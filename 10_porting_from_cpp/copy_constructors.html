<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Copy Constructor / Assignment Operators - A Guide to Porting C/C++ to Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book that explains how to port code from C++ to Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="../foreword.html"><strong aria-hidden="true">3.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="../credits.html"><strong aria-hidden="true">4.</strong> Credits</a></li><li class="chapter-item expanded "><a href="../notation.html"><strong aria-hidden="true">5.</strong> Notation used through this book</a></li><li class="chapter-item expanded "><a href="../01_setting_up_rust/index.html"><strong aria-hidden="true">6.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="../02_c_and_cpp_background/index.html"><strong aria-hidden="true">7.</strong> C and C++ Background</a></li><li class="chapter-item expanded "><a href="../03_rust_background/index.html"><strong aria-hidden="true">8.</strong> Rust Background</a></li><li class="chapter-item expanded "><a href="../04_start_simple/index.html"><strong aria-hidden="true">9.</strong> Let's Start Simple</a></li><li class="chapter-item expanded "><a href="../05_compiling_and_linking/index.html"><strong aria-hidden="true">10.</strong> Compiling and Linking in More Detail</a></li><li class="chapter-item expanded "><a href="../06_source_layout/index.html"><strong aria-hidden="true">11.</strong> Source Layout and Other General Points</a></li><li class="chapter-item expanded "><a href="../07_namespacing_with_modules/index.html"><strong aria-hidden="true">12.</strong> Namespacing With Modules</a></li><li class="chapter-item expanded "><a href="../08_porting_code/index.html"><strong aria-hidden="true">13.</strong> Porting Code</a></li><li class="chapter-item expanded "><a href="../09_features_compared/index.html"><strong aria-hidden="true">14.</strong> Features of Rust compared with C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_features_compared/types.html"><strong aria-hidden="true">14.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="../09_features_compared/strings.html"><strong aria-hidden="true">14.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../09_features_compared/variables.html"><strong aria-hidden="true">14.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../09_features_compared/literals.html"><strong aria-hidden="true">14.4.</strong> Literals</a></li><li class="chapter-item expanded "><a href="../09_features_compared/collections.html"><strong aria-hidden="true">14.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../09_features_compared/structs.html"><strong aria-hidden="true">14.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../09_features_compared/comments.html"><strong aria-hidden="true">14.7.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../09_features_compared/references_and_borrowing.html"><strong aria-hidden="true">14.8.</strong> Lifetimes, References and Borrowing</a></li><li class="chapter-item expanded "><a href="../09_features_compared/expressions.html"><strong aria-hidden="true">14.9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/conditions.html"><strong aria-hidden="true">14.10.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/match.html"><strong aria-hidden="true">14.11.</strong> Switch / Match</a></li><li class="chapter-item expanded "><a href="../09_features_compared/casting.html"><strong aria-hidden="true">14.12.</strong> Casting</a></li><li class="chapter-item expanded "><a href="../09_features_compared/enums.html"><strong aria-hidden="true">14.13.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../09_features_compared/loops.html"><strong aria-hidden="true">14.14.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../09_features_compared/functions.html"><strong aria-hidden="true">14.15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/polymorphism.html"><strong aria-hidden="true">14.16.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../09_features_compared/error_handling.html"><strong aria-hidden="true">14.17.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../09_features_compared/closures.html"><strong aria-hidden="true">14.18.</strong> Lambda Expressions / Closures</a></li><li class="chapter-item expanded "><a href="../09_features_compared/generics.html"><strong aria-hidden="true">14.19.</strong> Templates / Generics</a></li><li class="chapter-item expanded "><a href="../09_features_compared/attributes.html"><strong aria-hidden="true">14.20.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="../09_features_compared/multthreading.html"><strong aria-hidden="true">14.21.</strong> Multi-threading</a></li><li class="chapter-item expanded "><a href="../09_features_compared/lint.html"><strong aria-hidden="true">14.22.</strong> Lint</a></li><li class="chapter-item expanded "><a href="../09_features_compared/macros.html"><strong aria-hidden="true">14.23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../09_features_compared/memory_allocation.html"><strong aria-hidden="true">14.24.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../09_features_compared/ffi.html"><strong aria-hidden="true">14.25.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/index.html"><strong aria-hidden="true">15.</strong> Porting from C/C++ to Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_porting_from_cpp/copy_constructors.html" class="active"><strong aria-hidden="true">15.1.</strong> Copy Constructor / Assignment Operators</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/missing_braces.html"><strong aria-hidden="true">15.2.</strong> Missing Braces in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/assignments_in_conditionals.html"><strong aria-hidden="true">15.3.</strong> Assignment in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_member_initialisation.html"><strong aria-hidden="true">15.4.</strong> Class Member Initialisation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/splitting_code_between_headers_and_sources.html"><strong aria-hidden="true">15.5.</strong> Headers and Sources</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/forward_declarations.html"><strong aria-hidden="true">15.6.</strong> Forward Declarations</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/namespace_collisions.html"><strong aria-hidden="true">15.7.</strong> Namespace Collisions</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/macros.html"><strong aria-hidden="true">15.8.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/type_mismatching.html"><strong aria-hidden="true">15.9.</strong> Type Mismatching</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_constructors.html"><strong aria-hidden="true">15.10.</strong> Explicit / Implicit Class Constructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/poor_lifetime_enforcement.html"><strong aria-hidden="true">15.11.</strong> Poor Lifetime Enforcement</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/memory_allocation.html"><strong aria-hidden="true">15.12.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/null_pointers.html"><strong aria-hidden="true">15.13.</strong> Null Pointers</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/virtual_destructors.html"><strong aria-hidden="true">15.14.</strong> Virtual Destructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/exceptions.html"><strong aria-hidden="true">15.15.</strong> Exception Handling / Safety</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/templates.html"><strong aria-hidden="true">15.16.</strong> Templates vs Generics</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/multiple_inheritance.html"><strong aria-hidden="true">15.17.</strong> Multiple Inheritance</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/linker.html"><strong aria-hidden="true">15.18.</strong> Linker Errors</a></li></ol></li><li class="chapter-item expanded "><a href="../11_debugging_rust/index.html"><strong aria-hidden="true">16.</strong> Debugging Rust</a></li><li class="chapter-item expanded "><a href="../12_memory_management/index.html"><strong aria-hidden="true">17.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../13_std_library/index.html"><strong aria-hidden="true">18.</strong> Rust's std:: library</a></li><li class="chapter-item expanded "><a href="../14_rust_cookbook/index.html"><strong aria-hidden="true">19.</strong> Rust Cookbook</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Porting C/C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="copy-constructor--assignment-operators"><a class="header" href="#copy-constructor--assignment-operators">Copy Constructor / Assignment Operators</a></h1>
<p>Imagine this class in C++:</p>
<pre><code class="language-c++">struct Person {
    //...
};

class PersonList {
  std::vector&lt;Person&gt; *personList_;
public:
  PersonList() : personList_(new std::vector&lt;Person&gt;) {
  }

  ~PersonList() {
    delete personList_;
  }

  // ... Methods to add / search list
};
</code></pre>
<p>Note we're deliberately going to use a raw pointer to a vector for illustrative purposes. In your real code you'd probably use a scoped pointer.</p>
<p>Prior to C++11, all assignment was via copy construction and assignment operators. You would copy one instance to another via a constructor and also by an assignment operator. In some cases a constructor will be used instead of an assignment:</p>
<pre><code class="language-c++">PersonList x; 
PersonList y = x; // Copy constructor, not assignment
PersonList z;
z = x; // Assignment operator
</code></pre>
<p>By default C++ generates all the code to copy and assign the bytes in one class to another without any effort. Lucky us!</p>
<p>Except we're not lucky, we just got slimed. The default byte copy takes the pointer in <code>personList_</code> and makes a 
copy of it. Now if we copy <code>x</code> to <code>y</code>, or assign <code>x</code> to <code>z</code> we have three classes pointing to the same private data! 
On top of that, <code>z</code> allocated its own <code>personList_</code> during its default constructor but the byte copy assignment 
overwrote it with the one from <code>x</code> so its old <code>personList_</code> value just leaks.</p>
<p>Of course we might be able to use a <code>std::unique_ptr</code> to hold our pointer. In which case the compiler would 
generate an error. But it might not always be that simple. <code>personList_</code> may have been opaquely 
allocated by an external library so have no choice but to manage its lifetime through the constructor and destructor.</p>
<h2 id="the-rule-of-three"><a class="header" href="#the-rule-of-three">The Rule of Three</a></h2>
<p>This is such a terrible bug enabling problem in C++ that it has given rise to the so-called the Rule of Three<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>The rule says that if we explicitly declare a destructor, copy constructor or copy assignment operator in a C++ class
then we probably need to implement all three of them to safely handle assignment and construction. In other words 
the burden for fixing C++'s default and dangerous behaviour falls onto the developer.</p>
<p>So let's fix the class:</p>
<pre><code class="language-c++">struct Person {
    //...
};

class PersonList {
    std::vector&lt;Person&gt; *personList_;
public:
    PersonList() : personList_(new std::vector&lt;Person&gt;) {
    }

    PersonList(const PersonList &amp;other) :
            personList_(new std::vector&lt;Person&gt;)    {
        personList_-&gt;insert(
                personList_-&gt;end(), other.personList_-&gt;begin(),
                other.personList_-&gt;end());
    }

    ~PersonList() {
        delete personList_;
    }

    PersonList &amp; operator=(const PersonList &amp;other) {
        // Don't forget to check if someone assigns an object to itself
        if (&amp;other != this) {
            personList_-&gt;clear();
            personList_-&gt;insert(
                    personList_-&gt;end(), other.personList_-&gt;begin(),
                    other.personList_-&gt;end());
        }
        return *this;
    }

    // ... Methods to add / search list
};
</code></pre>
<p>What a mess!</p>
<p>We've added a copy constructor and an assignment operator to the class to handle copying safely. The code even had to check if it was being assigned to itself in case someone wrote <code>x = x</code>. Without that test, the receiving instance would clear itself in preparation to adding elements from itself which would of course wipe out all its contents.</p>
<p>Alternatively we might disable copy / assignments by creating private constructors that prevents them being called by external code:</p>
<pre><code class="language-c++">class PersonList {
    std::vector&lt;Person&gt; *personList_;

private:
    PersonList(const PersonList &amp;other) {}
    PersonList &amp; operator=(const PersonList &amp;other) { return *this; }

public:
    PersonList() : personList_(new std::vector&lt;Person&gt;) {
    }

    ~PersonList() {
        delete personList_;
    }
    // ... Methods to add / search list
};
</code></pre>
<p>Another alternative would be to use noncopyable types within the class itself. For example, the copy would fail if the pointer were managed with a C++11 <code>std::unique_ptr</code> (or Boost's <code>boost::scoped_ptr</code>).</p>
<p>Boost also provides a <code>boost::noncopyable</code> class which provides yet another option. Classes may inherit from noncopyable which implements a private copy constructor and assignment operator so any code that tries to copy will generate a compile error.</p>
<h2 id="move-constructor"><a class="header" href="#move-constructor">Move Constructor</a></h2>
<p>C++11 introduces move semantics. That basically you can avoid copying from one instance to another and instead <em>move</em>. A move essentially means shifting all the bytes over from one class to another and then rendering the first class in a valid, inoperable state.</p>
<p>In our <code>PersonList</code> adding a move constructor would be relatively simple - we put the pointer in the new class and render the old pointer as null. A move constructor uses a <code>&amp;&amp;</code> notation.</p>
<pre><code class="language-c++">    PersonList(const PersonList &amp;&amp;other) :
      personList_(nullptr) {
      personList_ = other.personList_;
      other.personList_ = nullptr;
    }
</code></pre>
<h2 id="move-assignment-operator"><a class="header" href="#move-assignment-operator">Move assignment operator</a></h2>
<p>Ah, but we also need a move assignment operator:</p>
<pre><code class="language-c++">  PersonList &amp; operator=(const PersonList &amp;&amp;other) {
      // Don't forget to check if someone assigns an object to itself
      if (&amp;other != this) {
          // We have to clear out anything we're holding already
          if (this-&gt;personList_) {
            delete this-&gt;personList_;
          }
          // Now take the other guy's data
          this.personList_ = other.personList_;
          other.personList_ = nullptr;
      }
      return *this;
  }
</code></pre>
<p>And finally, our constructor needs tweaking since if data moves out of us, we need to ensure we test for that before deleting it.</p>
<pre><code class="language-c++">  ~PersonList() {
    if (personList_)
        delete personList_;
    }
  }
</code></pre>
<h2 id="the-rule-of-five"><a class="header" href="#the-rule-of-five">The Rule of Five</a></h2>
<p>So adding a move constructor and move assignment operator means the Rule of Three has become the Rule of Five(!).</p>
<p>What a mess.</p>
<h2 id="how-rust-helps"><a class="header" href="#how-rust-helps">How Rust helps</a></h2>
<h3 id="move-is-the-default"><a class="header" href="#move-is-the-default">Move is the default</a></h3>
<p>Rust helps by making move semantics the default. i.e. unless you need to copy data from one instance to another, you don't. If you assign a struct from one variable to another, ownership moves with it. The old variable is marked invalid by the compiler and it is an error to access it.</p>
<p>But if you do want to copy data from one instance to another then you have two choices.</p>
<ul>
<li>Implement the <code>Clone</code> trait. Your struct will have an explicit <code>clone()</code> function you can call to make a copy of the data.</li>
<li>Implement the <code>Copy</code> trait. Your struct will now implicitly copy on assignment instead of move. Implementing <code>Copy</code> also implies implementing <code>Clone</code> so you can still explicitly call <code>clone()</code> if you prefer.</li>
</ul>
<p>Primitive types such as integers, chars, bools etc. implement <code>Copy</code> so you can just assign one to another</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is all good
let x = 8;
let y = x;
y = 20;
assert_eq!(x, 8);
<span class="boring">}
</span></code></pre></pre>
<p>But a <code>String</code> cannot be copied this way. A string has an internal heap allocated pointer so copying is a more expensive operation. So <code>String</code> only implements the <code>Clone</code> trait which requires you to explicitly duplicate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let copyright = &quot;Copyright 2017 Acme Factory&quot;.to_string();
let copyright2 = copyright.clone();
<span class="boring">}
</span></code></pre></pre>
<p>The default for any struct is that it can neither be copied nor cloned.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
  name: String,
  age: u8
}
<span class="boring">}
</span></code></pre></pre>
<p>The following code will create a <code>Person</code> object, assigns it to <code>person1</code>. And when <code>person1</code> is assigned to <code>person2</code>, ownership of the data also moves:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let person1 = Person { name: &quot;Tony&quot;.to_string(), age: 38u8 };
let person2 = person1;
<span class="boring">}
</span></code></pre></pre>
<p>Attempting to use <code>person1</code> after ownership moves to <code>person2</code> will generate a compile error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, person1.name); // Error, use of a moved value
<span class="boring">}
</span></code></pre></pre>
<p>To illustrate consider this Rust which is equivalent to the PersonList we saw in C++</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PersonList {
    pub persons: Vec&lt;Person&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>We can see that <code>PersonList</code> has a <code>Vec</code> vector of <code>Person</code> objects. Under the covers the <code>Vec</code>  will allocate space in the heap to store its data.</p>
<p>Now let's use it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = PersonList { persons: Vec::new(), };
let mut y = x;
// x is not the owner any more...
x.persons.push(Person{ name: &quot;Fred&quot;.to_string(), age: 30u8} );
<span class="boring">}
</span></code></pre></pre>
<p>The variable <code>x</code> is on the stack and is a <code>PersonList</code> but the persons member is partly allocated from the heap.</p>
<p>The variable <code>x</code> is bound to a PersonList on the stack. The vector is created in the heap. If we assign <code>x</code> to <code>y</code> then we could have two stack objects sharing the same pointer on the heap in the same way we did in C++.</p>
<p>But Rust stops that from happening. When we assign <code>x</code> to <code>y</code>, the compiler will do a bitwise copy of the data in x, but it will bind ownership to <code>y</code>.  When we try to access the in the old var Rust generates a compile error.</p>
<pre><code>error[E0382]: use of moved value: `*x.persons`
   |
10 | let mut y = x;
   |     ----- value moved here
11 | x.persons.push(Person{});
   | ^^^^^^^^^ value used here after move
   |
   = note: move occurs because `x` has type `main::PersonList`, which does not implement the `Copy` trait
</code></pre>
<p>Rust has stopped the problem that we saw in C++. Not only stopped it but told us why it stopped it - the value moved from x to y and so we can't use x any more.</p>
<h3 id="implementing-the-copy-trait"><a class="header" href="#implementing-the-copy-trait">Implementing the Copy trait</a></h3>
<p>The <code>Copy</code> trait allows us to do direct assignment between variables. The trait has no functions, and acts as a marker in the code to denote data that should be duplicated on assignment.</p>
<p>You can implement the <code>Copy</code> trait by deriving it, or implementing it. But you can only do so if all the members of the struct also derive the trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct PersonKey {
  id: u32,
  age: u8,
}

// Alternatively...

impl Copy for PersonKey {}

impl Clone for PersonKey {
  fn clone(&amp;self) -&gt; PersonKey {
     *self
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>So <code>PersonKey</code> is copyable because types <code>u32</code> and <code>u8</code> are also copyable and the compiler will take the <code>#[derive(Copy)]</code> directive and modify the move / copy semantics for the struct.</p>
<p>But when a struct contains a a type that does not implement <code>Copy</code> you will get a compiler error. So this struct <code>Person</code> will cause a compiler error because <code>String</code> does not implement <code>Copy:</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Person {
  name: String,
  age: u8
}
// Compiler error!
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-the-clone-trait"><a class="header" href="#implementing-the-clone-trait">Implementing the Clone trait</a></h3>
<p>The <code>Clone</code> trait adds a <code>clone()</code> function to your struct that produces an independent copy of it. We can derive it if every member of the struct can be cloned which in the case of <code>Person</code> it can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Person {
  name: String,
  age: u8
}
...
let x = Person { /*...*/ };
let y = x.clone();
<span class="boring">}
</span></code></pre></pre>
<p>Now that Person derives <code>Clone</code>, we can do the same for PersonList because all its member types implement that trait - a Person can be cloned, a Vec can be cloned, and a Box can be cloned:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct PersonList {
    pub persons: Box&lt;Vec&lt;Person&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can clone <code>x</code> into <code>y</code> and we have two independent copies.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//...
let mut x = PersonList { persons: Box::new(Vec::new()), };
let mut y = x.clone();
// x and y are two independent lists now, not shared
x.persons.push(Person{ name: &quot;Fred&quot;.to_string(), age: 30} );
y.persons.push(Person{ name: &quot;Mary&quot;.to_string(), age: 24} );
<span class="boring">}
</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In summary, Rust stops us from getting into trouble by treated assigns as moves when a non-copyable variable is assigned from one to another. But if we want to be able to clone / copy we can make our intent explicit and do that too.</p>
<p>C++ just lets us dig a hole and fills the dirt in on top of us.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../10_porting_from_cpp/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../10_porting_from_cpp/missing_braces.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../10_porting_from_cpp/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../10_porting_from_cpp/missing_braces.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
