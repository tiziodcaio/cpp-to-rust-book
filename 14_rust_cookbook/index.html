<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Cookbook - A Guide to Porting C/C++ to Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book that explains how to port code from C++ to Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="../foreword.html"><strong aria-hidden="true">3.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="../credits.html"><strong aria-hidden="true">4.</strong> Credits</a></li><li class="chapter-item expanded "><a href="../notation.html"><strong aria-hidden="true">5.</strong> Notation used through this book</a></li><li class="chapter-item expanded "><a href="../01_setting_up_rust/index.html"><strong aria-hidden="true">6.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="../02_c_and_cpp_background/index.html"><strong aria-hidden="true">7.</strong> C and C++ Background</a></li><li class="chapter-item expanded "><a href="../03_rust_background/index.html"><strong aria-hidden="true">8.</strong> Rust Background</a></li><li class="chapter-item expanded "><a href="../04_start_simple/index.html"><strong aria-hidden="true">9.</strong> Let's Start Simple</a></li><li class="chapter-item expanded "><a href="../05_compiling_and_linking/index.html"><strong aria-hidden="true">10.</strong> Compiling and Linking in More Detail</a></li><li class="chapter-item expanded "><a href="../06_source_layout/index.html"><strong aria-hidden="true">11.</strong> Source Layout and Other General Points</a></li><li class="chapter-item expanded "><a href="../07_namespacing_with_modules/index.html"><strong aria-hidden="true">12.</strong> Namespacing With Modules</a></li><li class="chapter-item expanded "><a href="../08_porting_code/index.html"><strong aria-hidden="true">13.</strong> Porting Code</a></li><li class="chapter-item expanded "><a href="../09_features_compared/index.html"><strong aria-hidden="true">14.</strong> Features of Rust compared with C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_features_compared/types.html"><strong aria-hidden="true">14.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="../09_features_compared/strings.html"><strong aria-hidden="true">14.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../09_features_compared/variables.html"><strong aria-hidden="true">14.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../09_features_compared/literals.html"><strong aria-hidden="true">14.4.</strong> Literals</a></li><li class="chapter-item expanded "><a href="../09_features_compared/collections.html"><strong aria-hidden="true">14.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../09_features_compared/structs.html"><strong aria-hidden="true">14.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../09_features_compared/comments.html"><strong aria-hidden="true">14.7.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../09_features_compared/references_and_borrowing.html"><strong aria-hidden="true">14.8.</strong> Lifetimes, References and Borrowing</a></li><li class="chapter-item expanded "><a href="../09_features_compared/expressions.html"><strong aria-hidden="true">14.9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/conditions.html"><strong aria-hidden="true">14.10.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/match.html"><strong aria-hidden="true">14.11.</strong> Switch / Match</a></li><li class="chapter-item expanded "><a href="../09_features_compared/casting.html"><strong aria-hidden="true">14.12.</strong> Casting</a></li><li class="chapter-item expanded "><a href="../09_features_compared/enums.html"><strong aria-hidden="true">14.13.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../09_features_compared/loops.html"><strong aria-hidden="true">14.14.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../09_features_compared/functions.html"><strong aria-hidden="true">14.15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/polymorphism.html"><strong aria-hidden="true">14.16.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../09_features_compared/error_handling.html"><strong aria-hidden="true">14.17.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../09_features_compared/closures.html"><strong aria-hidden="true">14.18.</strong> Lambda Expressions / Closures</a></li><li class="chapter-item expanded "><a href="../09_features_compared/generics.html"><strong aria-hidden="true">14.19.</strong> Templates / Generics</a></li><li class="chapter-item expanded "><a href="../09_features_compared/attributes.html"><strong aria-hidden="true">14.20.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="../09_features_compared/multthreading.html"><strong aria-hidden="true">14.21.</strong> Multi-threading</a></li><li class="chapter-item expanded "><a href="../09_features_compared/lint.html"><strong aria-hidden="true">14.22.</strong> Lint</a></li><li class="chapter-item expanded "><a href="../09_features_compared/macros.html"><strong aria-hidden="true">14.23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../09_features_compared/memory_allocation.html"><strong aria-hidden="true">14.24.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../09_features_compared/ffi.html"><strong aria-hidden="true">14.25.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/index.html"><strong aria-hidden="true">15.</strong> Porting from C/C++ to Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_porting_from_cpp/copy_constructors.html"><strong aria-hidden="true">15.1.</strong> Copy Constructor / Assignment Operators</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/missing_braces.html"><strong aria-hidden="true">15.2.</strong> Missing Braces in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/assignments_in_conditionals.html"><strong aria-hidden="true">15.3.</strong> Assignment in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_member_initialisation.html"><strong aria-hidden="true">15.4.</strong> Class Member Initialisation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/splitting_code_between_headers_and_sources.html"><strong aria-hidden="true">15.5.</strong> Headers and Sources</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/forward_declarations.html"><strong aria-hidden="true">15.6.</strong> Forward Declarations</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/namespace_collisions.html"><strong aria-hidden="true">15.7.</strong> Namespace Collisions</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/macros.html"><strong aria-hidden="true">15.8.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/type_mismatching.html"><strong aria-hidden="true">15.9.</strong> Type Mismatching</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_constructors.html"><strong aria-hidden="true">15.10.</strong> Explicit / Implicit Class Constructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/poor_lifetime_enforcement.html"><strong aria-hidden="true">15.11.</strong> Poor Lifetime Enforcement</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/memory_allocation.html"><strong aria-hidden="true">15.12.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/null_pointers.html"><strong aria-hidden="true">15.13.</strong> Null Pointers</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/virtual_destructors.html"><strong aria-hidden="true">15.14.</strong> Virtual Destructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/exceptions.html"><strong aria-hidden="true">15.15.</strong> Exception Handling / Safety</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/templates.html"><strong aria-hidden="true">15.16.</strong> Templates vs Generics</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/multiple_inheritance.html"><strong aria-hidden="true">15.17.</strong> Multiple Inheritance</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/linker.html"><strong aria-hidden="true">15.18.</strong> Linker Errors</a></li></ol></li><li class="chapter-item expanded "><a href="../11_debugging_rust/index.html"><strong aria-hidden="true">16.</strong> Debugging Rust</a></li><li class="chapter-item expanded "><a href="../12_memory_management/index.html"><strong aria-hidden="true">17.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../13_std_library/index.html"><strong aria-hidden="true">18.</strong> Rust's std:: library</a></li><li class="chapter-item expanded "><a href="../14_rust_cookbook/index.html" class="active"><strong aria-hidden="true">19.</strong> Rust Cookbook</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Porting C/C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-cookbook"><a class="header" href="#rust-cookbook">Rust Cookbook</a></h1>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<h3 id="convert-a-number-to-a-string"><a class="header" href="#convert-a-number-to-a-string">Convert a number to a string</a></h3>
<p>Let's say you have an integer you want to turn into a string.</p>
<p>In C++ you might do one of the following:</p>
<pre><code class="language-c++">const int value = 17;
std::string value_as_string;

// Nonstandard C itoa() (also not thread safe)
value_as_string = itoa(value);

// OR _itoa()
char buffer[16];
_itoa(value, buffer, 10);

// OR
sprintf(buffer, &quot;%d&quot;, value);

// OR
stringstream ss;
ss &lt;&lt; value;
value_as_string = ss.str();

// OR (boost)
value_as_string = boost::lexical_cast&lt;std::string&gt;(ivalue);
</code></pre>
<p>All of these have issues. Some are extensions to the standard, others may not be thread safe, some may break if <code>value</code> was changed to another type, e.g. <code>long long</code>.</p>
<p>Rust makes it far easier because numeric primitives implement a trait called ToString. The ToString trait has a to_string() function. So to convert the number to string is as simple as this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 17u32;
let value_as_string = value.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>The same is true for a floating point number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 100.00345f32;
let value_as_string = value.to_string();
<span class="boring">}
</span></code></pre></pre>
<h3 id="convert-a-number-to-a-string-with-precision--padding"><a class="header" href="#convert-a-number-to-a-string-with-precision--padding">Convert a number to a string with precision / padding</a></h3>
<p>In C you would add precision of padding using printf operations:</p>
<pre><code class="language-c++">double value = 1234.66667;
char result[32];
sprintf(result, &quot;%08.2d&quot;, value);
</code></pre>
<p>In C++ you could use the C way (and to be honest it's easier than what is written below), or you can set padding and precision through an ostream:</p>
<pre><code class="language-c++">// TODO validate
double value = 1234.66667;
ostringstream ss;
ss &lt;&lt; setfill('0') &lt;&lt; setw(8) &lt;&lt; setprecision(2) &lt;&lt; value;
</code></pre>
<p>In Rust you can use format!() [https://doc.rust-lang.org/std/fmt/] for this purpose and it is similar to printf / sprintf:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 1234.66667;
let value_as_string = format!(&quot;{:08.2}&quot;, value);
println!(&quot;value = {}&quot;, value_as_string);
<span class="boring">}
</span></code></pre></pre>
<p>Output</p>
<pre><code>value = 01234.67
</code></pre>
<h3 id="convert-a-number-to-a-localized-string"><a class="header" href="#convert-a-number-to-a-localized-string">Convert a number to a localized string</a></h3>
<p>Some locales will use dots or commas for separators. Some languages will use dots or commas for the decimal place. In order to format these strings we need to make use of the locale.</p>
<p>TODO</p>
<h3 id="convert-a-string-to-a-number"><a class="header" href="#convert-a-string-to-a-number">Convert a string to a number</a></h3>
<p>In C / C++ a number might be converted from a string to a number in a number of ways</p>
<pre><code class="language-c++">
int value = atoi(value_as_str);

</code></pre>
<p>TODO</p>
<p>In Rust we have a &amp;str containing a number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value_as_str = &quot;12345&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Any type that implements a trait called FromStr can take its type from a string. All the standard primitive types implement FromStr so we can simply say this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value_as_str = &quot;12345&quot;;
let value = i32::from_str(value_as_str).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Note the unwrap() at the end - the FromStr::from_str() returns the value inside a Result&lt;value, error&gt;, to allow for the possibility that the string cannot be parsed. Production code should test for errors before calling unwrap() or it will panic.</p>
<p>Another way to get the string is to call parse() on the &amp;str or String itself. In this case, you use a slightly odd looking syntax nicknamed 'turbofish' which looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;
let value_as_str = &quot;12345&quot;;
let value = value_as_str.parse::&lt;i32&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The string's implementation of parse() is a generic that works with any type implementing <code>FromStr</code>. So calling <code>parse::&lt;i32&gt;</code> is equivalent to calling <code>i32::from_str()</code>.</p>
<p>Note one immediate advantage of Rust is it uses string slices. That means you could have a long string with many numbers separated by delimiters and parse numbers straight out of the middle of it without constructing intermediate copies.</p>
<h3 id="converting-between-numeric-types"><a class="header" href="#converting-between-numeric-types">Converting between numeric types</a></h3>
<p>Converting between numeric types is as easy as using the &quot;as&quot; keyword.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = 1234.42f32;
let i = f as i32;
println!(&quot;Value = {}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<p>The result in i is the integer part of f.</p>
<pre><code>Value = 1234
</code></pre>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Rust comes with some very powerful functions that are attached to every &amp;str and String type. These mostly correspond to what you may be used to on the std::string class and in boost string algorithms.</p>
<p>Most find / match / trim / split string operations in Rust are efficient because they neither modify the existing string, nor return a duplicate to you. Instead they return slices, i.e. a pointer and a length into your existing string to denote the range that is the result.</p>
<p>It is only operations that modify the string contents themselves such as creating upper or lowercase versions that will return a new copy of a string.</p>
<h3 id="trimming-a-string"><a class="header" href="#trimming-a-string">Trimming a string</a></h3>
<p>Spaces, tabs and other Unicode characters defined as whitespace can be trimmed from a string.</p>
<p>All strings have access to the following functions</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trim(&amp;self) -&gt; &amp;str
fn trim_left(&amp;self) -&gt; &amp;str
fn trim_right(&amp;self) -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<p>Note the signatures of these functions - they are not mutable. The functions return a slice of the string that excludes the leading and / or trailing whitespace removed. In other words it is not duplicating the string, nor is it modifying the existing string. Instead it is just telling you what the trimmed range is within the &amp;str you're already looking at.</p>
<p>So</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let untrimmed_str = &quot; this is test with whitespace    \t&quot;;
let trimmed_str = untrimmed_str.trim();
println!(&quot;Trimmed str = \&quot;{}\&quot;&quot;, trimmed_str);
<span class="boring">}
</span></code></pre></pre>
<p>Yields:</p>
<pre><code>Trimmed str = &quot;this is test with whitespace&quot;
</code></pre>
<p>Also be aware that trim_left() and and trim_right() above are affected by the directionality of the string.</p>
<p>Most strings read from left-to-right, but strings in Arabic or Hebrew are read right-to-left and will start with a control character that sets their base direction right-to-left. If that character is present, trim_left() actually trims from the right and trim_right() trims from the left.</p>
<h3 id="get-the-length-of-a-string"><a class="header" href="#get-the-length-of-a-string">Get the length of a string</a></h3>
<p>Every &amp;str and String has a len() function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = &quot;All good things come to those who wait&quot;;
println!(&quot;Length = {}&quot;, message.len());
<span class="boring">}
</span></code></pre></pre>
<p>Note that len() is the length in bytes. If you want the number of characters you need to call message.chars().count(), e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = &quot;文字列の長さ&quot;;
assert_eq!(message.chars().count(), 6);
<span class="boring">}
</span></code></pre></pre>
<h3 id="splitting-a-string"><a class="header" href="#splitting-a-string">Splitting a string</a></h3>
<p>String slices and String have a variety of <code>split</code> methods that return an iterable collection of slices on a string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let input = &quot;20,30,400,100,21,-1&quot;;
let values : Vec&lt;&amp;str&gt; = input.split(&quot;,&quot;).collect();
for (i, s) in values.iter().enumerate() {
    println!(&quot;Value {} = {}&quot;, i, s);
}
<span class="boring">}
</span></code></pre></pre>
<p>The standard <code>split()</code> takes a string pattern for the delimiter and returns a <code>std::str::Split</code> struct that is an double-ended iterator representation of the matching result. We could call the iterator directly if we so wished but the <code>collect()</code> method above puts the values of the iterator into a <code>Vec&lt;&amp;str&gt;</code>.</p>
<pre><code>Value 0 = 20
Value 1 = 30
Value 2 = 400
Value 3 = 100
Value 4 = 21
Value 5 = -1
</code></pre>
<p>A string can also be split on an index, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (left, right) = &quot;No Mister Bond I expect you to die&quot;.split_at(14);
println!(&quot;Left = {}&quot;, left);
println!(&quot;Right = {}&quot;, right);
<span class="boring">}
</span></code></pre></pre>
<p>Note that index is the <em>byte index</em>! The function will panic if the index is in the centre of a UTF-8 codepoint.</p>
<p>Another useful function is <code>split_whitespace</code> that splits on tabs, spaces, newlines and other Unicode whitespace. Any amount of whitespace is treated as a single delimiter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Split whitespace
for s in &quot; All good   \n\n\tthings  to those who    wait&quot;.split_whitespace() {
    println!(&quot;Part - {}&quot;, s);
}
<span class="boring">}
</span></code></pre></pre>
<p>Yields the output.</p>
<pre><code>Part - All
Part - good
Part - things
Part - to
Part - those
Part - who
Part - wait
</code></pre>
<h3 id="tokenizing-a-string"><a class="header" href="#tokenizing-a-string">Tokenizing a string</a></h3>
<p>TODO</p>
<h3 id="joining-strings-together"><a class="header" href="#joining-strings-together">Joining strings together</a></h3>
<p>TODO</p>
<h3 id="getting-a-substring"><a class="header" href="#getting-a-substring">Getting a substring</a></h3>
<p>TODO</p>
<h3 id="converting-a-string-between-upper-and-lower-case"><a class="header" href="#converting-a-string-between-upper-and-lower-case">Converting a string between upper and lower case</a></h3>
<p>Strings have these functions for converting between upper and lower case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_lowercase(&amp;self) -&gt; String
fn to_uppercase(&amp;self) -&gt; String
<span class="boring">}
</span></code></pre></pre>
<p>These functions will return a new String that contains the upper or lower case version of the input. Upper and lower case are defined by Unicode rules. Languages that have no upper or lowercase strings may return the same characters.</p>
<h3 id="doing-a-case-insensitive-compare"><a class="header" href="#doing-a-case-insensitive-compare">Doing a case insensitive compare</a></h3>
<p>TODO</p>
<h3 id="using-regular-expression-matches"><a class="header" href="#using-regular-expression-matches">Using regular expression matches</a></h3>
<p>TODO</p>
<h2 id="date-and-time"><a class="header" href="#date-and-time">Date and Time</a></h2>
<h3 id="get-the-current-date-and-time"><a class="header" href="#get-the-current-date-and-time">Get the current date and time</a></h3>
<p>TODO time_rs</p>
<h3 id="utc"><a class="header" href="#utc">UTC</a></h3>
<p>TODO explain what UTC is and why maintaining time in UTC is vital Epochs etc.
TODO preamble about what an epoch is, the Unix epoch and other epochs</p>
<h3 id="setting-a-timer"><a class="header" href="#setting-a-timer">Setting a timer</a></h3>
<p>TODO setting a timer</p>
<h3 id="system-time-vs-utc"><a class="header" href="#system-time-vs-utc">System time vs UTC</a></h3>
<p>TODO the reason timers might be set in system uptime vs timers being set in UTC. Answer because users and NTP can change the UTC time wherease system time is relative to bootup. So setting a timer to run 10s from now will always work against system time where setting a timer to run 10s from now in UTC could fail if the OS sets time back by an hour.</p>
<h3 id="formatting-a-date-as-a-string"><a class="header" href="#formatting-a-date-as-a-string">Formatting a date as a string</a></h3>
<p>TODO standard date formatting UTC
TODO example</p>
<h3 id="parsing-a-date-from-a-string"><a class="header" href="#parsing-a-date-from-a-string">Parsing a date from a string</a></h3>
<p>TODO parsing a date from a string's
TODO example</p>
<h3 id="performing-date--time-arithmetic"><a class="header" href="#performing-date--time-arithmetic">Performing date / time arithmetic</a></h3>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<h3 id="creating-a-static-array"><a class="header" href="#creating-a-static-array">Creating a static array</a></h3>
<p>An array primitive consists of a type and a length. e.g. a 16 kilobyte array of bytes can be created and zeroed like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values: [u8; 16384] = [0; 16384];
<span class="boring">}
</span></code></pre></pre>
<p>The variable specifies the type and length and the assignment operator assigns 0 to every element.</p>
<p>The type, length and values can be initialized implicitly in-place like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_array = [ &quot;Cat&quot;, &quot;Dog&quot;, &quot;Fish&quot;, &quot;Donkey&quot;, &quot;Albatross&quot; ];
println!(&quot;{:?}&quot;, my_array);
<span class="boring">}
</span></code></pre></pre>
<p>This is an array of 5 &amp;str values. The compiler will complain if we try to mix types in the array.
We could also declare the array and manipulate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_array: [&amp;'static str; 5] = [&quot;&quot;; 5];
// Set some values
my_array[0] = &quot;Cat&quot;;
my_array[1] = &quot;Dog&quot;;
my_array[2] = &quot;Fish&quot;;
my_array[3] = &quot;Donkey&quot;;
my_array[4] = &quot;Albatross&quot;;
println!(&quot;{:?}&quot;, my_array);
<span class="boring">}
</span></code></pre></pre>
<p>Note in this case we declared the array, each element received an empty value. Then our code programmatically set the new element value.
The latter form would obviously be useful for arrays that change. The latter would be useful for arrays which do not.</p>
<h3 id="creating-a-dynamic-vector"><a class="header" href="#creating-a-dynamic-vector">Creating a dynamic vector</a></h3>
<p>A vector is a linear array of values. Unlike an array which has a fixed length, a vector can grow or shrink over time.</p>
<p>A vector can be created using the vec! macro like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_vector = vec![1984, 1985, 1988, 1995, 2001];
<span class="boring">}
</span></code></pre></pre>
<p>This creates a mutable Vec and prepopulates it with 5 values. Note how the vec! macro can use square brackets for its arguments. We could have used round brackets and it would have meant the same.</p>
<p>A new Vec can also be made using Vec::new() or Vec::with_capacity(size)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_array = Vec::new();
my_array.push(&quot;Hello&quot;);
let my_presized_array = Vec::with_capacity(100);
<span class="boring">}
</span></code></pre></pre>
<p>It is strongly recommended you use Vec::with_capacity() to create a vector with enough capacity for maximum number of elements you expect the vector to contain. It prevents the runtime from having to reallocate and copy data if you keep exceeding the existing capacity. It also significantly reduces heap fragmentation.</p>
<h3 id="removing-values-from-a-vector"><a class="header" href="#removing-values-from-a-vector">Removing values from a vector</a></h3>
<p>Sometimes you want to strip out values from a list which match some predicate. In which case there is a handy function for that purpose.
TODO <code>.retain</code></p>
<h3 id="sorting-a-vector"><a class="header" href="#sorting-a-vector">Sorting a vector</a></h3>
<p>A vector can be sorted by the natural sort order of the elements it contains:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values = vec![ 99, -1, 3, 555, 76];
values.sort();
println!(&quot;Values = {:?}&quot;, values);
<span class="boring">}
</span></code></pre></pre>
<p>Sorting is done using the Ord trait and calling Ord::cmp() on the elements to compare them to each other.</p>
<p>Comparison can also be done through a closure and Vec::sort_by()</p>
<p>TODO <code>.sort_by</code>
TODO <code>.sort_by_key</code></p>
<h3 id="stripping-out-duplicates-from-a-vector"><a class="header" href="#stripping-out-duplicates-from-a-vector">Stripping out duplicates from a vector</a></h3>
<p>Assuming your vec is sorted, you can strip out consecutive duplicate entries using dedup().
This function won't work and the result will be undefined if your vector is not sorted.
TODO .dedup</p>
<h3 id="creating-a-linked-list"><a class="header" href="#creating-a-linked-list">Creating a linked list</a></h3>
<p>A linked list is more suitable than a vector when items are likely to be inserted or removed from either end or from points within the list.</p>
<p><code>std::collections::LinkedList</code></p>
<h3 id="creating-a-hash-set"><a class="header" href="#creating-a-hash-set">Creating a hash set</a></h3>
<p>A hash set is a unique collection of objects. It is particularly useful for removing duplicates that might occur in the input.
<code>std::collections::HashSet</code></p>
<h3 id="creating-a-hash-map"><a class="header" href="#creating-a-hash-map">Creating a hash map</a></h3>
<p>A hash map consists of a key and a value. It is used for look up operations
<code>std::collections::HashMap</code></p>
<h3 id="iterating-collections"><a class="header" href="#iterating-collections">Iterating collections</a></h3>
<p>TODO</p>
<h3 id="iterator-adaptors"><a class="header" href="#iterator-adaptors">Iterator adaptors</a></h3>
<p>TODO</p>
<p>An adaptor turns the iterator into a new value</p>
<p><code>.enum</code>
<code>.map(X)</code>
<code>.take(N)</code>
<code>.filter(X)</code></p>
<h3 id="consuming-iterators"><a class="header" href="#consuming-iterators">Consuming iterators</a></h3>
<p>A consumer is a convenience way of iterating a collection and producing a value or a set of values from the result.</p>
<p><code>.collect()</code></p>
<p><code>.find()</code> will return the first matching element that matches the closure predicate. TODO</p>
<p><code>.fold()</code> is a way of doing calculations on the collection. It takes a base value, and then calls a closure to accumulate the value upon the result of the last value. TODO
Processing collections</p>
<h2 id="localization"><a class="header" href="#localization">Localization</a></h2>
<h3 id="unicode-considerations"><a class="header" href="#unicode-considerations">Unicode considerations</a></h3>
<p>TODO</p>
<h3 id="externalizing-strings"><a class="header" href="#externalizing-strings">Externalizing strings</a></h3>
<p>TODO</p>
<h3 id="building-strings-from-parameters"><a class="header" href="#building-strings-from-parameters">Building strings from parameters</a></h3>
<p>TODO</p>
<h3 id="creating-a-localization-file"><a class="header" href="#creating-a-localization-file">Creating a localization file</a></h3>
<p>TODO</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<h2 id="files-and-streams"><a class="header" href="#files-and-streams">Files and streams</a></h2>
<p>Rust comes with two standard modules:</p>
<ul>
<li>std::io contains various stream related traits and other functionality.</li>
<li>std::fs contains filesystem related functionality including the implementation of IO traits to work with files.</li>
</ul>
<h3 id="creating-a-directory"><a class="header" href="#creating-a-directory">Creating a directory</a></h3>
<p>A directory can be created with <code>std::fs::DirBuilder</code>, e.g.</p>
<pre><code>let result = DirBuilder::new().recursive(true).create(&quot;/tmp/work_dir&quot;);
</code></pre>
<h3 id="file-paths"><a class="header" href="#file-paths">File paths</a></h3>
<p>Windows and Unix systems have different notation for path separators and a number of other differences. e.g. Windows has drive letters, long paths, and network paths called UNCs.</p>
<p>Rust provides a PathBuf struct for manipulating paths and a Path which acts like a slice and can be the full path or just a portion of one.</p>
<p>TODO simple example of a path being created</p>
<p>TODO simple example of a Path slice in actively</p>
<p>TODO simple example of relative path made absolute</p>
<p>Windows has a bunch of path prefixes so std::path::Prefix provides a way to accessing those.</p>
<p>TODO example of a path being made from a drive letter and path</p>
<h3 id="opening-a-file"><a class="header" href="#opening-a-file">Opening a file</a></h3>
<p>A <code>File</code> is a reference to an open file on the filesystem. When the struct goes out of scope the file is closed. There are static functions for creating or opening a file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::prelude::*;
use std::fs::File;

let mut f = try!(File::open(&quot;myfile.txt&quot;));
TODO
<span class="boring">}
</span></code></pre></pre>
<p>Note that File::open() opens a file read-only by default. To open a file read-write, there is an OpenOptions struct that has methods to set the behaviour of the open file - read, write, create, append and truncate.</p>
<p>e.g. to open a file with read/write access, creating it if it does not already exist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::OpenOptions;

let file = OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(&quot;myfile.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="writing-to-a-file"><a class="header" href="#writing-to-a-file">Writing to a file</a></h3>
<p>TODO simple example of opening file to write</p>
<h3 id="reading-lines-from-a-file"><a class="header" href="#reading-lines-from-a-file">Reading lines from a file</a></h3>
<p>TODO simple example of opening file text mode, printing contents</p>
<h2 id="threading"><a class="header" href="#threading">Threading</a></h2>
<p>Rust actively enforces thread safety in your code. If you attempt to pass around data which is not marked thread safe (i.e. implements the Sync trait), you will get a compile error. If you use code which is implicitly not thread safe such as Rc&lt;&gt; you will get a compile error.</p>
<p>This enforcement means that Rust protects against data race conditions, however be aware it cannot protect against other forms of race conditions or deadlocks, e.g. thread 1 waits for resource B (held by thread 2) while thread 2 waits for resource A (held by thread 1).</p>
<h3 id="creating-a-thread"><a class="header" href="#creating-a-thread">Creating a thread</a></h3>
<p>Creating a thread is simple with a closure.</p>
<p>TODO</p>
<h3 id="waiting-for-a-thread-to-complete"><a class="header" href="#waiting-for-a-thread-to-complete">Waiting for a thread to complete</a></h3>
<p>TODO</p>
<h3 id="using-atomic-reference-counting"><a class="header" href="#using-atomic-reference-counting">Using atomic reference counting</a></h3>
<p>Rust provides two reference counting types. Type Rc&lt;&gt; is for code residing on the same thread and so the reference counting is not atomic. Type Arc&lt;&gt; is for code that runs on different threads and the reference counting is atomic.</p>
<p>An Arc&lt;&gt; can only hold a Sync derived object. Whenever you clone an Arc&lt;&gt; or its lifetime ends, the counter is atomically incremented or decremented. The last decrement to zero causes the object to be deleted.</p>
<p>TODO example</p>
<h3 id="locking-a-shared-resource"><a class="header" href="#locking-a-shared-resource">Locking a shared resource</a></h3>
<p>Message passing is a preferable way to prevent threads from sharing state but its not always possible.</p>
<p>Therefore Rust allows you to create a mutex and lock access to shared data. The guard that locks / unlocks the mutex protects the data and when the guard goes out of scope, the data is returned.</p>
<p>This style of guard is called TODO</p>
<h3 id="data-race-protection"><a class="header" href="#data-race-protection">Data race protection</a></h3>
<p>Rust can guarantee that protection from data races, i.e. more than one thread accessing / writing to the same data at the same time.</p>
<p>However even Rust cannot protect against the more general problem of race conditions. e.g. if two threads lock each other's data, then the code will deadlock. This is a problem that no language can solve.</p>
<h3 id="waiting-for-multiple-threads-to-finish"><a class="header" href="#waiting-for-multiple-threads-to-finish">Waiting for multiple threads to finish</a></h3>
<p>TODO</p>
<h3 id="sending-data-to-a-thread"><a class="header" href="#sending-data-to-a-thread">Sending data to a thread</a></h3>
<p>Any struct that implements the Send trait is treated safe to send to another thread. Of course that applies to</p>
<h3 id="receiving-data-from-a-thread"><a class="header" href="#receiving-data-from-a-thread">Receiving data from a thread</a></h3>
<p>A thread can receive messages and block until it receives one. Thus it is easy to create a worker thread of some kind.</p>
<p>TODO</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="connecting-to-a-server"><a class="header" href="#connecting-to-a-server">Connecting to a server</a></h3>
<p>TODO</p>
<p>###Listening to a socket</p>
<p>TODO</p>
<h2 id="interacting-with-c"><a class="header" href="#interacting-with-c">Interacting with C</a></h2>
<h3 id="using-libc-functions-and-types"><a class="header" href="#using-libc-functions-and-types">Using libc functions and types</a></h3>
<h3 id="calling-a-c-library"><a class="header" href="#calling-a-c-library">Calling a C library</a></h3>
<h3 id="generating-a-dynamic-library"><a class="header" href="#generating-a-dynamic-library">Generating a dynamic library</a></h3>
<h3 id="calling-win32-functions"><a class="header" href="#calling-win32-functions">Calling Win32 functions</a></h3>
<h2 id="common-design-patterns"><a class="header" href="#common-design-patterns">Common design patterns</a></h2>
<h3 id="singleton"><a class="header" href="#singleton">Singleton</a></h3>
<p>A singleton has one instance ever in your application.
TODO</p>
<h3 id="factory"><a class="header" href="#factory">Factory</a></h3>
<p>TODO</p>
<h3 id="observer"><a class="header" href="#observer">Observer</a></h3>
<p>TODO</p>
<h3 id="facade"><a class="header" href="#facade">Facade</a></h3>
<p>TODO</p>
<h3 id="flyweight"><a class="header" href="#flyweight">Flyweight</a></h3>
<p>TODO</p>
<h3 id="adapter"><a class="header" href="#adapter">Adapter</a></h3>
<p>An adapter is where we present a different interface to a client calling the adapter than the interface the code is implemented in. This might be done to make some legacy code conform to a new interface, or to manage / hide complexity which might leak out into the client.</p>
<p>As Rust is a relatively new language you are most likely to use an adapter pattern to wrap some existing code in C. A common use for the adapter in C++ is to wrap up a C library in RAII classes or similar.</p>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../13_std_library/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../13_std_library/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
