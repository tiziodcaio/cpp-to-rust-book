<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Guide to Porting C/C++ to Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book that explains how to port code from C++ to Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">3.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="credits.html"><strong aria-hidden="true">4.</strong> Credits</a></li><li class="chapter-item expanded "><a href="notation.html"><strong aria-hidden="true">5.</strong> Notation used through this book</a></li><li class="chapter-item expanded "><a href="01_setting_up_rust/index.html"><strong aria-hidden="true">6.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="02_c_and_cpp_background/index.html"><strong aria-hidden="true">7.</strong> C and C++ Background</a></li><li class="chapter-item expanded "><a href="03_rust_background/index.html"><strong aria-hidden="true">8.</strong> Rust Background</a></li><li class="chapter-item expanded "><a href="04_start_simple/index.html"><strong aria-hidden="true">9.</strong> Let's Start Simple</a></li><li class="chapter-item expanded "><a href="05_compiling_and_linking/index.html"><strong aria-hidden="true">10.</strong> Compiling and Linking in More Detail</a></li><li class="chapter-item expanded "><a href="06_source_layout/index.html"><strong aria-hidden="true">11.</strong> Source Layout and Other General Points</a></li><li class="chapter-item expanded "><a href="07_namespacing_with_modules/index.html"><strong aria-hidden="true">12.</strong> Namespacing With Modules</a></li><li class="chapter-item expanded "><a href="08_porting_code/index.html"><strong aria-hidden="true">13.</strong> Porting Code</a></li><li class="chapter-item expanded "><a href="09_features_compared/index.html"><strong aria-hidden="true">14.</strong> Features of Rust compared with C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09_features_compared/types.html"><strong aria-hidden="true">14.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="09_features_compared/strings.html"><strong aria-hidden="true">14.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="09_features_compared/variables.html"><strong aria-hidden="true">14.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="09_features_compared/literals.html"><strong aria-hidden="true">14.4.</strong> Literals</a></li><li class="chapter-item expanded "><a href="09_features_compared/collections.html"><strong aria-hidden="true">14.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="09_features_compared/structs.html"><strong aria-hidden="true">14.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="09_features_compared/comments.html"><strong aria-hidden="true">14.7.</strong> Comments</a></li><li class="chapter-item expanded "><a href="09_features_compared/references_and_borrowing.html"><strong aria-hidden="true">14.8.</strong> Lifetimes, References and Borrowing</a></li><li class="chapter-item expanded "><a href="09_features_compared/expressions.html"><strong aria-hidden="true">14.9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="09_features_compared/conditions.html"><strong aria-hidden="true">14.10.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="09_features_compared/match.html"><strong aria-hidden="true">14.11.</strong> Switch / Match</a></li><li class="chapter-item expanded "><a href="09_features_compared/casting.html"><strong aria-hidden="true">14.12.</strong> Casting</a></li><li class="chapter-item expanded "><a href="09_features_compared/enums.html"><strong aria-hidden="true">14.13.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="09_features_compared/loops.html"><strong aria-hidden="true">14.14.</strong> Loops</a></li><li class="chapter-item expanded "><a href="09_features_compared/functions.html"><strong aria-hidden="true">14.15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="09_features_compared/polymorphism.html"><strong aria-hidden="true">14.16.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="09_features_compared/error_handling.html"><strong aria-hidden="true">14.17.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="09_features_compared/closures.html"><strong aria-hidden="true">14.18.</strong> Lambda Expressions / Closures</a></li><li class="chapter-item expanded "><a href="09_features_compared/generics.html"><strong aria-hidden="true">14.19.</strong> Templates / Generics</a></li><li class="chapter-item expanded "><a href="09_features_compared/attributes.html"><strong aria-hidden="true">14.20.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="09_features_compared/multthreading.html"><strong aria-hidden="true">14.21.</strong> Multi-threading</a></li><li class="chapter-item expanded "><a href="09_features_compared/lint.html"><strong aria-hidden="true">14.22.</strong> Lint</a></li><li class="chapter-item expanded "><a href="09_features_compared/macros.html"><strong aria-hidden="true">14.23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="09_features_compared/memory_allocation.html"><strong aria-hidden="true">14.24.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="09_features_compared/ffi.html"><strong aria-hidden="true">14.25.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/index.html"><strong aria-hidden="true">15.</strong> Porting from C/C++ to Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_porting_from_cpp/copy_constructors.html"><strong aria-hidden="true">15.1.</strong> Copy Constructor / Assignment Operators</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/missing_braces.html"><strong aria-hidden="true">15.2.</strong> Missing Braces in Conditionals</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/assignments_in_conditionals.html"><strong aria-hidden="true">15.3.</strong> Assignment in Conditionals</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/class_member_initialisation.html"><strong aria-hidden="true">15.4.</strong> Class Member Initialisation</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/splitting_code_between_headers_and_sources.html"><strong aria-hidden="true">15.5.</strong> Headers and Sources</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/forward_declarations.html"><strong aria-hidden="true">15.6.</strong> Forward Declarations</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/namespace_collisions.html"><strong aria-hidden="true">15.7.</strong> Namespace Collisions</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/macros.html"><strong aria-hidden="true">15.8.</strong> Macros</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/type_mismatching.html"><strong aria-hidden="true">15.9.</strong> Type Mismatching</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/class_constructors.html"><strong aria-hidden="true">15.10.</strong> Explicit / Implicit Class Constructors</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/poor_lifetime_enforcement.html"><strong aria-hidden="true">15.11.</strong> Poor Lifetime Enforcement</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/memory_allocation.html"><strong aria-hidden="true">15.12.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/null_pointers.html"><strong aria-hidden="true">15.13.</strong> Null Pointers</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/virtual_destructors.html"><strong aria-hidden="true">15.14.</strong> Virtual Destructors</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/exceptions.html"><strong aria-hidden="true">15.15.</strong> Exception Handling / Safety</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/templates.html"><strong aria-hidden="true">15.16.</strong> Templates vs Generics</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/multiple_inheritance.html"><strong aria-hidden="true">15.17.</strong> Multiple Inheritance</a></li><li class="chapter-item expanded "><a href="10_porting_from_cpp/linker.html"><strong aria-hidden="true">15.18.</strong> Linker Errors</a></li></ol></li><li class="chapter-item expanded "><a href="11_debugging_rust/index.html"><strong aria-hidden="true">16.</strong> Debugging Rust</a></li><li class="chapter-item expanded "><a href="12_memory_management/index.html"><strong aria-hidden="true">17.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="13_std_library/index.html"><strong aria-hidden="true">18.</strong> Rust's std:: library</a></li><li class="chapter-item expanded "><a href="14_rust_cookbook/index.html"><strong aria-hidden="true">19.</strong> Rust Cookbook</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Porting C/C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-guide-to-porting-cc-to-rust"><a class="header" href="#a-guide-to-porting-cc-to-rust">A Guide to Porting C/C++ to Rust</a></h1>
<p>This book is for people familiar with C or C++ who are thinking of using Rust.</p>
<p>Before we go into what Rust is or why it might be preferable to C/C++ <em>in some cases</em>, let's think of software that is mission critical and must not or should not fail.</p>
<ul>
<li>Operating system services and daemons</li>
<li>Internet of things devices</li>
<li>Industrial control software</li>
<li>Medical devices - MRI, ultrasound, X-ray, ventilators etc.</li>
<li>High availability servers / databases / cloud storage etc.</li>
<li>Avionics, telemetry, rocketry, drones etc.</li>
</ul>
<p>All this code must run as efficiently and reliably as possible. It must run on devices for days, weeks, months or preferably years without failure. It cannot suffer intermittent freezes, erratic performance, memory leaks, crashes or other issues without impacting on its purpose.</p>
<p>Normally such software would be written in C or C++, but consider these <em>every day</em> bugs that happen in these languages:</p>
<ul>
<li>Use after free / Dangling pointers. A program calls an invalid pointer causing a crash.</li>
<li>Buffer overruns / underruns. Code writes beyond an allocated buffer causing memory corruption or a page exception.</li>
<li>Memory leaks. Code that allocates memory <em>or resources</em> without calling the corresponding free action. C++ provides classes such as smart pointers and techniques like RAII to mitigate these issues but still occur.</li>
<li>Data races. Multiple threads write to data at the same time causing corruption or other destabilizing behavior.</li>
</ul>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>Rust stops these bad things happening <strong>by design</strong>. And it does so without impacting on runtime performance because all of these things are checked at compile time:</p>
<ul>
<li>Object lifetimes are tracked automatically to prevent memory leaks and dangling pointers.</li>
<li>The length of arrays and collections is enforced.</li>
<li>Data race conditions are prevented by strict enforcement of mutex / guards and object ownership.</li>
</ul>
<p>Code that passes the compiler's checks is transformed into machine code with similar performance and speed as the equivalent C or C++.</p>
<p>This is a &quot;zero-cost&quot; approach. The compiler enforces the rules so that there is zero runtime cost over the equivalent and correctly written program in C or C++. Safety does not compromise performance.</p>
<p>In addition Rust plays well C. You can call C from Rust or call Rust from C via foreign function interfaces. So you could rewrite a critical section of your codebase while leaving the remainder alone. You can also invoke Rust via the FFI of other languages - for example NodeJS or Python.</p>
<h2 id="rust-is-not-a-magic-wand"><a class="header" href="#rust-is-not-a-magic-wand">Rust is not a magic wand</a></h2>
<p>Despite the things the language can protect you against, it cannot protect you against the following:</p>
<ul>
<li>General race conditions such as deadlocks between threads</li>
<li>Halting problems such as a loop that pushes values onto a vector until memory is exhausted.</li>
<li>Application logic errors, i.e. errors that have nothing to do with the underlying language, e.g. missing out the line that should say &quot;if door_open { sound_alarm(); }&quot;</li>
<li>Explicit unsafe sections doing unsafe and erroneous things</li>
<li>Errors in LLVM or something outside of Rust's control.</li>
</ul>
<p>And rewriting something for the sake of rewriting is never a good idea. Make sure you have a reason to port or rewrite your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="licence"><a class="header" href="#licence">Licence</a></h1>
<p>The book is written under these terms:</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
<p>Refer to the link for the exact legal terms. But in essence you may share and modify this book providing you do not sell or derive profit from doing so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p><strong>BEGIN DRAFT BOOK DISCLAIMER</strong></p>
<ul>
<li>Some of the samples will not compile or may not have been syntax checked</li>
<li>C and Rust code snippets are not distinguished very well yet (styling)</li>
<li>Some of the text makes uncited assertions of fact</li>
<li>Some of the text is marked TODO</li>
<li>Some of the topics that should be covered are brushed over, given undue weight or omitted entirely</li>
<li>Some of the text probably makes no sense or repeats itself</li>
</ul>
<p>WITH ALL THAT IN MIND, read on!</p>
<p><strong>END DRAFT BOOK DISCLAIMER</strong></p>
<p>Think of all the software that needs to be reliable in this world. Software that can ill afford downtime or crashes. Software that is mission critical and must not or should not fail.</p>
<ul>
<li>Operating system services and daemons</li>
<li>Internet of things devices</li>
<li>Industrial control software</li>
<li>Medical devices, imagery etc.</li>
<li>High availability servers / databases / cloud storage etc.</li>
<li>Avionics, telemetry, rocketry, drones etc.</li>
</ul>
<p>All this code that has to run as efficiently and reliably as possible with the minimal of errors. It also has to be predictable without sudden freezes or mystery-memory behavior due to garbage collection.</p>
<p>C and C++ has the speed angle covered but is hard to make reliable. A language like Java would have the reliability angle covered but is hard to make performant.</p>
<p>What we want is something which runs as fast as C or C++ but has the reliability that goes with it. And that is what Rust is about. It compiles into binary executables or libraries just like C or C++ and can even be used to produce dynamic libraries that can be consumed by other code bodies.</p>
<div style="break-before: page; page-break-before: always;"></div><p>All of the information found in this document can be gleaned from elsewhere but it tends to be scattered across documents and sites that are focused on topics not
and in many cases I've sought inspiration and knowledge from
TODO</p>
<ol>
<li><a href="https://www.rust-lang.org/en-US/documentation.html">Online documentation for Rust</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a> - describes some of the esoteric reasoning and internals behind the language and how to perform unsafe programming. Unsafe programming is not the default but is necessary for interacting with external code.</li>
<li>TODO - Design patterns repo</li>
<li>TODO - Effective C++, Meyers</li>
<li>TODO â€“ various stackoverflow questions and answers</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notation-used-through-this-book"><a class="header" href="#notation-used-through-this-book">Notation used through this book</a></h1>
<p>Code samples are given throughout this book are for C, C++, Rust and general configuration / console output.<br />
In order to distinguish each kind they are styled as follows:</p>
<p>C / C++ samples are given in this style:</p>
<pre><code class="language-c++">// C/C++
while (x &lt; y) {
  cout &lt;&lt; &quot;x is less than y&quot; &lt;&lt; endl;
  ++x;
}
</code></pre>
<p>Rust samples are given in this style:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
if x == 20 {
  println!(&quot;Warning!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Standard console output or script is given this style:</p>
<pre><code>cd myproject/
cargo build
</code></pre>
<p>Most of the code samples are abbreviated in some fashion. e.g. they assume the code is running from within a main() function or they omit noise such as #includes, namespace definitions and so forth.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-rust"><a class="header" href="#setting-up-rust">Setting up Rust</a></h1>
<p>This section will talk you through setting up Rust for the first time and also how to keep it up to date.</p>
<p>Getting started is incredibly easy but some details vary upon your target platform. Rust runs on Windows, Linux and MacOS. In addition you might wish to cross-compile code for the consumption of another platform.</p>
<h2 id="use-rustup"><a class="header" href="#use-rustup">Use Rustup</a></h2>
<p>The easiest way to get started is to download and run <code>rustup-init</code> which you can do by visiting the <a href="https://www.rustup.rs/">Rustup site</a>.</p>
<p>The instructions differ for Windows and Unix-like systems:</p>
<ul>
<li>On Windows, rustup-init is an exe installer.</li>
<li>On Unix / OS X / Linux rust-init is a shell script.</li>
</ul>
<p>Either way, when you follow the instructions the installer will download and install put rustc, cargo, and rustup in your bin directory which is <code>~/.cargo/bin</code> on Unix and <code>%USERPROFILE%.cargo.\bin</code> on Windows. </p>
<p>It will also set your <code>PATH</code> environment variable so that you can open a terminal and type rustc, cargo, rustup etc.</p>
<p>Once <code>rustup</code> is installed you can also use the tool for maintenance:</p>
<ul>
<li>Install additional Rust toolchains (e.g. if you are cross-compiling or supporting multiple targets you may have more than one toolchain)</li>
<li>Change the default toolchain that is invoked when you type <code>rustc</code> or <code>cargo</code>. Rustup will create symbolic links / scripts that invoke the appropriate toolchain</li>
<li>Update the toolchain when a new version of Rust is released</li>
<li>Fetch source and documentation</li>
</ul>
<h3 id="unix--linux"><a class="header" href="#unix--linux">Unix / Linux</a></h3>
<p>The process for running <code>rustup-init.sh</code> is as follows:</p>
<ol>
<li>Open a terminal / console</li>
<li>Type &quot;curl https://sh.rustup.rs -sSf | sh&quot;</li>
<li>This will download and execute a script which will examine your environment, recommend the toolchain to download, and offer to modify your <code>PATH</code> environment variable.</li>
<li>Choose the option 1 to proceed. Or customize if you want to modify something</li>
<li>Wait for download to complete</li>
<li>You're done.</li>
</ol>
<p>If you don't have curl, then you must install it first to proceed, or save the <a href="https://sh.rustup.rs">shell script</a> from a browser to disk and execute that. </p>
<p>To install <code>curl</code> in Linux you would invoke a command like this to install it.</p>
<ul>
<li>Debian / Ubuntu - <code>sudo apt get curl</code></li>
<li>Fedora / Redhat - <code>sudo dnf install curl</code></li>
</ul>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ol>
<li>Download rustup-init.exe from rustup.rs.</li>
<li>Double click on the rust-init.exe and a console will open</li>
<li>Choose the option 1 to proceed. Or customize if you want to modify something</li>
<li>Wait for download to complete</li>
<li>You're done.</li>
</ol>
<p>If you prefer not to go with the defaults, here are some choices you should decide upon:</p>
<ol>
<li>32/64 bit version. Most Windows installations are going to be 64-bits these days but you may have a reason to choose 32-bit.</li>
<li>GNU or MSVC ABI. This depends on what toolchain and runtimes you wish to be compatible with.</li>
</ol>
<p>The second choice concerns the application binary interface (ABI) you want Rust to be compatible with.</p>
<ul>
<li>If you don't care about linking to anything then choose the GNU ABI. Also choose it if you have DLLs produced by MingW / MSYS. The advantage of this ABI is that it is more mature.</li>
<li>If you have Visual Studio installed or intend to use Rust against DLLs created with Visual Studio, that's the ABI you need. One advantage of this option is that you can debug Rust inside of Visual Studio- the compiler will produce .pdb files that allow you to step debug Rust.</li>
</ul>
<h3 id="keeping-rust-up-to-date"><a class="header" href="#keeping-rust-up-to-date">Keeping Rust up to date</a></h3>
<p>New versions of Rust appear in a semi-frequent basis. If you want to update your environment to the latest version, it is as simple as this:</p>
<pre><code>rustup update
</code></pre>
<p>Sometimes <code>rustup</code> will need an update of its own in which case you type:</p>
<pre><code>rustup self update
</code></pre>
<h3 id="adding-rust-source"><a class="header" href="#adding-rust-source">Adding Rust source</a></h3>
<p>Rustup installs a rust toolchain but if you're writing code or debugging you probably
should also get the Rust source code so you can step into it or look at the implementation:</p>
<pre><code>rustup component add rust-src
</code></pre>
<h2 id="manual-installation"><a class="header" href="#manual-installation">Manual installation</a></h2>
<p>If you prefer manual installation of Rust then there are packages and instructions on the <a href="https://www.rust-lang.org/en-US/downloads.html">Rust site</a>.</p>
<p>Just be aware that Rust has a fairly rapid release cycle so you probably only want to do this if you have a reason to choose a specific version of Rust and stick with it.</p>
<p>Otherwise you may find yourself uninstalling and reinstalling a new version 6 weeks later all over again.</p>
<h2 id="setting-up-a-debugger"><a class="header" href="#setting-up-a-debugger">Setting up a debugger</a></h2>
<h3 id="unix--linux-1"><a class="header" href="#unix--linux-1">Unix / Linux</a></h3>
<p>Debugging Rust is little different from debugging C or C++.</p>
<p>You must install gdb for your platform and then you may invoke it from a console or your favourite front-end to debug Rust code.</p>
<p>On Linux systems you would normally install gdb from a package with one of these commands:</p>
<pre><code>sudo apt-get install gdb
# or
sudo dnf install gdb
</code></pre>
<p>You may also prefer to use lldb which is a companion project to LLVM (the backend compiler used by Rust). Refer to the <a href="http://lldb.llvm.org/">lldb website</a> for information on using it.</p>
<p>Rust comes with a few scripts that wrap gdb and lldb to provide pretty-printing to assist with debugging. When debugging, you can invoke <code>rust-gdb</code> or <code>rust-lldb</code> to use them.</p>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>If you have chosen Rust with the MSVC ABI then you can debug through Visual Studio with some limitations. When you create a debug build of your code, the compile will also create a .pdb file to go with it. You may open your executable in Visual Studio and step debug it, inspect variables and so on. </p>
<h4 id="gdb"><a class="header" href="#gdb">GDB</a></h4>
<p>GDB on Windows is available through MSYS / MingW distributions.</p>
<p>For example downloads of the TDM-GCC distribution of MSYS can be found <a href="http://tdm-gcc.tdragon.net/download">here</a>. At the time of writing this, there is a standalone gdb-7.9.1-tdm64-2.zip containing the Choose the 32 or 64-bit version according to your Rust environment.</p>
<p>Extract the zip file to a directory, e.g. <code>C:\tools\gdb-7.9.1-tdm64-2</code> and add a value to your <code>PATH</code> environment variable:</p>
<pre><code>set PATH=%PATH%;C:\tools\gdb-7.9.1-tdm64-2\bin\
</code></pre>
<p>You can invoke <code>gdb</code> from the command line but more normally you'd prefer a front end.</p>
<p>At the time of writing, perhaps the best option is Visual Studio Code which has plugins for debugging with GDB and for Rust development. So you can edit and debug from the same IDE.</p>
<h5 id="pretty-printer"><a class="header" href="#pretty-printer">Pretty printer</a></h5>
<p>Rust supplies a pretty printer for variable inspection that you can add to the GDB.   The pretty printer is a script written in Python that GDB will invoke to display variables. </p>
<p>First ensure you have Python 2.7 installed in your path.</p>
<p>The script is bundled with the Rust source code so you need to have installed that first.</p>
<p>If you installed it with <code>rustup</code> then it can be found in your <code>%USERPROFILE%\.rustup</code> directory:</p>
<p>e.g.</p>
<pre><code>c:\users\MyName\.rustup\toolchains\stable-x86_64-pc-windows-gnu\lib\rustlib\src\rust\src\etc
</code></pre>
<p>Otherwise it can be found wherever you unzipped your Rust source code under <code>src\rust\src\etc</code>.</p>
<p>Note the fully qualified path its under and edit <code>C:\tools\gdb-7.9.1-tdm64-2\bin\gdbinit</code> to insert the path using <em>forward</em> slashes.</p>
<pre><code>python
print &quot;---- Loading Rust pretty-printers ----&quot;
 
sys.path.insert(0, &quot;C:/users/MyName/.rustup\toolchains/stable-x86_64-pc-windows-gnu/lib/rustlib/src/rust/src/etc&quot;)
import gdb_rust_pretty_printing
gdb_rust_pretty_printing.register_printers(gdb)
 
end
</code></pre>
<h2 id="setting-up-an-ide"><a class="header" href="#setting-up-an-ide">Setting up an IDE</a></h2>
<p>Rust is still behind some other languages when it comes to IDE integration but there are already plugins that provide much of the functionality you need.</p>
<p>Popular IDEs such as Eclipse, IntelliJ, Visual Studio all have plugins that work to varying degrees of integration with Rust.</p>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> (not to be confused with Visual Studio) is a cross-platform programming editor and has a lot of plugins. It can be set up into a complete Rust development environment by following this <a href="https://sherryummen.in/2016/09/02/debugging-rust-on-windows-using-visual-studio-code/">tutorial</a>.</li>
<li><a href="https://intellij-rust.github.io/">Rust plugin for IntelliJ IDEA</a> is under active development. This plugin has a lot of traction and is turning around new versions on a nearly weekly basis.  Offers syntax highlighting, autocomplete (via built-in parser), cargo builts and eventually other functionality. <a href="https://www.jetbrains.com/idea/download/#section=windows">IntelliJ</a> is a commercial product but it comes in a community edition which is sufficient for development.</li>
<li><a href="https://github.com/PistonDevelopers/VisualRust">Visual Rust plugin for Microsoft Studio</a> . Offers syntax highlighting, autocompletion, interactive debugging.</li>
<li><a href="https://github.com/RustDT/RustDT">RustDT for Eclipse</a> is also under active development. It adds syntax highlighting, autocomplete (via racer), cargo builds and rustfmt functionality to Eclipse.</li>
<li>Atom is a popular editor with heaps of plugins. These plugins are very useful for Rust:
<ul>
<li><a href="https://atom.io/packages/language-rust">language-rust</a> provides basic syntax highlighting</li>
<li><a href="https://atom.io/packages/racer">racer</a> for autocompletion functionality</li>
<li><a href="https://atom.io/packages/atom-beautify">atom-beautify</a> invokes rustfmt to make code look pretty.</li>
<li><a href="https://atom.io/packages/build-cargo">build-cargo</a> invokes cargo for you showing errors and warnings inline.</li>
</ul>
</li>
</ul>
<p>For other editors and IDEs refer to the <a href="https://forge.rust-lang.org/ides.html">Rust and IDEs</a> page on the Rust website.</p>
<h2 id="racer--rustfmt"><a class="header" href="#racer--rustfmt">Racer / Rustfmt</a></h2>
<p>Some of the plugins above make use of Racer and Rustfmt.</p>
<p>Racer is used by some plugins to provide autocompletion functionality.</p>
<p>Rustfmt is a source code formatting tool that makes sure your Rust source code is pretty to look at, adding spacing, indentation and so on.</p>
<p>You can get both just by typing these commands and waiting for the tools to download and build themselves - they're written in Rust and built through cargo.</p>
<pre><code>cargo install racer
cargo install rustfmt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>|</p>
<h1 id="c-and-c-background"><a class="header" href="#c-and-c-background">C and C++ Background</a></h1>
<p>This section talks about C and C++. It describes its history, standards and provides a background as to how it ended up where it is today.</p>
<h2 id="history-of-c"><a class="header" href="#history-of-c">History of C</a></h2>
<h3 id="early-days"><a class="header" href="#early-days">Early Days</a></h3>
<p>The C <sup class="footnote-reference"><a href="#1">1</a></sup> programming language was developed as part of Unix <sup class="footnote-reference"><a href="#2">2</a></sup> by Dennis Ritchie and Ken Thompson.</p>
<p>Unix started life on the PDP-7 microcomputer and was originally written in assembly language. The OS was then ported to the PDP-11 architecture, also in assembly. </p>
<p>Ritchie developed C in 1972 as a higher level language and compiler for writing Unix software in a more abstract way than pure assembly. The language provided constructs such as static types, loops, conditionals, expressions etc and the compiler produced machine code which was almost as efficient as hand written assembly. Over time much of Unix itself, including much of the kernel was rewritten in C which in turn aided portability.</p>
<p>The compiler was also a bundled component of Unix, so Unix users could develop their own software using the language. Thus C became a popular way of developing Unix software.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> C was called C because it was influenced by a language called B developed by Thompson as a simplified version of BCPL.</p>
<p><sup class="footnote-reference"><a href="#2">2</a></sup> Unix is a multi-tasking operating system that evolved into many commerical and free variants such as Solaris, HPUX, BSD etc. Many of these are in use today as well as Linux. You may be thinking Linux is Unix, but Linux <em>isn't</em> derived from Unix code. However, it did independently implement most of the same interfaces and concepts as a typical Unix OS. These days Linux is the dominant Unix-like OS and can be found in anything from lightbulbs all the way up to mainframe computers.</p>
<h3 id="defacto-standard-and-emerging-popularity"><a class="header" href="#defacto-standard-and-emerging-popularity">Defacto standard and emerging popularity</a></h3>
<p>In 1978 C was formalised into a defacto standard called K&amp;R C, named after Brian Kernighan &amp; Dennis Ritche who published the standard as a book. K&amp;R formalised the language and defined the standard I/O library and some other features.</p>
<p>Over time the use of C became more widespread and compilers such as Turbo C, Lattice C, Microsoft C popularized C on other operating systems including personal computers.</p>
<h3 id="international-standards"><a class="header" href="#international-standards">International Standards</a></h3>
<p>C was later standardised by the American National Standards Institute (ANSI) and thus became known as ANSI C, or C89. Further standards followed such as C99, C11, C18 and so on.</p>
<p>Later standards have attempted to align C with developments in C++ to keep the two in sync as much as possible. Some functionality that was introduced in C++ has also found its way back into C standards. For example, the // style single-line comment and variable declaration rules in blocks.</p>
<h2 id="history-of-c-1"><a class="header" href="#history-of-c-1">History of C++</a></h2>
<p>C++ first appeared in 1983 as C with classes. It was invented by Bjarne Stroustrop as a way to imbue C with Simula-like <sup class="footnote-reference"><a href="#3">3</a></sup> object-oriented features. </p>
<p>C++ added these concepts as extensions to the C language and used a precompiler called <code>cfront</code> to transform the C++ extensions into C code that could then be compiled into machine code. So a C++ program could have the high level object oriented concepts but without the overhead that came with Simula.</p>
<p>C++ became popular in its own right and outgrew the limitations of cfront preprocessor to become supported by compilers in its own right. Thus toolchains such as Microsoft Visual C++, GCC, Clang etc. support both languages. Some toolchains have also been given to favouring C++ over C, for example Microsoft's compiler has been very slow to implement C99.</p>
<p>Object oriented programming has mostly been used in higher level software - applications, games,  simulations and mathematical work.</p>
<p>C++ has also become formalised standards with C++98, C++03, C++11 and so on.</p>
<p><sup class="footnote-reference"><a href="#3">3</a></sup> Simula is a language that allowed concepts such as objects, classes and inheritance to be expressed in code and as its name suggests was created for running simulations. However it was considered too slow for systems programming and so something that combined speed of C with object oriented concepts was highly desirable.</p>
<h3 id="modern-c"><a class="header" href="#modern-c">Modern C++</a></h3>
<p>C++11 onwards is a distinctly different beast from earlier iterations and strives to add functionality that if used correctly can eliminate a lot of issues that will be discussed later on:</p>
<ul>
<li>Unique and shared pointers</li>
<li><code>auto</code> keyword</li>
<li>move semantics (i.e. moving data ownership of data from one variable to another)</li>
<li>rvalue references</li>
<li>perfect forwarding</li>
<li><code>nullptr_t</code> and <code>nullptr</code> explicit type</li>
</ul>
<p>However it is worth noting that since many of these things are late additions to C++. Things like move semantics must be explicitly used and have complexity as we shall see.</p>
<h3 id="the-relationship-between-c-and-c"><a class="header" href="#the-relationship-between-c-and-c">The relationship between C and C++</a></h3>
<p>While C++ grew out of C and has developed alongside it, C++ is <em>not</em> a superset of C. It is <em>mostly</em> a superset but C can use C++ keywords as variable / function names that would cause a compiler error with C++.</p>
<p>C++ also has function overloading and classes and uses name mangling to disambiguate overloaded functions. But in practice it is possible to write C as a subset of C++ and compile the two into the same executable. Most real-world C code could be called C++ <em>without</em> classes.</p>
<p>C and C++ are even usually handled by the same toolchain. Most compilers would consist of a front half that parses the language into an intermediate form and a back half which turns the intermediate form into optimized machine code. Finally the linker would join all the binary objects together to form an executable. C and C++ would share most of this code path.</p>
<p>C++ tends to be more popular with applications level programming. Part of the reason C++ hasn't found itself in the lower layers is the perception that exception handling, name mangling, linking and issues of that nature add unwanted complexity or that somehow the generated code is less efficient. Arguments have been made that this is not the case, but the perception still remains.</p>
<p>C still tends to be more popular in low level systems programming. Components such as the Linux kernel are pure C with some assembly. Many popular open source libraries such as sqlite3 are also written in C.</p>
<h2 id="objective-c"><a class="header" href="#objective-c">Objective-C</a></h2>
<p>Objective-C is another C derived language that added objects and classes. Unlike C++, Objective-C behaves as a strict superset of C.</p>
<p>The language was developed in the 1980s and was popularized in the NeXTSTEP operating system and later in Apple's OS X and iOS. It hasn't gained much popularity outside of those platforms but the success of the iPhone has ensured it has a sizeable developer base of its own. It is also well supported by the GCC and Clang toolchains. Apple has begun to deprecate Objective-C in favour of Swift which is a modern high level language similar in some respects to Rust but more application focussed.</p>
<p>Objective-C is strongly influenced by Smalltalk (as opposed to Simula in C++) and so code works somewhat differently than C++.</p>
<p>Notionally code calls objects by sending them a message. An object defines an interface specifying what messages it accepts and an implementation that binds those messages to code. The caller code sends a message to call a method. Objects can also receive dynamic messages, i.e. ones not defined by their interfaces, so they can do certain tasks such as intercepting and forwarding messages. In addition an object can ignore a message or not implement it without it being considered an error. In a broad sense, an ObjC message and a C++ method are or more or less analogous in functionality.</p>
<h2 id="cc-timeline"><a class="header" href="#cc-timeline">C/C++ Timeline</a></h2>
<p>These are the major revisions of C and C++</p>
<div class="table-wrapper"><table><thead><tr><th>Year</th><th>Event</th><th>Description</th></tr></thead><tbody>
<tr><td>1972</td><td>C</td><td>C for PDP-11, other Unix systems</td></tr>
<tr><td>1978</td><td>K&amp;R C</td><td>C as defined in &quot;The C Programming Language&quot; book by Kernighan &amp; Ritchie</td></tr>
<tr><td>1979</td><td>C with classes -&gt; C++</td><td>Bjarne Stroustrops</td></tr>
<tr><td>1989</td><td>C89 (ANSI X3.159-1989)</td><td>C is standardized as ANSI C, or C89. C90 (ISO/IEC 9899:1990) is the ISO ratified version of this same standard.</td></tr>
<tr><td>1987</td><td>GNU C Compiler (GCC)</td><td>An open source C compiler that was quickly adopted by developers and became the defacto compiler for most Unix / Linux systems. Acronym <code>GCC</code> was rebranded as GNU Compiler Chain since the project encapsulated many other languages including C++, Objective-C, Ada, Fortran etc. that had individual compiler front-ends but shared the code generating backend.</td></tr>
<tr><td>1995</td><td>C95 (ISO/IEC 9899/AMD1:1995)</td><td>Wide character support, digraphs, new macros, and some other minor changes.</td></tr>
<tr><td>1998</td><td>C++98 (ISO/IEC 14882:1998)</td><td>C++ is standardized for the first time.</td></tr>
<tr><td>1999</td><td>C99 (ISO/IEC 9899:1999)</td><td>Single line (//) comments, mixing declarations with code, new intrinsic types, inlining, new headers, variable length arrays</td></tr>
<tr><td>2003</td><td>C++03 (ISO/IEC 14882:2003)</td><td>Primarily a defect revision, addressing various defects in the specification.</td></tr>
<tr><td>2003</td><td>LLVM</td><td>Similar to GCC, a compiler and toolchain that started predominantly to support compiling C and C++ via the Clang compiler with many backends for generating machine code across across many platforms. The toolchain is also used by the Rust compiler.</td></tr>
<tr><td>2011</td><td>C++11 (ISO/IEC 14882:2011)</td><td>A major revision that introduces type inference (auto), range based loops, lambdas, strongly typed enums, a nullptr constant, struct initialization. Improved Unicode char16_t, char32_t, u, U and u8 string literals.</td></tr>
<tr><td>2011</td><td>C11 (ISO/IEC 9899:2011)</td><td>Multi-threading support. Improved unicode char16_t, char32_t, u, U and u8 string literals. Other minor changes</td></tr>
<tr><td>2014</td><td>C++14 (ISO/IEC 14882:2014)</td><td>A major revision that introduces auto return types, variable templates, digit separators (1'000'000), generic lambdas, lambda capture expressions, deprecated attribute.</td></tr>
<tr><td>2017</td><td>C++17 (ISO/IEC 14882:2017)</td><td>A major revision that introduces a number of enhancements but notably a filesystem library, <code>string_view</code> and <code>option</code> types and <code>UTF-8</code> strings</td></tr>
</tbody></table>
</div>
<p>In a sense C++ is converging with Rust since many of the enhancements which have gone into the language have the potential to make code safer and more efficient. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-background"><a class="header" href="#rust-background">Rust Background</a></h1>
<p>So Rust began life as a research project by Graydon Hoare in 2009 for the Mozilla foundation to solve issues related to developing in C++. It progressed until the release of version 1.0 in 2015 and has since iterated through releases every six weeks since.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The motivating force for a new language isn't hard to see if you consider the Mozilla Firefox web browser. Like most web browsers it is:</p>
<ul>
<li>Written in C++. <sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>Has millions of lines of code.</li>
<li>Complex</li>
<li>Vulnerable to bugs, vulnerabilities and exploits, many of which are attributable to the language the software is written in.</li>
<li>Subsystems are mostly single-threaded and therefore not well suited for many-core devices - PCs, phones, tablets etc. Implementing multi-threading to the existing engine would doubtless cause even more bugs and vulnerabilities than being single threaded.</li>
</ul>
<p>Rust was conceived as a way to obtain C or C++ levels of performance but also remove entire classes of software problem that destabilize software and could be exploited. Code that passes the compiler phase could be guaranteed to be memory safe and therefore could be written in a way to take advantage of concurrency. It has even been coined as <em>fearless concurrency</em> because it removes a lot of the uncertainty and doubt that comes from typical concurrent code - data race conditions and so on.</p>
<p>The project is hosted on <a href="https://github.com/rust-lang/rust">GitHub</a>. The language has been <em>self-hosting</em> for quite some time - that is to say the Rust compiler is written in Rust, so compiling Rust happens from a compiler written in Rust. Get your head around that! But it's the same way that C and C++ compilers are these days too.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Read this <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Internal_strings">Mozilla internal string guide</a> to get a flavor of the sort of problems the browser had to overcome. A browser obviously uses a lot of temporary strings. STL strings were too inefficient / flakey from one compiler to the next and so the browser sprouted an entire tree of string related classes to solve this issue. Similar tales are told in Qt and other large libraries.</p>
<h2 id="safe-by-design"><a class="header" href="#safe-by-design">Safe by design</a></h2>
<p>Rust enforces a safe-by-design philosophy. Simply put, the language and the compiler try to stop errors from happening in the first place. </p>
<p>For example the compiler rigorously enforces lifetime tracking on objects and generates errors on violations. That means you cannot hold a reference to an object which has been destroyed unlike in C++.</p>
<p>Most of these checks and guards are done at compile time so there is a zero-cost at runtime.</p>
<h2 id="timeline"><a class="header" href="#timeline">Timeline</a></h2>
<p>Rust has evolved a number of features in a backwards compatible fashion</p>
<ul>
<li>2015 - Release 1.0 of Rust</li>
<li>2015-18 - Refinements such as procedural macros, rustup, rls, C ABI libraries, global allocators</li>
<li>2018 - Rust 2018 edition (1.30). The 2018 edition contains various syntactic improvements designed to remove nuisances in the language (e.g. <code>extern crate</code> declarations) and improve the borrow checker. The compiler is backwards compatible so 2015 syntax is still accepted.</li>
<li>2019 - <code>async</code> / <code>await</code> keywords for handling futures.</li>
</ul>
<h2 id="active-development"><a class="header" href="#active-development">Active Development</a></h2>
<p>The Rust team releases a new version of Rust approximately every 6 weeks. This means Rust receives code and speed improvements over time. </p>
<p>Most releases focus on marking APIs as stable, improving code optimization and compile times.</p>
<h2 id="open-source-and-free"><a class="header" href="#open-source-and-free">Open source and free</a></h2>
<p>Rust is dual licensed under the Apache 2.0 and MIT open source licenses. The full copyright message is viewable <a href="https://github.com/rust-lang/rust/blob/master/COPYRIGHT">online</a>.</p>
<p>Essentially the license covers your right to modify and distribute the Rust source code. Note that Rust generates code for LLVM so LLVM also has its own software license (TODO link).</p>
<p>What you compile with Rust (or LLVM) is not affected by the open source license. So you may compile, execute and distribute proprietary code without obligation to these licenses.</p>
<h2 id="is-rust-for-everybody"><a class="header" href="#is-rust-for-everybody">Is Rust for everybody?</a></h2>
<p>No of course not. Performance and safety are only two things to consider when writing software.</p>
<ul>
<li>Sometimes it's okay for a program to crash every so often. That depends on what you are writing of course.</li>
<li>If you have code that's written and works then why throw that away?</li>
<li>Writing new code will always take effort and will still cause application level bugs of one sort or another.</li>
<li>Performance may not be a big deal especially for network bound code and a higher level language such as Java, C#, or Go may be more suitable.</li>
<li>Some people will find the learning curve extremely steep. </li>
<li>Rust is still relatively immature as a language and still has some rough edges - compilation times, optimization, complex macros.</li>
</ul>
<p>But you may still find there is benefit to moving some of your code to Rust. For example, your C++ software might work great but it has to deal with a lot of user-generated data so perhaps you want to reimplement that code path in Rust for extra safety.</p>
<h2 id="safe-by-design-1"><a class="header" href="#safe-by-design-1">Safe by design</a></h2>
<p>Some examples of this safe-by-design philosophy:</p>
<ul>
<li>Variable (binding) is immutable by default. This is the opposite of C++ where mutable is the default and we must explicitly say const to make something immutable. Immutability extends to the &amp;self reference on struct functions.</li>
<li>Lifetime tracking. The Rust compiler will track the lifetime of objects and can generate code to automatically drop them when they become unused. It will generate errors if lifetime rules are violated.</li>
<li>Borrowing / Variable binding. Rust enforces which variable &quot;owns&quot; an object at any given time, and tracks values that are moved to other variables. It enforces rules about who may hold a mutable or immutable reference to it. It will generate errors if the code tries to use moved variables, or obtain multiple mutable references to it.</li>
<li>There is no NULL pointer in safe code. All references and pointers are valid because their lifetimes and borrowing are tracked.</li>
<li>Rust uses LLVM for the backend so it generates optimized machine code.</li>
<li>Lint checking is builtin, e.g. style enforcement for naming conventions and code consistency.</li>
<li>Unit tests can be integrated into the code and run automatically</li>
<li>Modules (equivalent to namespaces C++) are automatic meaning we implicitly get them by virtue of our file structure.</li>
</ul>
<h2 id="dont-c11--c14--c17-get-us-this"><a class="header" href="#dont-c11--c14--c17-get-us-this">Don't C++11 / C++14 / C++17 get us this?</a></h2>
<p>Yes and no. C++ is converging with Rust in some aspects, but it is still unsafe by default and that could never change without changing the language itself.</p>
<p>But let's look at some of the fundamental differences between C++ and Rust</p>
<h3 id="move-semantics"><a class="header" href="#move-semantics">Move semantics</a></h3>
<p>Move semantics in C++ require you implement explicit move constructors on classes you wish to use with them. </p>
<p>Any class that doesn't is using copy semantics. The compiler will not care either that you leave the old class instance in a valid state as a result of your implementation. The compiler will even let you call your old class instance despite having moved data to a new instance. Move errors can be handled at runtime with a sentinel state. Simply put, move in C++ is complex and blogs <a href="https://foonathan.net/blog/2017/09/14/destructive-move.html">like this</a> spend a long time explaining the gory details.</p>
<p>Remember in Rust you just get them for free, and they are enforced by the compiler.</p>
<h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h3>
<p>Smart pointers can still be null dereferenced. Null dereferencing is undefined behaviour and can crash or compromise your code. C++ strongly prefers that you use references to avoid null dereferencing, but it doesn't check the lifetimes of references so it is still not always possible. Certain data structures like trees and graphics virtually preclude using references.</p>
<p>C++ introduces an <code>std::optional</code> type that attempts to fulfill the same purpose as <code>Option</code> in Rust. There is a <code>nullopt</code>, equivalent to <code>None</code>, and <code>std::optional&lt;T&gt;(value)</code> to hold a value. </p>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<p>Concurrency requires correct programming habits - ensuring to avoid concurrency errors like data races by using guards. The compiler will not help if you do not write correct code.</p>
<p>In C++ you might protect access to some shared data with a <code>std::mutex</code> or <code>std::recursive_mutex</code> and use a <code>std::lock_guard</code> to hold the mutex for the duration of the operation. But the compiler does not care if you do or not.</p>
<h4 id="programming-safety"><a class="header" href="#programming-safety">Programming safety</a></h4>
<p>Perhaps if you program the right subset of features and diligently work to avoid pitfalls of C++ in general then you are more likely to create safe code. If you search for &quot;C++ coding guidelines&quot; you will find no end of articles that try to minimize risky practice. </p>
<p>But what is the <em>right</em> subset?</p>
<ul>
<li>If you use someone else's library - are they using the right subset?</li>
<li>If one subset is right then why does C++ still contain all the stuff that is outside of that?</li>
<li>Why are all the things which are patently unsafe / dangerous still allowed?</li>
<li>Why are certain dangerous default behaviors such as default copy constructors not flipped to improve code safety?</li>
</ul>
<p>We could argue that C++ doesn't want to break existing code by introducing change that requires code to be modified. That's fair enough but the flip-side is that future code is almost certainly going to be broken by this decision. Perhaps it would be better to inflict a little pain for some long term gain.</p>
<h2 id="unsafe-programming--c-interoperability"><a class="header" href="#unsafe-programming--c-interoperability">Unsafe programming / C interoperability</a></h2>
<p>Rust recognizes you may need to call an external libraries, e.g. in a C library or a system API.</p>
<p>Therefore it provides an <code>unsafe</code> keyword that throws some of the safety switches when it is necessary to talk to the outside world.</p>
<p>This allows you consider the possibility of porting code partially to Rust while still allowing some of it to remain as C.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-start-simple"><a class="header" href="#lets-start-simple">Let's Start Simple</a></h1>
<p>For this section we're going to ignore makefiles for the time being and just concentrate on how you might compile and run a single file of source code.</p>
<p>The usual introduction to any language is &quot;Hello, World!&quot;. A simple program that prints that message out to the console.</p>
<p>Here is how we might write it for C:</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  printf(&quot;Hello, World!\n&quot;);
  return 0;
}
</code></pre>
<p>C++ could write it the same way, or use streams if it preferred:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int main(int argc, char *argv[]) {
  cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;
  return 0;
}
</code></pre>
<p>And here is the equivalent in Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<p>There are some obvious points of similarity that we can observe:</p>
<ul>
<li>C/C++ and Rust follow the convention of having a <code>main()</code> function as the entry point into code. Note that Rust's main doesn't return anything. It's effectively a void method.</li>
<li>There is a general purpose print statement.</li>
<li>The general structure in terms of main, use of <code>{</code>, <code>}</code> and semi-colons is mostly the same. In both languages a block of code is enclosed in curly braces, and a semi-colon is used as a separator between statements.</li>
<li>Rust looks a little bit more terse than either C or C++ because it automatically includes references to part of its standard runtime that it refers to as its &quot;prelude&quot;.</li>
</ul>
<p>The <code>println!()</code> is actually a macro that expands into code that writes to the standard output. We know it's a macro because it ends in a <code>!</code> character but you may treat it like a function call for now. We'll see how Rust macros differ to those in C/C++ later.</p>
<h2 id="compiling-our-code"><a class="header" href="#compiling-our-code">Compiling our code</a></h2>
<p>Open a command prompt and set up your compiler environments.</p>
<p>If you were using gcc, youâ€™d compile your code like this:</p>
<pre><code class="language-bash">gcc hw.cpp -o hw
</code></pre>
<p>If you were using Microsoft Visual C++ you'd compile like this:</p>
<pre><code class="language-bash">cl /o hw.exe hw.cpp
</code></pre>
<p>To compile in Rust you invoke the rustc compiler.</p>
<pre><code class="language-bash">rustc hw.rs
</code></pre>
<p>And to run either</p>
<pre><code class="language-bash">./hw (or .\hw.exe)
Hello, World!
</code></pre>
<p>Again there are points of similarity:</p>
<ul>
<li>There is a shell command that compiles the code and creates an executable from it.</li>
<li>The binary runs in the same way.</li>
</ul>
<p>A less obvious point of similarity is that Rust shares its code generation backend with gcc-llvm and clang. Rustc outputs llvm bitcode which is compiled (and optimized) into machine code via LLVM. This means the resulting executable is very similar in form to that output by C++ compilers. That includes the symbolic information it supplies for debugging purposes. A rust executable can be debugged in gdb, lldb or Microsoft Visual Studio depending on the target platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-and-linking-in-more-detail"><a class="header" href="#compiling-and-linking-in-more-detail">Compiling and Linking in More Detail</a></h1>
<h2 id="your-main-entry-point"><a class="header" href="#your-main-entry-point">Your main() entry point</a></h2>
<p>Rust has a main function just like C/C++ which is usually called <code>main()</code>. <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>It doesnâ€™t take any arguments and it doesnâ€™t return anything unlike C/C++. Let's see how we might do those things.</p>
<h3 id="processing-command-line-arguments"><a class="header" href="#processing-command-line-arguments">Processing command-line arguments</a></h3>
<p>In C/C++, the entry point takes argc, and argv arguments. Argc is the number of arguments and argv is an array of char * pointers that specify those arguments.</p>
<pre><code class="language-c++">int main(int arcg, char **argv) {
  // our code
}
</code></pre>
<p>Processing arguments can become inordinately complex (and buggy) so most software will use a function like <code>getopt()</code> or <code>getopt_long()</code> to simplify the process.</p>
<p>Note that <code>getopt()</code> is not a standard C function and is not portable, e.g. to Windows. So immediately we see an example of problem that C/C++ forces us to solve.</p>
<p>Rust doesn't process arguments this way. Instead you access the command-line parameters from <code>std::env::args()</code> from anywhere in the code. That is to say, there is a function called <code>args()</code> under the namespace <code>std::env</code> that returns the strings on the command-line.</p>
<p>The function <code>args()</code> returns the parameters in a string array. As with C++, the first element of the array at index 0 is the command itself:</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
fn main() {
    for argument in env::args() {
        println!(&quot;{}&quot;, argument);
    }
}
</code></pre></pre>
<p>Alternatively, since <code>args()</code> returns a type called <code>Args</code> that implements the <code>Iterator</code> trait  you can collect the arguments up into your own collection and process that:</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::collections::HashSet;
fn main() {
    let args: HashSet&lt;String&gt; = env::args().collect();
    let verbose_flag = args.contains(&quot;--verbose&quot;);
}
</code></pre></pre>
<p>We can see some clear advantages to how Rust supplies args:</p>
<ul>
<li>You don't need a separate argc, parameter. You have an array that defines its own length.</li>
<li>You can access arguments from anywhere in your program, not just from the <code>main()</code>. In C++ you would have to pass your args around from one place to another. In Rust you can simply ask for them from anywhere.</li>
</ul>
<h4 id="use-a-crate---easy-command-line-processing"><a class="header" href="#use-a-crate---easy-command-line-processing">Use a crate - easy command-line processing</a></h4>
<p>Rust has a number of crates for processing arguments. The most popular crate for processing arguments is <a href="https://crates.io/crates/clap">clap</a>.</p>
<p>It provides a very descriptive, declarative way of adding rules for processing arguments into the code. It is especially useful if your program takes a lot of arguments, including parameters and validation rules.</p>
<p>For example we add this to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
clap = &quot;2.27&quot;
</code></pre>
<p>And in our <code>main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use] extern crate clap;
use clap::*;
fn main() {
  let matches = App::new(&quot;Sample App&quot;)
    .author(&quot;My Name &lt;myname@foocorp.com&gt;&quot;)
    .about(&quot;Sample application&quot;)
    .arg(Arg::with_name(&quot;T&quot;)
        .long(&quot;timetowait&quot;)
        .help(&quot;Waits some period of time for something to happen&quot;)
        .default_value(&quot;10&quot;)
        .takes_value(true)
        .possible_values(&amp;[&quot;10&quot;, &quot;20&quot;, &quot;30&quot;])
        .required(false))
    .get_matches();

  let time_to_wait = value_t_or_exit!(matches, &quot;T&quot;, u32);
  println!(&quot;Time to wait value is {}&quot;, time_to_wait);
}
</code></pre></pre>
<p>This code will process arguments for <code>-T</code> or <code>--timetowait</code> and ensure the value is one of 3 accepted. And if the user doesn't supply a value, it defaults to <code>10</code>. And if the user doesn't supply a valid integer it will terminate the application with a useful error.</p>
<p>The user can also provide <code>--help</code> as an argument and it will print out the usage.</p>
<h3 id="exit-code"><a class="header" href="#exit-code">Exit code</a></h3>
<p>If you want to exit with a code, you set it explicitly:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //... my code
    std::os::set_exit_status(1);
}
</code></pre></pre>
<p>When <code>main()</code> drops out, the runtime cleans up and returns the code to the environment. Again there is no reason the status code has to be set in <code>main()</code>, you could set it somewhere else and <code>panic!()</code> to cause the application to exit.</p>
<h2 id="optimized-compilation"><a class="header" href="#optimized-compilation">Optimized compilation</a></h2>
<p>In a typical edit / compile / debug cycle there is no need to optimize code and so Rust doesn't optimize unless you ask it to.</p>
<p>Optimization takes longer to happen and can reorder the code so that backtraces and debugging may not point at the proper lines of code in the source.</p>
<p>If you want to optimize your code, add a -O argument to rustc:</p>
<pre><code class="language-sh">rustc -O hw.rs
</code></pre>
<p>The act of optimization will cause Rust to invoke the LLVM optimizer prior to linking. This will produce faster executable code at the expense of compile time.</p>
<h2 id="incremental-compilation"><a class="header" href="#incremental-compilation">Incremental compilation</a></h2>
<p>Incremental compilation is also important for edit / compile / debug cycles. Incremental compilation only rebuilds those parts of the code which have changed through modification to minimize the amount of time it takes to rebuild the product.</p>
<p>Rust has a different incremental compilation model to C++.</p>
<ul>
<li>C++ doesn't support incremental compilation per se. That function is left to the make / project / solution tool. Most builders will track a list of project files and which file depends on other files. So if file foo.h changes then the builder knows what other files depend on it and ensures they are rebuilt before relinking the target executable.</li>
<li>In Rust incremental compilation is at the crate level - that if any file in a crate changes then the crate as a whole has to be rebuilt. Thus larger code bases tend to be split up into crates to reduce the incremental build time.</li>
</ul>
<p>There is a recognition in the Rust community that the crate-level model can suck for large crates so the Rust compiler is getting <a href="https://blog.rust-lang.org/2016/09/08/incremental.html">incremental per-file compilation support</a> in addition to per-crate.</p>
<p>At the time of writing this support is experimental because it is tied to refactoring the compiler for other reasons to improve performance and optimization but will eventually be enabled and supported by rustc and cargo.</p>
<h2 id="managing-a-project"><a class="header" href="#managing-a-project">Managing a project</a></h2>
<p>In C++ we would use a <code>makefile</code> or a solution file of some kind to manage a real world project and build it.</p>
<p>For small programs we might run a script or invoke a compiler directly but as our program grows and takes longer to build, we would have to use a <code>makefile</code> to maintain our sanity.</p>
<p>A typical <code>makefile</code> has rules that say what files are our sources, how each source depends on other sources (like headers), what our final executable is and a bunch of other mess about compile and link flags that must be maintained.</p>
<p>There are lots of different makefile solutions which have cropped up over the years but a simple gmake might look like one:</p>
<pre><code>SRCS = main.o pacman.o sprites.o sfx.o
OBJS = $(SRCS:.cpp=.o)
EXE = pacman
$(EXE): $(OBJS)
    $(CC) $(CFLAGS) -o $(EXE) $(OBJS)
.cpp.o:
    $(CC) $(CFLAGS) -c $&lt; -o $@
</code></pre>
<p>When you invoke <code>make</code>, the software will check all the dependencies of your target, looking at their filestamps and determine which rules need to be invoked and which order to rebuild your code.</p>
<p>Rust makes things a lot easier â€“ there is no makefile! The source code is the makefile. Each file says what other files it uses via depencies on other crates, and on other modules.</p>
<p>Consider this main.rs for a pacman game:</p>
<pre><pre class="playground"><code class="language-rust">mod pacman;

fn main() {
  let mut game = pacman::Game::new();
  game.start();
}
</code></pre></pre>
<p>If we save this file and type <code>rustc main.rs</code> the compiler will notice the reference to <code>mod pacman</code> and will search for a <code>pacman.rs</code> (or <code>pacman/mod.rs</code>) and compile that too. It will continue doing this with any other modules referenced along the way.</p>
<p>In other words you could have a project with 1000 files and compile it as simply as <code>rustc main.rs</code>. Anything referenced is automatically compiled and linked.</p>
<p>Okay, so we can call <code>rustc</code>, but what happens if our code has dependencies on other projects. Or if our project is meant to be exported so other projects can use it?</p>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p>Cargo is a package manager build tool rolled into one. Cargo can fetch dependencies, build them, build and link your code, run unit tests, install binaries, produce documentation and upload versions of your project to a repository.</p>
<p>The easiest way to create a new project in Rust is to use the <code>cargo</code> command to do it</p>
<pre><code>cargo new hello_world â€“bin
</code></pre>
<p>Creates this</p>
<pre><code>hello_world/
  .git/ (git repo)
  .gitignore
  Cargo.toml
  src/
    main.rs
</code></pre>
<p>Building the project is then simply a matter of this:</p>
<pre><code>cargo build
</code></pre>
<p>If you want to build for release you add a --release argument. This will invokes the rust compiler with optimizations enabled:</p>
<pre><code>cargo build --release
</code></pre>
<p>If we wanted to build and run unit tests in our code we could write</p>
<pre><code>cargo test
</code></pre>
<h3 id="crates-and-external-dependencies"><a class="header" href="#crates-and-external-dependencies">Crates and external dependencies</a></h3>
<p>Cargo doesn't just take care of building our code, it also ensures that anything our code depends on is also downloaded and built. These external dependencies are defined in a <code>Cargo.toml</code> in our project root.</p>
<p>We can edit that file to say we have a dependency on an external &quot;crate&quot; such as the <code>time</code> crate:</p>
<pre><code>[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Joe Blogs &lt;jbloggs@somewhere.com&gt;&quot;]

[dependencies]
time = &quot;0.1.35&quot;
</code></pre>
<p>Now when we run <code>cargo build</code>, it will fetch &quot;time&quot; from crates.io and also any dependencies that &quot;time&quot; has itself. Then it will build each crate in turn automatically. It does this efficiently so iterative builds do not incur a penalty. External crates are download and built in your .cargo home directory.</p>
<p>To use our external crate we declare it in the main.rs of our code, e.g.</p>
<pre><pre class="playground"><code class="language-rust">extern crate time;

fn main() {
  let now = time::PreciseTime::now();
  println!(&quot;The time is {:?}&quot;, now);
}
</code></pre></pre>
<p>So the change to the <code>Cargo.toml</code> and a reference in the source is sufficient to:</p>
<ol>
<li>Fetch the crate (and any dependencies)</li>
<li>Build the crate (and any dependencies)</li>
<li>Compile and link to the crate and dependencies</li>
</ol>
<p>All that happened with a line in <code>Cargo.toml</code> and a line in our code to reference the crate. We didn't have to mess around figuring how to build the other library, or maintain multiple makefiles, or getting our compiler / linker flags right. It just happened.</p>
<h4 id="cargolock"><a class="header" href="#cargolock">Cargo.lock</a></h4>
<p>Also note that once we build, cargo creates a <code>Cargo.lock</code> file in our root directory.</p>
<p>This file is made so that if <code>cargo build</code> is invoked again it has an exact list of what packages need to be pulled and compiled. It stops situations where the code under our feet (so to speak) moves and suddenly our project no longer builds. So if the lock file exists, the same dependency configuration can be reproduced even from a clean. If you want to force the cargo to rebuild a new lock file, e.g. after changing <code>Cargo.toml</code>, you can type <code>cargo update</code>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>You can change the main entry point using a special  <code>#[start]</code> directive if you want on another function but the default is main()</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-layout-and-other-general-points"><a class="header" href="#source-layout-and-other-general-points">Source Layout and Other General Points</a></h1>
<h2 id="header-files"><a class="header" href="#header-files">Header files</a></h2>
<h3 id="c-c"><a class="header" href="#c-c">C/ C++</a></h3>
<p>C and C++ code tends to be split over two general kinds of file:</p>
<ul>
<li>The Header file contains class definitions, external function signatures, macros, templates, inline functions. Sometimes inline functions get stored in their own file. The standard template library C++ headers may omit file extension. Some 3rd party libraries like Qt may also omit the file extension.</li>
<li>The Source file contains the implementation of the source code. Source files will usually <code>#include</code> one or more header files to obtain the definitions of things the implementation needs to call or implement.</li>
</ul>
<p>Prior to compilation, a <em>preprocessor</em> will read and follow the <code>#include</code> directives in a source file and produce a concatenated file for the compiler to parse. The preprocessor will also handle <code>#ifdef</code> and <code>#define</code> commands in this step. </p>
<p>Splitting source into definitions and implementation can increase code maintenance. So too that the compiler does not support forward referencing - you must describe a type / function before the thing that uses it. </p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust does not use header files. Instead every struct, implementation, function, const, and macro resides in a file ending in .rs. Code is made public or not by structuring .rs files into modules and exposing functions via the <code>pub</code> keyword.</p>
<p>For functions, the definition and the implementation are the same thing - the function implementation's signature is its definition.</p>
<p>For structs, the structure is declared and there are zero or more implementation blocks for functions and traits that are associated with the struct. Usually the implementation and definition will reside right next to each other.</p>
<p>Other modules can <code>use</code> the other module's public types and functions and the compiler will obtain the definition.</p>
<p>Rust can forward reference structs or functions, or even <code>use</code> the very same module that a piece of code is a part of. </p>
<p>The only time that ordering matters is for macro definitions. A macro must be defined before a module that uses it. </p>
<p>Rust files reference non-dependent modules with the <code>use</code> keyword and pull-in dependent modules with the <code>mod</code> keyword.</p>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<h2 id="c--c"><a class="header" href="#c--c">C / C++</a></h2>
<p>C does not use namespaces. Libraries tend to prefix their functions and structs with a qualifying name of some sort. </p>
<p>e.g. the SQLite3 library prefixes every function,  struct and macro definition</p>
<pre><code class="language-c++">SQLITE_API SQLITE_EXTERN const char sqlite3_version[];
SQLITE_API const char *SQLITE_STDCALL sqlite3_libversion(void);
SQLITE_API const char *SQLITE_STDCALL sqlite3_sourceid(void);
SQLITE_API int SQLITE_STDCALL sqlite3_libversion_number(void);
</code></pre>
<p>C++ <em>does</em> have namespaces but their use is optional and varies from one piece of code to the next. Some code may hold all their definitions in a single flat namespace while others may nest namespaces. </p>
<p>A <code>math.h</code></p>
<pre><code class="language-c++">namespace math {
  double sqrt(double v);
}
</code></pre>
<pre><code class="language-c++">#include &quot;math.h&quot;
//...
auto v = math::sqrt(4);
}
</code></pre>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<p>Rust has modules which are like <code>#include</code> and namespaces rolled into one</p>
<p>One major convenience definition and implementation are one and the same. Implementing a function brings it into existence. Any other module that chooses to &quot;use&quot; it simply says so and the compiler will ensure it compiles properly.</p>
<p>See <a href="06_source_layout/../namespacing_with_modules/index.html">Namespacing with modules</a></p>
<h2 id="file-name-conventions"><a class="header" href="#file-name-conventions">File name conventions</a></h2>
<p>In C++ filenames typically end in:</p>
<ul>
<li><code>.h</code>, <code>.hpp</code>, <code>.inl</code> for headers or inline code. Some libraries may omit an extension from their header files.</li>
<li><code>.c</code>, <code>.cpp</code>, <code>.cc</code> for source code. A compiler will usually infer the source is C or C++ by its extension.</li>
</ul>
<p>Aside from the extension (which may kick off the compiler expecting C or C++) there is next to no expected arrangement or naming convention for files. They can be in any folder structure and any mix of upper and lower case.</p>
<p>Rust files have a <code>.rs</code> extension and are are snake_case.  The filename DOES matter because the name is also the module name that scopes whatever is in it. </p>
<p>So if I have a file called <code>math.rs</code>, then the module is called <code>math</code>. Alternatively I can create a file <code>math/mod.rs</code> and the module is also inferred to be <code>math</code>. So if there were a <code>sqrt(v: f64)</code> function, then it would be called everything in it is scoped <code>math::sqrt</code>.</p>
<p>In <code>math.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sqrt(v: f64) : f64 {
  //....
}
<span class="boring">}
</span></code></pre></pre>
<p>Caller:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use math;
//...
let v = math::sqrt(4);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespacing-with-modules"><a class="header" href="#namespacing-with-modules">Namespacing With Modules</a></h1>
<p>C++ namespaces allow you to group your functions, variables and classes into logical blocks and allow the compiler to disambiguate them from other functions, variables and classes that might otherwise have the same name.</p>
<pre><code class="language-c++">// Namespacing is usually a good idea
namespace myapp {
  void error() {
    //...
  }
  const int SOME_VALUE = 20;
  void doSomething(int value) {
    //...
  }
}
//... somewhere else in the code
myapp::doSomething(100);
</code></pre>
<p>Namespacing in C++ is completely optional which means some code may use nest namespaces while other code may be content to cover its entire codebase with a single namespace. Some code might even put its code into the global namespace. Other code might control the use of namespaces with macros.</p>
<p>The equivalent to a namespace in Rust is a module and serves a similar purpose.  Unlike C++ though you get namespacing automatically from the structure of your files. Each file is a module in its own right.</p>
<p>So if we may have a file myapp.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// myapp.rs
pub fn error() { /* ... */ }
pub const SOME_VALUE: i32 = 20;
pub fn doSomething(value: i32) { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>Everything in myapp.rs is automatically a module called myapp. That means modules are implicit and you don't have to do anything except name your file something meaningful.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use myapp;
myapp::doSomething(myapp::SOME_VALUE);
<span class="boring">}
</span></code></pre></pre>
<p>You could also just bring in the whole of the mod if you like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use myapp::*;
doSomething(SOME_VALUE);
<span class="boring">}
</span></code></pre></pre>
<p>Or just the types and functions within it that you use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use myapp::{doSomething, SOME_VALUE}
doSomething(SOME_VALUE);
// Other bits can still be referenced by their qualifying mod
myapp::error();
<span class="boring">}
</span></code></pre></pre>
<p>But if you want an explicit module you may also write it in the code. So perhaps myapp doesn't justify being a separate file.</p>
<pre><code>// main.rs
mod myapp {
  pub fn error() { /* ... */ }
  pub const SOME_VALUE = 20;
  pub fn doSomething(value: i32) { /* ... */ }
}
</code></pre>
<p>Modules can be nested so a combination of implicit modules (from file names) and explicit modules can be used together.</p>
<h2 id="splitting-modules-across-files"><a class="header" href="#splitting-modules-across-files">Splitting modules across files</a></h2>
<p>Namespacing with modules is pretty easy, But sometimes you might have lots of files in a module and you don't want the outside world to see a single module namespace.</p>
<p>In these cases youâ€™re more likely to use the myapp/mod.rs form. In this instance the mod.rs file may pull</p>
<p>in subordinate files</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// myapp/mod.rs
mod helpers;
mod gui;

#[cfg(test)]
mod tests

// Perhaps we want the outside world to see myapp::Helper
pub use helpers::Helper;
<span class="boring">}
</span></code></pre></pre>
<p>In this example, the module pulls in submodules <code>helpers</code> and <code>gui</code>. Neither is marked as <code>pub mod</code> so they are private to the module.</p>
<p>However the module also says <code>pub use helpers::Helper</code> which allows the outside to reference <code>myapp::Helper</code>. Thus a module can act as a gatekeeper to the things it references, keeping them private or selectively making parts public.</p>
<p>We haven't mentioned the other module here <code>tests</code>. The attribute <code>#[cfg(test)]</code> indicates it is only pulled in when a unit test executable is being built. The <code>cfg</code> attribute is used for <a href="https://doc.rust-lang.org/book/conditional-compilation.html">conditional compliation</a>.</p>
<h2 id="using-a-module"><a class="header" href="#using-a-module">Using a module</a></h2>
<p>Modules can be used once they are defined.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use helpers::*;
<span class="boring">}
</span></code></pre></pre>
<p>Note that the use command is relative to the toplevel <code>main</code> or <code>lib</code> module. So if you declare a <code>mod helpers</code> at the top, then the corresponding <code>use helpers</code> will retrieve it. You can also use relative <code>use</code> commands with the <code>super</code> and <code>self</code> keywords.</p>
<p>// TODOs</p>
<h2 id="module-aliasing"><a class="header" href="#module-aliasing">Module aliasing</a></h2>
<p>TODO</p>
<h2 id="external-crates"><a class="header" href="#external-crates">External crates</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="porting-code"><a class="header" href="#porting-code">Porting Code</a></h1>
<p>Before starting, the assumption at this point is you <em>need</em> to port code. But before doing that remember that if it ain't broke then don't fix it. Code that works is probably not worth changing unless it is small enough that you can reliably do it.</p>
<h2 id="automation-tools"><a class="header" href="#automation-tools">Automation tools</a></h2>
<h3 id="c2rust"><a class="header" href="#c2rust">C2Rust</a></h3>
<p>The <a href="https://github.com/immunant/c2rust">C2Rust project</a> is developing a tool that translates C to semantically equivalent Rust.</p>
<p>There is an online demo of it working <a href="https://c2rust.com/">here</a>.</p>
<p>As C is unsafe by default, it means the Rust equivalent is also unsafe by default, but it can be useful as a starting point for converting code.</p>
<h3 id="corrode"><a class="header" href="#corrode">Corrode</a></h3>
<p><a href="https://github.com/jameysharp/corrode">Corrode</a> is a command-line tool that can partially convert C into Rust. At the very least it may spare you some drudgery ensuring the functionality is as close to the original as possible.</p>
<p>Corrode will take a C file, e.g. <code>somefile.c</code> plus any arguments from <code>gcc</code> and produces a <code>somefile.rs</code> which is the equivalent code in Rust. </p>
<p>It works by parsing the C code into an abstract syntax tree and then generating Rust from that.</p>
<p>Interestingly Corrode is written in Haskell and more interestingly is written as a <a href="https://github.com/jameysharp/corrode/blob/master/src/Language/Rust/Corrode/C.md">literate Haskell source</a> - the code is a markdown document interspersed with Haskell.</p>
<h3 id="bindgen"><a class="header" href="#bindgen">Bindgen</a></h3>
<p><a href="https://github.com/servo/rust-bindgen">Bindgen</a> is a tool for generating FFI interfaces for Rust from existing C and C++ header files. You might find this beneficial if you're porting code from C / C++, or writing a new component that must work with an existing code base.</p>
<p>Bindgen requires that you preinstall the Clang C++ compiler in order to parse code into a structure it can digest. </p>
<p>The readme documentation on the site link provides more information on installing and using the tool.</p>
<h3 id="cbindgen"><a class="header" href="#cbindgen">CBindgen</a></h3>
<p><a href="https://github.com/eqrion/cbindgen">CBindgen</a> works in the opposite direction of bindgen - it produces C header files from Rust constants, structures and functions.</p>
<p>So if you have Rust code that you wish to call from C, then you can generate the appropriate header files that enable you to do this. Functions that you expose to C are implicitly unsafe on the outside.</p>
<p>So here is a sample lib.rs (using the libc crate) that prints a simple message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use libc::c_char;
use std::ffi::CStr;

#[no_mangle]
pub unsafe extern fn print_hello(name: *const c_char) {
    let name = CStr::from_ptr(name);
    let name = name.to_str().unwrap();
    println!(&quot;Hello {}!&quot;, name);
}
<span class="boring">}
</span></code></pre></pre>
<p>C headers can be produced from the command line like so:</p>
<pre><code>cargo install cbindgen
cbindgen -o hello.h
</code></pre>
<p>Producing this <code>hello.h</code> header file:</p>
<pre><code class="language-c">#include &lt;cstdarg&gt;
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;ostream&gt;
#include &lt;new&gt;

extern &quot;C&quot; {

void print_hello(const char *name);

} // extern &quot;C&quot;
</code></pre>
<p>Alternatively you can create a <code>build.rs</code> that automatically creates the bindings when you build your crate:</p>
<pre><pre class="playground"><code class="language-rust">extern crate cbindgen;

use std::env;

fn main() {
    let crate_dir = env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap();
    cbindgen::Builder::new()
      .with_crate(crate_dir)
      .generate()
      .expect(&quot;Unable to generate bindings&quot;)
      .write_to_file(&quot;hello.h&quot;);
}
</code></pre></pre>
<p>A <code>cbindgen.toml</code> allows you to configure things that go into the header file. See the site link for more information.</p>
<h2 id="experiences"><a class="header" href="#experiences">Experiences</a></h2>
<p>A number of websites offer insights of the porting process from C to Rust</p>
<ol>
<li><a href="https://github.com/carols10cents/rust-out-your-c-talk">Porting Zopfli from C to Rust</a>. Zopfli is a library that performs good but slow deflate algorithm. It produces smaller compressed files than zlib while still remaining compatible with it. </li>
<li>TODO</li>
</ol>
<h1 id="tips"><a class="header" href="#tips">Tips</a></h1>
<h2 id="use-references-wherever-you-can"><a class="header" href="#use-references-wherever-you-can">Use references wherever you can</a></h2>
<p>TODO references are equivalent to C++ references or to pointers in C. Passing by reference is an efficient way of passing any object greater than 64-bits in size into a function without relinquishing ownership. In some cases, it is even a good idea to return by reference since the caller can always clone the object if they need to, and more often than not they can just use the reference providing the lifetimes allow for it.</p>
<p>TODO you do not need to use references on intrinstic types such as integers, bools etc. and there is no point unless you intend for them to be mutable and change. </p>
<h2 id="move-semantics-1"><a class="header" href="#move-semantics-1">Move semantics</a></h2>
<p>C and C++ default to copy on assign. Unless you explicitly implement a move constructor on objects, the default is copy. Copying is dangerous because it allows two data structures to potentially point to the same data, e.g. a raw file handle. Even if code implements a move constructor, the compiler will not care if you reference the old 
object so you are required to put the object into a valid but safe state.</p>
<p>Rust by default will move on assign unless the type implements a <code>Copy</code> trait. Only simple primitives or structs comprised of simple primitives can implement or derive the <code>Copy</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 100;
let y = x; // This is a copy
println!(&quot;x = {}&quot;, x);

let x = &quot;Hello world&quot;.to_string();
let y = x; // This is a move
println!(&quot;x = {}&quot;, x); // compile error
<span class="boring">}
</span></code></pre></pre>
<p>And unlike C++, you CANNOT access the old object once you have assigned the value to a new one. The compiler will generate an error if you try.</p>
<p>If you need to copy data in Rust you must implement / derive the <code>Clone</code> trait which allows you to explicitly invoke <code>.clone()</code> to make a copy of an object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;Hello world&quot;.to_string();
let y = x.clone();
println!(&quot;x = {}&quot;, x);

#[derive(Clone)]
struct MyData {
  name: String;
}
///...
let x = MyData { name: &quot;Fred&quot;.to_string() };
let y = x.clone();
<span class="boring">}
</span></code></pre></pre>
<h2 id="use-modules-to-naturally-arrange-your-source-code"><a class="header" href="#use-modules-to-naturally-arrange-your-source-code">Use modules to naturally arrange your source code</a></h2>
<p>TODO</p>
<h2 id="using-composition-and-traits"><a class="header" href="#using-composition-and-traits">Using composition and traits</a></h2>
<p>TODO Rust does not allow you to inherit one struct from another. The manner of overcoming this.</p>
<h2 id="using-cargotoml-to-create-your-build-profiles"><a class="header" href="#using-cargotoml-to-create-your-build-profiles">Using Cargo.toml to create your build profiles</a></h2>
<h2 id="use-rust-naming-conventions-and-formatting"><a class="header" href="#use-rust-naming-conventions-and-formatting">Use Rust naming conventions and formatting</a></h2>
<p>C and C++ have never had </p>
<h1 id="foreign-function-interface"><a class="header" href="#foreign-function-interface">Foreign Function Interface</a></h1>
<p>TODO for now read the <a href="http://jakegoulding.com/rust-ffi-omnibus/">FFI omnibus</a>.</p>
<h2 id="leaving-function-names-unmangled"><a class="header" href="#leaving-function-names-unmangled">Leaving function names unmangled</a></h2>
<p>TODO attribute no_mangle</p>
<h2 id="libc"><a class="header" href="#libc">libc</a></h2>
<p>TODO Rust provides a crate with bindings for C library functions. If you find yourself receiving a pointer allocated with malloc you could free it with the corresponding call to free() via the bindings.</p>
<p>TODO add the following to your <code>Cargo.toml</code></p>
<pre><code>[dependencies]
libc = &quot;*&quot;
</code></pre>
<p>TODO example of using libc</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-of-rust-compared-with-c"><a class="header" href="#features-of-rust-compared-with-c">Features of Rust compared with C++</a></h1>
<p>Rust and C++ are compiled languages with support for the following.</p>
<ul>
<li>Variables</li>
<li>Expressions</li>
<li>Structures and types</li>
<li>Enums</li>
<li>Memory allocation</li>
<li>Strings</li>
<li>Collections</li>
<li>Threads</li>
<li>Error handling</li>
</ul>
<p>In some cases these are done in an analogous or similar fashion, in others they are very different.</p>
<p>In some cases, C++ is the victim of circumstances. For example  Unicode and encodings like UTF-8 are relatively recent compared to the language  so support was retrofitted into the string types and can feel a little clunky. Whereas Rust was able to benefit from an elegant choice from the get go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<h2 id="data-model"><a class="header" href="#data-model">Data model</a></h2>
<p>C/C++ compilers implement a <em>data model</em> that affects what the width of standard types are. The general rule is that:</p>
<p><code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code></p>
<p>So basically you <em>cannot</em> tell how big any type is other than a <code>short</code> is at least as big as a <code>char</code> and so on. </p>
<p>Compilers tend implement a data model which determines the size of types. The four common data models in C++ are:</p>
<ul>
<li>LP32 - <code>int</code> is 16-bit, <code>long</code> and pointers are 32-bit. This is an uncommon model (mostly gone since the days of DOS / Windows 3.1) but it is still used on some Arduino targets.</li>
<li>ILP32 - <code>int</code>, <code>long</code> and pointers are 32-bit. Used by Win32, Linux, OS X</li>
<li>LLP64 - <code>int</code> and <code>long</code> are 32-bit, <code>long long</code> and pointers are 64-bit. Used by Win64</li>
<li>LP64 - <code>int</code> is 32-bit, <code>long</code> / <code>long long</code> and pointers are 64-bit. Used by Linux, OS X</li>
</ul>
<p>As you can see, potentially everything all the way to <code>long long</code> could be a single byte, or there could be some other crazy definition. In practice software expects one of the models above.</p>
<h3 id="stdinth--cstdint"><a class="header" href="#stdinth--cstdint">stdint.h / cstdint</a></h3>
<p>C provides a <code>&lt;stdint.h&gt;</code> header that provides unambigious typedefs with length and signedess, e.g. <code>uint32_t</code>. The equivalent in C++ is <code>&lt;cstdint&gt;</code>.</p>
<p>If you use the types defined in this header file the types become directly analogous and unambiguous between C/C++ and Rust.</p>
<div class="table-wrapper"><table><thead><tr><th>C/C++</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>int8_t</code></td><td><code>i8</code></td></tr>
<tr><td><code>uint8_t</code></td><td><code>u8</code></td></tr>
<tr><td><code>int16_t</code></td><td><code>i16</code></td></tr>
<tr><td><code>uint16_t</code></td><td><code>u16</code></td></tr>
<tr><td><code>uint32_t</code></td><td><code>u32</code></td></tr>
<tr><td><code>int32_t</code></td><td><code>i32</code></td></tr>
<tr><td><code>int64_t</code></td><td><code>i64</code></td></tr>
<tr><td><code>uint64_t</code></td><td><code>u64</code></td></tr>
</tbody></table>
</div>
<h2 id="comparing-cc-types-to-rust"><a class="header" href="#comparing-cc-types-to-rust">Comparing C/C++ types to Rust</a></h2>
<p>If code isn't using unambiguous types then these are the <em>most likely</em> analogous types between Rust and C/C++.</p>
<div class="table-wrapper"><table><thead><tr><th>C/C++</th><th>Rust</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>i8</code> (or <code>u8</code>)</td><td>The signedness of a C++ char can be signed or unsigned - the assumption here is signed but it varies by target system.<br>A Rust <code>char</code> is not the same as a C/C++ <code>char</code> since it can hold any Unicode character. <sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
<tr><td><code>unsigned char</code></td><td><code>u8</code></td><td></td></tr>
<tr><td><code>signed char</code></td><td><code>i8</code></td><td></td></tr>
<tr><td><code>short int</code></td><td><code>i16</code></td><td></td></tr>
<tr><td><code>unsigned short int</code></td><td><code>u16</code></td><td></td></tr>
<tr><td><code>(signed) int</code></td><td><code>i32</code> or <code>i16</code></td><td>In C/C++ this is data model dependent <sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>unsigned int</code></td><td><code>u32</code> or <code>u16</code></td><td>In C/C++ this is data model dependent <sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>(signed) long int</code></td><td><code>i32</code> or <code>i64</code></td><td>In C/C++ this is data model dependent <sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>unsigned long int</code></td><td><code>u32</code> or <code>u64</code></td><td>In C/C++ this is data model dependent <sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>(signed) long long int</code></td><td><code>i64</code></td><td></td></tr>
<tr><td><code>unsigned long long int</code></td><td><code>u64</code></td><td></td></tr>
<tr><td><code>size_t</code></td><td><code>usize</code></td><td>usize holds numbers as large as the address space <sup class="footnote-reference"><a href="#3">3</a></sup></td></tr>
<tr><td><code>float</code></td><td><code>f32</code></td><td></td></tr>
<tr><td><code>double</code></td><td><code>f64</code></td><td></td></tr>
<tr><td><code>long double</code></td><td><s>f128</s></td><td>f128 support was present in Rust but removed due to issues for some platforms in implementing it.</td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>void</code></td><td><code>()</code></td><td>The unit type (see below)</td></tr>
</tbody></table>
</div>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Rust's <code>char</code> type, is 4 bytes wide, enough to hold any Unicode character. This is equivalent to the belated <code>char32_t</code> that appears in C++11 to rectify the abused C++98 <code>wchar_t</code> type which on operating systems such as Windows is only 2 bytes wide. When you iterate strings in Rust you may do so either by character or <code>u8</code>, i.e. a byte.</p>
<p><sup class="footnote-reference"><a href="#2">2</a></sup> See the next section to for a discussion on data models.</p>
<p><sup class="footnote-reference"><a href="#3">3</a></sup> Rust has a specific numeric type for indexing on arrays and collections called <code>usize</code>. A <code>usize</code> is designed to be able to reference as many elements in an array as there is addressable memory. i.e. if memory is 64-bit addressable then usize is 64-bits in length. There is also a signed <code>isize</code> which is less used but also available.</p>
<h3 id="machine-types-under-the-covers"><a class="header" href="#machine-types-under-the-covers">Machine types under the covers</a></h3>
<p>C/C++ and Rust will share the same machine types for each corresponding language type and the same compiler / backend technology, i.e.:</p>
<ol>
<li>Signed types are two's complement</li>
<li>IEE 754-2008 binary32 and binary64 floating points for float and double precision types.</li>
</ol>
<h2 id="integer-types"><a class="header" href="#integer-types">Integer types</a></h2>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<p>C/C++ has primitive types for numeric values, floating point values and booleans. Strings will be dealt in a separate section.</p>
<p>Integer types (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>) come in <code>signed</code> and <code>unsigned</code> versions.</p>
<p>A <code>char</code> is always 8-bits, but for historical reasons, the standards only guarantee the other types are &quot;at least&quot; a certain number of bits. So an <code>int</code> is ordinarily 32-bits but the standard only say it should be at <em>least as large</em> as a <code>short</code>, so potentially it could be 16-bits!</p>
<p>More recent versions of C and C++ provide a <a href="http://www.cplusplus.com/reference/cstdint/"><code>&lt;cstdint&gt;</code></a> (or <code>&lt;stdint.h&gt;</code> for C) with typedefs that are unambiguous about their precision.</p>
<p>Even though <code>&lt;stdint.h&gt;</code> can clear up the ambiguities, code frequently sacrifices correctness for terseness. It is not unusual to see an <code>int</code> used as a temporary incremental value in a loop:</p>
<pre><code class="language-c++">string s = read_file();
for (int i = 0; i &lt; s.size(); ++i) {
  //...
}
</code></pre>
<p>While <code>int</code> is unlikely to fail for most loops in a modern compiler supporting ILP32 or greater, it is still technically wrong. In a LP32 data model incrementing 32767 by one would become -32768 so this loop would never terminate if <code>s.size()</code> was a value greater than that.</p>
<p>But look again at this snippet. What if the file read by <code>read_file()</code> is outside of our control. What if someone deliberately or accidentally feeds us a file so large that our loop will fail trying to iterate over it? In doing so our code is hopelessly broken.</p>
<p>This loop should be using the same type returned from <code>string::size()</code> which is an opaque unsigned integer type called <code>size_type</code>. This is usually a typedef for <code>std::size_t</code> but not necessarily. Thus we have a type mismatch. A <code>string</code> has an iterator which could be used instead but perhaps you need the index for some reason, but it can messy:</p>
<pre><code class="language-c++">string s = read_file();
for (string::iterator i = s.begin(); i != s.end(); ++i) {
  string::difference_type idx = std::distance(s.begin(), i);
  //...
}
</code></pre>
<p>Now we've swapped from one opaque type <code>size_type</code> to another called <code>difference_type</code>. Ugh.</p>
<p>C/C++ types can also be needlessly wordy such as <code>unsigned long long int</code>. Again, this sort of puffery encourages code to make bad assumptions, use a less wordy type, or bloat the code with typedefs.</p>
<h2 id="rust-2"><a class="header" href="#rust-2">Rust</a></h2>
<p>Rust benefits from integer types that unambiguously denote their signedness and width in their name - <code>i16</code>, <code>u8</code> etc.</p>
<p>They are also extremely terse making it easy to declare and use them. For example a <code>u32</code> is an unsigned 32-bit integer. An <code>i64</code> is a signed 64-bit integer.</p>
<p>Types may be inferred or explicitly prefixed to the value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = 1000;
let v2 : u32 = 25;
let v3 = 126i8;
<span class="boring">}
</span></code></pre></pre>
<p>Rust also has two types called <code>usize</code> and <code>isize</code> respectively. These are equivalent to <code>size_t</code> in that they are as large enough to hold as many elements as there is addressable memory. So in a 32-bit operating system they will be 32-bits in size, in a 64-bit operating system they will be 64-bits in size.</p>
<p>Rust will not implicitly coerce an integer from one size to another without explicit use of the <code>as</code> keyword.</p>
<pre><code>let v1 = 1000u32;
let v2: u16 = v1 as u16;
</code></pre>
<h2 id="real-types"><a class="header" href="#real-types">Real types</a></h2>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<p>C/C++ has float, double and long double precision floating point types and they suffer the same vagueness as integer types.</p>
<ul>
<li><code>float</code></li>
<li><code>double</code> - &quot;at least as much precision as a <code>float</code>&quot;</li>
<li><code>long double</code> - &quot;at least as much precision as a <code>double</code>&quot;</li>
</ul>
<p>In most compilers and architectures however a float is a 32-bit single precision value, and a double is an 64-bit double precision value. The most common machine representation is the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754-2008 format</a>.</p>
<h4 id="long-double"><a class="header" href="#long-double">Long double</a></h4>
<p>The <a href="https://en.wikipedia.org/wiki/Long_double"><code>long double</code></a> has proven quite problematic for compilers. Despite the expectation that it is a quadruple precision value it usually isn't. Some compilers such as gcc may offer 80-bit extended precision on x86 processors with a floating point unit but it is implementation defined behaviour.</p>
<p>The Microsoft Visual C++ compiler treats it with the same precision as a <code>double</code>. Other architectures may treat it as quadruple precision. The fundamental problem with <code>long double</code> is that most desktop processors do not have the ability in hardware to perform 128-bit floating point operations so a compiler must either implement it in software or not bother.</p>
<h4 id="math-functions"><a class="header" href="#math-functions">Math functions</a></h4>
<p>The <code>&lt;math.h&gt;</code> / <code>&lt;cmath&gt;</code> C header provides math functions for working with different precision types.</p>
<pre><code class="language-c++">#include &lt;math.h&gt;

const double PI = 3.1415927;
double result = cos(45.0 * PI / 180.0);
//..
double result2 = abs(-124.77);
//..
float result3 = sqrtf(9.0f);
//
long double result4 = powl(9,10);
</code></pre>
<p>Note how different calls are required according to the precision, e.g. <code>sinf</code>, <code>sin</code> or <code>sinl</code>. C99 supplies a &quot;type-generic&quot; set of macros in <code>&lt;tgmath.h&gt;</code> which allows <code>sin()</code> to be used regardless of type.</p>
<p>C++11 provides a <code>&lt;cmath&gt;</code> that uses specialised inline functions for the same purpose:</p>
<pre><code class="language-c++">#include &lt;cmath&gt;
float result = std::sqrt(9.0f);
</code></pre>
<h3 id="rust-3"><a class="header" href="#rust-3">Rust</a></h3>
<p>Rust implements two floating point types - <code>f32</code> and <code>f64</code>. These would be analogous to a 32-bit <code>float</code> and 64-bit <code>double</code> in C/C++.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = 10.0;
let v2 = 99.99f32;
let v3 = -10e4f64;
<span class="boring">}
</span></code></pre></pre>
<p>Unlike in C/C++, the math functions are directly bound to the type itself providing you properly qualify the type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = 10.0f32.sqrt();
//
let angle = 45.0f64;
let result2 = angle.to_radians().cos();
<span class="boring">}
</span></code></pre></pre>
<p>Rust does not have a 128-bit double. A <code>f128</code> did exist for a period of time but was removed to portability, complexity and maintenance issues. Note how <code>long double</code> is treated (or not) according to the compiler and target platform. </p>
<p>At some point Rust might get a f128 or f80 but at this time does not have such a type.</p>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>A <code>bool</code> (boolean) type in C/C++ can have the value <code>true</code> or <code>false</code>, however it can be promoted to an integer type (0 == <code>false</code>, 1 == <code>true</code>) and a bool even has a ++ operator for turning false to true although it has no -- operator!?</p>
<p>But inverting true with a ! becomes false and vice versa.</p>
<pre><code class="language-c++">!false == true
!true == false
</code></pre>
<p>Rust also has a <code>bool</code> type that can have the value <code>true</code> or <code>false</code>. Unlike C/C++ it is a true type with no promotion to integer type</p>
<h2 id="void--unit-type"><a class="header" href="#void--unit-type">void / Unit type</a></h2>
<p>C/C++ uses <code>void</code> to specify a type of nothing or an indeterminate pointer to something.</p>
<pre><code class="language-c++">// A function that doesn't return anything
void delete_directory(const std::string &amp;path);

// Indeterminate pointer use
struct file_stat {
  uint32_t creation_date;
  uint32_t last_modified;
  char file_name[MAX_PATH + 1];
};

// malloc returns a void * which must be cast to the type need
file_stat *s = (file_stat *) malloc(sizeof(file_stat));
// But casting is not required when going back to void *
free(s);
</code></pre>
<p>The nearest thing to <code>void</code> in Rust is the Unit type. It's called a Unit type because it's type is <code>()</code> and it has one value of <code>()</code>.</p>
<p>Technically <code>void</code> is absolutely nothing and <code>()</code> is a single value of type <code>()</code> so they're not analogous but they serve a similar purpose.</p>
<p>When a block evaluates to nothing it returns <code>()</code>. We can also use it in places where we don't care about one parameter. e.g. say we have a function <code>do_action()</code> that succeeds or fails for various reasons. We don't need any payload with the Ok response so specify <code>()</code> as the payload of success:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_action() -&gt; Result&lt;(), String&gt; {
 //...
 Result::Ok(())
}

let result = do_action();
if result.is_ok() {
 println!(&quot;Success!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="empty-enums"><a class="header" href="#empty-enums">Empty enums</a></h3>
<p>Rust <em>does</em> have something closer (but not the same as) <code>void</code> - empty enumerations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}
<span class="boring">}
</span></code></pre></pre>
<p>Essentially this enum has no values at all so anything that assigns or matches this nothing-ness is unreachable and the compiler can issue warnings or errors. If the code had used <code>()</code> the compiler might not be able to determine this.</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>A tuple is a collection of values of the same or different type passed to a function or returned by one as if it were a single value.</p>
<p>C/C++ has no concept of a tuple primitive type, however C++11 can construct a tuple using a template:</p>
<pre><code class="language-c++">std::tuple&lt;std::string, int&gt; v1 = std::make_tuple(&quot;Sally&quot;, 25);
//
std::cout &lt;&lt; &quot;Name = &quot; &lt;&lt; std::get&lt;0&gt;(v1)
          &lt;&lt; &quot;, age = &quot; &lt;&lt; std::get&lt;1&gt;(v1) &lt;&lt; std::endl;
</code></pre>
<p>Rust supports tuples as part of its language:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = (&quot;Sally&quot;, 25);
println!(&quot;Name = {}, age = {}&quot;, v1.0, v1.1);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see this is more terse and more useful. Note that the way a tuple is indexed is different from an array though, values are indexed via .0, .1 etc.</p>
<p>Tuples can also be returned by functions and assignment operators can ignore tuple members we're not interested in.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, _) = calculate_coords();
println!(&quot;x = {}, y = {}&quot;, x, y);
//...
pub fn calculate_coords() -&gt; (i16, i16, i16) {
  (11, 200, -33)
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, the calculate_coords() function returns a tuple containing three <code>i16</code> values. We assign the first two values to <code>x</code> and <code>y</code> respectively and ignore the third by passing an underscore. The underscore tells the compiler we're aware of the 3rd value but we just don't care about it.</p>
<p>Tuples can be particularly useful with code blocks. For example, let's say we want to get some values from a piece of code that uses a guard lock on a reference counted service. We can lock the service in the block and return all the values as a tuple to the recipients outside of the block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let protected_service: Arc&lt;Mutex&lt;ProtectedService&gt;&gt; = Arc::new(Mutex::new(ProtectedService::new()));
//...
let (host, port, url) = {
  // Lock and acquire access to ProtectedService
  let protected_service = protected_service.lock().unwrap();
  let host = protected_service.host();
  let port = protected_service.port();
  let url = protected_service.url();
  (host, port, url)
}

<span class="boring">}
</span></code></pre></pre>
<p>This code is really neat - the lock allows us to obtain the values, the lock goes out of scope and the values are returned in one go.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>An array is a fixed size list of elements in a contiguous memory location that can be referenced by an index. Arrays can be allocated either on the stack or the heap.</p>
<p>E.g to create a 100 element array of <code>double</code> values in C++ / C using the language features:</p>
<pre><code class="language-c++">// Stack (uninitialized)
double values[100]; // ?,?,?,?,?,...
// Stack with assignment
double values[100] = [1, 2, 3]; // 1,2,3,?,?,?,?,...
// Heap
double *values = new double[100]; // ?,?,?,?,?,...
delete []values;
// C99 initialized arrays
double values[100] = { }; // 0,0,0,0,0,...
double values[100] = {1, 2, 3}; // 1,2,3,0,0,0,0...
// C99 initialized arrays with designators
double values[100] = {1, 2, 3, [99] = 99}; // 1,2,3,0,0,0,...,0,99
// C++ doesn't need the assignment
double values[100] {1, 2, 3}; // 1,2,3,0,0,0,0...
</code></pre>
<p>As can be seen, arrays have evolved a lot to resolve issues using uninitialized data but it is also leads to a lot of variation in how they are defined. Designators can be be incredibly powerful.</p>
<p>The language also doesn't help you know what the size of an array is, so you will often see code like this:</p>
<pre><code class="language-c++">// Number of elements is the size of the entire array divided by the size of one element
int len = sizeof(values) / sizeof(values[0]);
</code></pre>
<p>But this isn't the end of it because C++ also defines <code>std::array</code> which is slightly more convenient for having <code>size()</code>, <code>empty()</code>, <code>begin()</code>, <code>end()</code> etc. making it similar to other kinds of collection:</p>
<pre><code class="language-c++">#include &lt;array&gt;
//...
std::array values {1, 2, 3};
for (int i = 0; i &lt; values.size(); i++) {
  //...
}
</code></pre>
<p>Rust has a less powerful syntax than is possible with initialized arrays in C++ but it is also less ambiguous:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stack
let values = [0f64; 100]; // 100 elements initialised to 0
let values = [1f64, 2f64, 3f64]; // 3 elements 1,2,3
// Heap
let values = Box::new([0f64; 100]);
<span class="boring">}
</span></code></pre></pre>
<p>Note how Rust provides a shorthand to initialise the array with the same value or assigns the array with every value. Initialisation in C and C++ is optional but it is more expressive in that portions of the array can be set or not set using enclosed list syntax.</p>
<p>But Rust <em>forces</em> you to initialise an array to something, ensuring the content of the array is predictable. Attempting to declare an array without assigning it a value is a compiler error.</p>
<p>In addition, a Rust array coerces to be a slice <code>&amp;[T]</code>, so methods like <code>len()</code>, <code>is_empty()</code>, <code>get()</code>, <code>swap()</code>, <code>reverse()</code> are all instantly available:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Reverse the order of values in this array in-place
let mut values = [1, 2, 3, 4];
values.reverse();
println!(&quot;Values = {:?}&quot;, values);
<span class="boring">}
</span></code></pre></pre>
<h3 id="multi-dimensional-arrays"><a class="header" href="#multi-dimensional-arrays">Multi-dimensional arrays</a></h3>
<h2 id="slices"><a class="header" href="#slices">Slices</a></h2>
<p>A slice is a runtime view of a part of an array or string. A slice is not a copy of the array / string rather that it is a reference to a portion of it. The reference holds a pointer to the starting element and the number of elements in the slice. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [&quot;Mary&quot;, &quot;Sue&quot;, &quot;Bob&quot;, &quot;Michael&quot;];
println!(&quot;{:?}&quot;, array);
let slice = &amp;array[2..];
println!(&quot;{:?}&quot;, slice);
<span class="boring">}
</span></code></pre></pre>
<p>This slice represents the portion of array starting from index 2.</p>
<pre><code>[&quot;Mary&quot;, &quot;Sue&quot;, &quot;Bob&quot;, &quot;Michael&quot;]
[&quot;Bob&quot;, &quot;Michael&quot;]
</code></pre>
<h3 id="size-of-the-array"><a class="header" href="#size-of-the-array">Size of the array</a></h3>
<p>C gives no easy way to know the length of the array unless happen to remember it from the code that declares it.
C++ allows to encapsulate the array with a <code>std::array</code> or request the size with the generic function <code>std::size</code>.</p>
<pre><code class="language-c++">// C++11
std::array&lt;Element, 100&gt; elements;
std::cout &lt;&lt; &quot;Size of std::array = &quot; &lt;&lt; elements.size() &lt;&lt; std::endl;

// C++17
Element elements[100];
std::cout &lt;&lt; &quot;Size of C array = &quot; &lt;&lt; std::size(elements) &lt;&lt; std::endl;
</code></pre>
<p>They require making functions templates instead of simple functions if one wants to pass array of unknown size: </p>
<pre><code class="language-c++">template&lt;std::size_t N&gt;
void fill_buffer(std::array&lt;Element, N&gt;&amp; arr) { ... }

template&lt;std::size_t N&gt;
void fill_buffer(Element (&amp;arr)[N]) { ... }
</code></pre>
<p>Or more recently using <code>std::span</code> if knowing the size at run-time instead of compile-time is sufficient:</p>
<pre><code class="language-c++">// C++20
void fill_buffer(std::span&lt;Element&gt; arr) { ... }

std::array&lt;Element, 100&gt; elements_std;
Element elements_c[100];

fill_buffer(elements_std);
fill_buffer(elements_c);
</code></pre>
<p>Alternatively you might see code like this:</p>
<pre><code class="language-c++">const size_t num_elements = 1024;
char buffer[num_elements];
//...
// fill_buffer needs to be told how many elements there are
fill_buffer(buffer, num_elements);
</code></pre>
<p>Or like this</p>
<pre><code class="language-c++">Element elements[100];
//...
int num_elements = sizeof(elements) / sizeof(Element);
</code></pre>
<p>In Rust, the array has a function bound to it called <code>len()</code>. This always provides the length of the array. In addition if we take a slice of the array, that also has a <code>len()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer: [u8; 1024]
println!(&quot;Buffer length = {}&quot;, buffer.len());

fill_buffer(&amp;buffer[0..10]);
//...
fn fill_buffer(elements: &amp;[Element]) {
  println!(&quot;Number of elements = {}&quot;, elements.len());
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In C/C++</p>
<ul>
<li>A string is typically a pointer to an array of <code>char</code>, <code>wchar_t</code>, <code>char16_t</code> or <code>char32_t</code> values. Historically most strings are <code>char</code> but efforts have been made to support wide character strings as well as Unicode encodings such as UTF-8.</li>
<li>A string's length is calculated by looking for a special nul (<code>'\0'</code>) value that signifies the end of the string. So a 2000 character string requires iterating through the whole string, potentially 2000 times looking for a nul. The <code>std::basic_string&lt;&gt;</code> type holds a length to negate the need to calculate the length and also to handle byte arrays that may contain nuls.</li>
<li>In C++ types derived from <code>std::basic_string&lt;&gt;</code> template are the recommended way to manage strings safely. But other 3rd party libraries also have their own string wrappers, e.g. <code>QString</code> in QT.</li>
<li>Only <code>char16_t</code> and <code>char32_t</code> types are considered to be Unicode (encoded as UTF-16, UTF-32 respectively). There is no encoding knowledge about the meaning of other kinds of string.</li>
<li>In C++17 you may create a <code>std::basic_string_view&lt;&gt;</code> which is a view onto a read-only string.</li>
</ul>
<p>In Rust</p>
<ul>
<li>A <code>char</code> is a primitive in Rust that is 32-bits and can represent any Unicode character. So it equivalent to <code>char32_t</code> in C++.</li>
<li>A <code>str</code> is a primitive that represents a read-only string. You don't declare these, rather any string in your code is implicitly a <code>str</code> and your variables bind to it via a string slice.</li>
<li>A <code>&amp;str</code> is a string slice - a reference to a <code>str</code>, consisting of a pointer and a length. </li>
<li>A <code>String</code> is a heap allocated writable buffer for strings. i.e. it can be truncated, extended etc. It implements all the functions of <code>str</code> and can also be used as a <code>&amp;str</code>.</li>
<li>All strings are internally encoded as UTF-8 but there are functions to iterate by character.</li>
</ul>
<h2 id="what-is-a-character-exactly"><a class="header" href="#what-is-a-character-exactly">What is a character exactly?</a></h2>
<p>Historically, a string has been a sequence of bytes, each representing a character. Each character is mapped to a byte (or multiple bytes) to be displayed on a screen. This is known as an encoding, i.e. the computer knows that a byte with value 65 corresponds as the letter 'A' and has a table lookup for every printable character.</p>
<p>The two predominent encodings early on were EBDIC and ASCII. Each of these assigned characters to byte values. We won't mention EBDIC since ASCII essentially won the encoding war but basically ASCII uses the first 7-bits (0-127) of the byte to assign values to upper and lower case letters in the English alphabet, numbers, punctuation marks and certain control characters. The eighth wasn't used because at the time it was used as a control bit for serial communications.</p>
<p><img src="09_features_compared/USASCII_code_chart.png" alt="ASCII Table" title="ASCII Table (wikimedia)" /></p>
<p>But what about the rest of the world? It is no use to someone writing in French if there are no letters with acute, grave or circumflex chars to use ASCII since there is no character for 'Ã€'. It would be no use at all for Japanese unless the entire language were written phonetically. For that reason the values in the 128-255 range started to be co-opted to represent other characters. </p>
<p>Languages like Chinese, Japanese, Korean, Thai, Arabic etc. have thousands of symbols so there is no way to encode them in this range. So they had to use multi-byte encodings, one character being more than one byte in length.</p>
<p>The problem here is that unless you know what language the string of bytes represents, you cannot render the character. The same sequence of bytes may mean different things depending on the encoding. So operating systems like DOS &amp; Windows gave software a clue how to handle strings - the codepage. The codepage was an environmental setting that said that on this computer, the bytes should be interpreted as.. Rusian, Latin, Japanese etc. So for example Microsoft's code page 932 use an encoding called Shift JIS (Japanese) where some symbols are two bytes.</p>
<p>The code page works for one computer, but not documents sent between multiple computers with differing code pages. The bytes in one computer mean one thing and another in the other computer. </p>
<p>Obviously this was rapidly becoming a mess. Each code page interpretted the same byte array differently according to some external setting. So you could not send a file written in Chinese to someone with a different code page and expect it to render properly.</p>
<h3 id="unicode"><a class="header" href="#unicode">Unicode</a></h3>
<p>The Unicode standard was created to solve this problem. It assigns every printable character or glyph in existence with a unique 32-bit value, called a code point. Code points are arranged into planes - blocks of 65536 code points.</p>
<p>Most characters fall in plane 0 called the Basic Multilingual Plane (BMP). These can be encoded with 2 bytes, but China has compelled software makers to support all code points since some Chinese symbols are not contained in the BMP.</p>
<h4 id="unicode-encoding"><a class="header" href="#unicode-encoding">Unicode encoding</a></h4>
<p>So Unicode represents every character in 32-bits but it would be less than inefficient to store every character in the stream as 32-bits.</p>
<p>Thus a number of encoding formats exist that attempt to losslessly represent 32-bit values in an efficient manner:</p>
<ul>
<li>UTF-8 is backwards compatible with ASCII. ASCII characters require one byte to encode, other characters may require up to 4 bytes depending on their code point.</li>
<li>UTF-16 encodes the characters in Basic Multilingual Plane in two bytes but uses four bytes for code points outside this range. </li>
<li>UTF-32 encodes every character in 4 bytes.</li>
</ul>
<p>Each encoding can be losslessly transformed to the others with helper code such as the popular <code>libicu</code> library.</p>
<p>Generally speaking UTF-8 is the most popular encoding because it is also the most efficient way to store characters most of the time. Even web pages in Japanese contain a lot of ASCII characters for the markup. So the vast majority of content is stored and served up in UTF-8. UTF-16 is not a popular encoding however the Windows operating system and also Java use it for their string encodings due to decisions made to support the BMP before China mandated full code point support.</p>
<h2 id="c--c-1"><a class="header" href="#c--c-1">C / C++</a></h2>
<h3 id="there-is-no-string-primitive"><a class="header" href="#there-is-no-string-primitive">There is no string primitive</a></h3>
<p>C and C++ does not have a string primitive type, instead it has a <code>char</code> type, that is one byte. A &quot;string&quot; is a pointer to an array of chars that are terminated with a zero byte, <code>'\0'</code>.</p>
<pre><code class="language-c++">// The array that my_string points at ends with a hidden \0
const char *my_string = &quot;This is as close to a string primitive as you can get&quot;;
printf(&quot;String is %d chars long.\n&quot;, strlen(my_string));
</code></pre>
<h4 id="string-functions"><a class="header" href="#string-functions">String functions</a></h4>
<p>In C, functions such as <code>strlen(s)</code>, <code>strcpy(dst, src)</code>, <code>strdup(s)</code> etc. allow strings to be inspected, copied or duplicated. But they work all work by essentially walking the array of bytes until they reach the <code>\0</code>. So <code>strcpy(dst, src)</code> copies from <code>src</code> to <code>dst</code> a byte at a time up to and including the <code>\0</code>. </p>
<p>But what if <code>dst</code> was not a big enough array to hold the input? Well now we have a buffer overrun which may crash the software, or cause it to be compromisd.</p>
<p>C11 introduces &quot;safe&quot; versions of functions like <code>strcpy</code> that say how large the destination is, i.e. <code>strcpy_s(dst, dstlen, src)</code>. It will not overstep the output buffer's size and if the output is not big enough to hold the input or is truncated, the function will return an error. Even so, we are required to set this size correctly, include space for the terminator byte and test for errors.</p>
<h4 id="stdbasic_string-template"><a class="header" href="#stdbasic_string-template">std::basic_string template</a></h4>
<p>C++ provides <code>std::basic_string&lt;char_type&gt;</code>. Normally <code>char_type</code> would be a <code>char</code> and there is a typedef to <code>std::string</code> which is precisely that. The <code>std::string</code> manages the lifetime of a string and provide methods for modifying the string in a safe manner. It is a vast improvement over C.</p>
<pre><code class="language-c++">#include &lt;string&gt;
//...
std::string my_string = &quot;Mary had a little lamb&quot;;
std::cout &lt;&lt; &quot;String is &quot; &lt;&lt; my_string.size() &lt;&lt; &quot; chars long.&quot; &lt;&lt; std::endl;
</code></pre>
<p>Note that this is not a primitive type. Instead <code>std::string</code> is a fairly opaque template defined in <code>&lt;string&gt;</code> that is included, compiled and linked to the executable just like every other template class. </p>
<p>In addition, a <code>std::string</code> will normally uses the heap to store the string's data which can have repercussions for memory usage and fragmentation. There is also a hidden cost to assigning one string to another strings are duplicated in the process. Operations like <code>substr()</code> create copies of the section of the string.</p>
<pre><code class="language-c++">#include &lt;string&gt;
//...
std::string str = &quot;The Evolution of Man&quot;;
std::string str2 = str.substr(4, 9);
// Str2 contains a copy of &quot;Evolution&quot;
</code></pre>
<p>In this example we use <code>substr()</code> to get a portion of the containing string, but to do so, a new string must be created. In a trivial example it doesn't matter but we might have large loops where a lot of string manipulation is occuring and it becomes inefficient. For example, if the code was consuming records delimited with a <code>|</code> where there might be 100 fields in a record, then we have a lot of allocation going on.</p>
<p>Recognizing this C++17 did this...</p>
<h4 id="stdbasic_string_view-template"><a class="header" href="#stdbasic_string_view-template">std::basic_string_view template</a></h4>
<p>C++17 supports a <code>std::basic_string_view&lt;char_type&gt;</code> template defined in <code>&lt;string_view&gt;</code>. Normally <code>char_type</code> would be a <code>char</code> and there is a typedef <code>std::string_view</code>. A string view is a read-only slice of a string.</p>
<pre><code class="language-c++">#include &lt;string_view&gt;
//...
std::string str = &quot;The Evolution of Man&quot;;
std::string_view sv { str }
std::string_view sv2 { sv.substr(4, 9) };
</code></pre>
<p>In this example, the <code>sv</code> points to <code>str</code> but it does not copy it. Basically it is just a pointer and a length onto the string. And <code>sv2</code> is a pointer and a length onto the substring portion. There is no heap or string copy happening here so it is much more efficient.</p>
<p>This allows string operations to be more efficient, however it requires the underlying string to be read only and for the view to be lifetime dependent on the string. i.e. it offers no guarantees that the view points to anything by the time it is accessed and it is the developers job to make sure it doesn't. For example, if I changed <code>str</code> in the previous example, then <code>sv</code> and <code>sv2</code> could be pointing at junk.</p>
<h3 id="string-encoding-is-whatever-you-want-it-to-be"><a class="header" href="#string-encoding-is-whatever-you-want-it-to-be">String encoding is whatever you want it to be</a></h3>
<p>C++ more or less expects you to know the encoding of your own strings. It has no inherent knowledge that an array of bytes is ASCII, EBDIC, UTF-8 or anything else. What you put in your strings is your own business and it doesn't care if the bytes are valid Unicode encodings or not. </p>
<p>However it does support Unicode if that is your intent. It has a long string notation that indicates a wide character string:</p>
<pre><code class="language-c++">wchar_t *msg = L&quot;Hello World!&quot;;
</code></pre>
<p>The <code>L</code> prefix indicates the string is in a wide format. Unfortunately <code>wchar_t</code> type can be either 2 or 4 bytes wide and is a compiler / platform specific decision. In Microsoft Visual C++ the wide char is 2 bytes and in gcc it can be 2 or 4 bytes according to the compiler flags.</p>
<p>Oops...</p>
<p>So C++11 rectifies this by introducing unambiguous <code>char16_t</code> and <code>char32_t</code> types and corresponding versions of string called <code>std::u16string</code> and <code>std::u32string</code>. It also has string prefixes for declaring encodings of strings when you combine them with <code>auto</code>:</p>
<pre><code class="language-c++">// Wide string with L prefix
wchar_t hello_chinese = L&quot;\u4f60\u597d&quot;;
// C11 and C++11 add UTF string literal prefixes
auto hello_8  = u8&quot;\u4f60\u597d&quot;; // UTF-8 encoded
auto hello_16 =  u&quot;\u4f60\u597d&quot;; // UTF-16
auto hello_32 =  U&quot;\u4f60\u597d&quot;; // UTF-32
</code></pre>
<p>Even with this you can see above that encoding Unicode in your source code isn't very nice. The Unicode characters are escaped. Some C++ compilers may allow the character set of the source file to be encoded (e.g. with UTF-8) to overcome this but it is not a certainty.</p>
<h3 id="character-types"><a class="header" href="#character-types">Character types</a></h3>
<p>So C++ has 4 character types. Great huh?</p>
<div class="table-wrapper"><table><thead><tr><th>Character type</th><th>Encoding</th></tr></thead><tbody>
<tr><td><code>char</code></td><td>C, ASCII, EBDIC, UTF-8, ad hoc, ???</td></tr>
<tr><td><code>wchar_t</code></td><td>UTF-16 or maybe UTF-32</td></tr>
<tr><td><code>char16_t</code></td><td>UTF-16</td></tr>
<tr><td><code>char32_t</code></td><td>UTF-32</td></tr>
</tbody></table>
</div>
<p>You basically cannot assume what a char string is encoded with. To preserve your sanity you are best to choose an encoding, e.g. UTF-8 and enforce it, sanitizing your inputs where you need to. If you are calling external libraries you also need to see what rules they follow for string handling. If necessary you may need to use <code>libicu</code> to properly handle strings including iterating through them since you cannot slice strings without knowing where characters lie in the buffer.</p>
<h2 id="rust-4"><a class="header" href="#rust-4">Rust</a></h2>
<p>Rust has implicit string in the language itself.</p>
<ul>
<li>A <code>char</code> type is a 32-bit Unicode character.</li>
<li>A <code>str</code> type is a UTF-8 encoded string held in memory. Code will never directly use this type. Instead it will use <code>&amp;str</code> which is a string slice, a pointer and length to the str or a portion of it. </li>
<li>A <code>std::String</code> is a heap allocated <code>str</code> that you can manipulate. Code may also obtain a <code>&amp;str</code> to a <code>String</code> but the compiler will enforce that the string is read-only while the slice exists upon it.</li>
</ul>
<p>Finally there are foreign function interface (FFI) types <code>OSString</code> and <code>OSStr</code> akin to <code>String</code> and <code>str</code> that handles any differences in how the outside world sees strings compared to Rust, e.g. changing the character width or encoding and putting a null terminator on the end. Normally you would only use these types when you need to call an external API.</p>
<h2 id="types-comparison"><a class="header" href="#types-comparison">Types Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>C/C++</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>char *</code> or <code>wchar_t *</code></td><td><code>str</code>, <code>&amp;str</code></td></tr>
<tr><td></td><td><code>OSStr</code>, <code>&amp;OSStr</code> (FFI)</td></tr>
<tr><td>C11</td><td></td></tr>
<tr><td><code>char16_t *</code>, <code>char32_t *</code></td><td><code>str</code>, <code>&amp;str</code></td></tr>
<tr><td>C++11</td><td></td></tr>
<tr><td><code>std::string</code>, <code>std::wstring</code>, <code>std::u16string</code>, <code>std::u32string</code></td><td><code>std::String</code></td></tr>
<tr><td></td><td><code>OSString</code> (FFI)</td></tr>
</tbody></table>
</div>
<h3 id="slices-1"><a class="header" href="#slices-1">Slices</a></h3>
<p>A <em>slice</em> is a reference to some or all of a <code>str</code>. It is written <code>&amp;str</code> and also contains a pointer and a byte length value. </p>
<p>We saw that C++17 introduces a <code>std::string_view</code> and it's like that, but it is an intrinsic part of the language and the compiler makes sure you cannot use the slice unsafely.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These variables are &amp;str pointing to a str consisting of UTF-8 encoded bytes
let my_str = &quot;Hello&quot;; 
let hello_chinese = &quot;ä½ å¥½&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Type inferences for these assignments will create a <code>&amp;str</code> slice pointing to the statically allocated <code>str</code> and its bytes. The data itself doesn't move and the <code>&amp;str</code> is implicitly read-only.</p>
<p>There is no need for the different prefixes in C++ for different character widths as it is implicitly Unicode. The developer may type any Unicode they like into their UTF-8 encoded source code or between string delimiters and the compiler will just take it. </p>
<p>The <code>str</code> has functions for iterating over the string in bytes / characters, for creating slices, to find a pattern etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;Hello&quot;; // v is a &amp;â€™static str
println!(&quot;My string is {} and it is {} bytes long&quot;, v, v.len());
<span class="boring">}
</span></code></pre></pre>
<p>Note <code>len()</code> is the length in bytes because strings are UTF-8 encoded. A single character may be encoded as 1, 2, 3, or 4 bytes. It may not be the number of characters a human would actually see. Characters may even be clustered together to form a graphene.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;ä½ å¥½&quot;;
println!(&quot;Number of bytes = {}&quot;, my_str.len());
println!(&quot;Number of chars = {}&quot;, my_str.chars().count());
<span class="boring">}
</span></code></pre></pre>
<pre><code>Number of bytes = 6
Number of chars = 2
</code></pre>
<p>You can split a <code>&amp;str</code> to produce a left and a right <code>&amp;str</code> slice like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (part1, part2) = &quot;Hello&quot;.split_at(3);
println!(&quot;Part 1 = {}&quot;, part1);
println!(&quot;Part 2 = {}&quot;, part2);
<span class="boring">}
</span></code></pre></pre>
<pre><code>Part 1 = Hel
Part 2 = lo
</code></pre>
<h3 id="raw-strings"><a class="header" href="#raw-strings">Raw strings</a></h3>
<p>A raw string is a convenience for strings that contain backslashes, quotes etc. that you don't want to have to escape out.</p>
<p>It is a Unicode string starting with <code>r&quot;</code> prefix. If your string contains a double quotation mark you can also put one or more hashes around the outer quotes, <code>r#&quot;A quote is this symbol &quot;&quot;#;</code>. You could even put more hashes if your string contained <code>#&quot;</code>, e.g. <code>r##&quot;</code>, <code>&quot;##</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let quote = r#&quot;And the man said &quot;the best is yet to come&quot;&quot;#;
let multiline = r&quot;All good things
to those who wait&quot;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="byte-strings"><a class="header" href="#byte-strings">Byte strings</a></h3>
<p>A byte string is just an unchecked byte array that is not assumed to be any kind of encoding:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
let b = b&quot;SUCCESS\x0f&quot;;
}
</code></pre></pre>
<p>In this case, <code>b</code> is a reference to a static byte array <code>&amp;'static [u8]</code>. There is no <code>str</code>. This may be useful for reading data from a stream where there is no assumption about its encoding.</p>
<h1 id="unicode-1"><a class="header" href="#unicode-1">Unicode</a></h1>
<p>As state already strings are Unicode. It is worth remember that internally the string is UTF-8 encoded. What that means is you have to be a little careful conflating length with number of characters. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = &quot;ä½ å¥½&quot;;
    println!(&quot;Length of string = {}&quot;, s.len());
    s.chars().for_each(|c| {
      println!(&quot;Char = {}&quot;, c);
    })
}
</code></pre></pre>
<p>And the output would be:</p>
<pre><code>Length of string = 6
Char = ä½ 
Char = å¥½
</code></pre>
<p>Notice that the <em>length</em> of the string is 6 bytes, but there are only two characters. It takes 6 bytes to UTF-8 encode the string and that is what is referring to. Functions that manipulate strings will be indexed by byte too and will error if you are incorrect. Therefore, you are better to use <code>chars()</code> for character wise operation.</p>
<p>So a <code>char</code> in Rust is a Unicode character, 32-bits. This may seem weird at first but remember that Rust has explicit <code>i8</code> and <code>u8</code> types if you really want to deal in bytes. But strings in Rust are not bytes, they're characters.</p>
<p>It gets more complex than &quot;character&quot; though because some languages have clusters of characters that are known as graphene clusters, which are akin to letters. So a character may be an adornment for another character, not necessarily printable. Therefore even with Unicode baked in you may find your code has to have special knowledge of what it is doing to make sense for what the user sess.</p>
<p>In addition, to manipulate strings, then there is a type for that purpose, <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;ä½ å¥½&quot;);
    s.push_str(&quot;ä¸–ç•Œ&quot;);
    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<h2 id="stdbasic_string-c-vs-stdstring-rust"><a class="header" href="#stdbasic_string-c-vs-stdstring-rust">std::basic_string (C++) vs std::String (Rust)</a></h2>
<p>The standard C++ library also has template class <code>std::basic_string</code> that acts as a wrapper around the various character types and can be used for manipulating a string of any width. This template is specialised as<br />
<code>std::string</code>, <code>std:wstring</code>, <code>std::u16string</code> and <code>std::u32string</code>.</p>
<pre><code class="language-c++">std::string my_str = &quot;Hello&quot;;
my_str += &quot; world&quot;;

// C++11 also allows some type inference with autos
auto s1 =   &quot;Hello&quot;s; // std::string
auto s2 = u8&quot;Hello&quot;s; // std::string, forces UTF-8 encoding
auto s3 = L&quot;Hello&quot;s;  // std::wstring
auto s4 = u&quot;Hello&quot;s;  // std::u16string
auto s5 = U&quot;Hello&quot;s;  // std::u32string
</code></pre>
<p>In Rust, the <code>std::String</code> type serves the same purpose:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = String::from(&quot;Hello&quot;);
v.push_str(&quot; world&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Using it is fairly simple</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = String::from(&quot;This is a String&quot;);
v.push_str(&quot; that we can modify&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>A <code>String</code> has functions to do actions such as appending, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = String::from(&quot; Bananas&quot;);
let mut result = String::new();
result.push_str(&quot;Apples &quot;);
result.push('&amp;'); // Push a char
result.push_str(b.as_str());
println!(&quot;result = {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<p>Strings are always valid UTF-8.</p>
<p>Internally a String has a pointer to the data, its length and a capacity (max size). If you intend to expand a string, then you should ensure the <code>String</code> has sufficient capacity to accommodate its longest value otherwise you may cause it to reallocate itself excessively.</p>
<p>Strings will never shrink their capacity unless you explicitly call <code>shrink_to_fit()</code>. This means if you use a temporary string in a loop, it's probably best to place it outside the loop and reserve space to make it efficient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = String::with_capacity(100);
// or
let mut v = String::new();
v.reserve_exact(100);
<span class="boring">}
</span></code></pre></pre>
<p>Strings also have all the methods of str thanks to implementing <code>Deref</code> trait.</p>
<h3 id="formatting-strings"><a class="header" href="#formatting-strings">Formatting strings</a></h3>
<p>Strings can be formatted in C with <code>printf</code> or <code>sprintf</code> or in C++ composed with stream operators, e.g. to a <code>std::stringstream</code>.</p>
<p>Rust uses <code>format!</code> and <code>println!</code> macros that more resemble the <code>sprintf</code> model. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">C++</th><th style="text-align: left">Rust formatting trait</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>%s</code>, <code>%u</code>, <code>%d</code>, <code>%i</code>, <code>%f</code>, <code>%c</code></td><td style="text-align: left"><code>{}</code></td><td style="text-align: left">C/C++ require the type of the parameter to be specified. In Rust the type is inferred and <code>{}</code> will invoked the type's Display trait regardless of what it is. So a String outputs its text, numeric types return their value, boolean as returns true or false, and so on.</td></tr>
<tr><td style="text-align: left"><code>%lld</code>, <code>%llu</code></td><td style="text-align: left"><code>{}</code></td><td style="text-align: left">C/C++ has extensions to deal with different size ints and floats, e.g. ll for long long due to the way arguments are passed to the function. In Rust, there is no need for that.</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>{:?}</code>, <code>{:#?}</code></td><td style="text-align: left">In Rust <code>{:?}</code> returns whatever is implemented by a type's Debug trait. The <code>{:#?}</code> variant can be used to pretty-print the output for types that derive the Debug trait.</td></tr>
<tr><td style="text-align: left"><code>%-10s</code></td><td style="text-align: left"><code>{:&lt;10}</code></td><td style="text-align: left">Format left aligned string padded to minimum of 10 spaces</td></tr>
<tr><td style="text-align: left"><code>%04</code></td><td style="text-align: left"><code>{:04}</code></td><td style="text-align: left">Pad a number with zero's to a width of 4</td></tr>
<tr><td style="text-align: left"><code>%.3</code></td><td style="text-align: left"><code>{:.3}</code></td><td style="text-align: left">Pad a number's precision to 3 decimal places. May also be zero-padded, e.g. {:.03}</td></tr>
<tr><td style="text-align: left"><code>%e</code>, <code>%E</code></td><td style="text-align: left"><code>{:e}</code>, <code>{:E}</code></td><td style="text-align: left">Exponent in lower or uppercase</td></tr>
<tr><td style="text-align: left"><code>%x</code>, <code>%X</code></td><td style="text-align: left"><code>{:x}</code>, <code>{:X}</code></td><td style="text-align: left">Hexadecimal in lower or uppercase. Note <code>{:#x}</code>, <code>{:#X}</code> prefixes the output with 0x</td></tr>
<tr><td style="text-align: left"><code>%o</code></td><td style="text-align: left"><code>{:o}</code></td><td style="text-align: left">Octal. Note <code>{:#o}</code> prefixes the output with 0o</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>{:b}</code></td><td style="text-align: left">Binary. Note <code>{:#b}</code> prefixes the output with 0b</td></tr>
<tr><td style="text-align: left"><code>%p</code></td><td style="text-align: left"><code>{:p}</code></td><td style="text-align: left">Presents a struct's memory location, i.e. pointer</td></tr>
</tbody></table>
</div>
<p>Rust has many <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">more formatting traits</a> than this.</p>
<p>For example it allows named parameters like this example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = format!(&quot;The temperature {temp}C is within {percent} of maximum&quot;, temp = 104, percent = 99);
<span class="boring">}
</span></code></pre></pre>
<p>Named parameters would be particularly useful for localization where the order of values may be different in one language compared to another.</p>
<h2 id="display-and-debug-traits"><a class="header" href="#display-and-debug-traits">Display and Debug traits</a></h2>
<p>Rust allows types to be formatted as strings based upon the formatting traits they implement.</p>
<p>The two main implementation traits are:</p>
<ul>
<li><code>Display</code> - this is for standard textual representation of a type.</li>
<li><code>Debug</code> - this is for the debugging textual representation of a type. It might present additional information or be formatted separately to the Display trait. It is possible to <code>#[derive(Debug)]</code> this trait which is usually enough for the purpose of debugging.</li>
</ul>
<p>If we look at the traits we can see they're identical</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// std::fmt::Display
pub trait Display {
    fn fmt(&amp;self, &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}
// std::fmt::Debug
pub trait Debug {
    fn fmt(&amp;self, &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>All of the intrinsic types implement <code>Display</code> and <code>Debug</code>. We can explicitly implement Display on our own structs too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::{self, Formatter, Display};

struct Person {
  first_name: String,
  last_name: String,
}

impl Display for Person {
  fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
    write!(f, &quot;{} {}&quot;, self.first_name, self.last_name)
  }
}
//...
let person = Person { first_name: &quot;Susan&quot;.to_string(), last_name: &quot;Smith&quot;.to_string() };
println!(&quot;Person - {}&quot;, person);
<span class="boring">}
</span></code></pre></pre>
<pre><code>Person - Susan Smith
</code></pre>
<p>Implementing <code>Debug</code> is usually done by <code>#[derive(Debug)]</code> but it could also be implemented. The derived <code>Debug</code> will print out the struct name, and then the members in curly braces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Person {
  //...
}
//...
println!(&quot;Person - {:?}&quot;, person);
<span class="boring">}
</span></code></pre></pre>
<pre><code>Person - Person { first_name: &quot;Susan&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>Many types process formatting traits which are values held between the <code>{}</code> braces in the string. These are fairly similar to the patterns used in C functions for printf, sprintf etc.</p>
<h2 id="osstring--osstr"><a class="header" href="#osstring--osstr">OsString / OsStr</a></h2>
<p>Rust recognises there are times when you need to pass or receive a string from a system API.</p>
<p>In this case you may use <code>OsString</code> which allows interchange between Rust and a system dependent representations of strings. On Windows it will return UTF-16 strings, on Linux / Unix systems it will return UTF-8.</p>
<p>An <code>OsStr</code> is a slice onto <code>OsString</code>, analogous to <code>str</code> and <code>String</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h2 id="c-2"><a class="header" href="#c-2">C++</a></h2>
<h3 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h3>
<p>C++11 implements type inference, previous versions of C++ do not. Type inference allows the programmer to assign a value to an <code>auto</code> typed variable and let the compiler infer the type based on the assignment. The
<code>auto</code> keyword is a convenience because it allows the compiler to figure out the type in a great deal of cases.</p>
<p>Boolean and numeric types are fairly easy to understand providing the code is as explicit as it needs to be.</p>
<pre><code class="language-c++">auto x = true; // bool
auto y = 42;   // int
auto z = 100.; // double
</code></pre>
<p>Where C++ gets messy is for references, arrays and strings. Recall that strings are not primitive types in the strong sense within C or C++ so auto requires they be explicitly defined or the type will be wrong.</p>
<pre><code class="language-c++">// C++11
auto s = std::string(&quot;Now is the window of our discontent&quot;); // char string
// C++17 
auto s = &quot;Now is the window of our discontent&quot;s; // Notation to use a std::string
// Unicode 32-bit
auto s = U&quot;Battle of Waterloo&quot;; // char32_t pointer to UTF-32 string literal
</code></pre>
<p>Strings are covered elsewhere, but essentially there are many kinds of strings and C++/C has grown a whole bunch of string prefixes and suffixes to deal with them all.</p>
<p>Arrays are a more interesting problem. The <code>auto</code> keyword has no easy way to infer array type so is one hack workaround to assign a templatized array to an <code>auto</code> and coerce it.</p>
<pre><code class="language-c++">template &lt;typename T, int N&gt; using raw_array = T[N];
auto a = raw_array&lt;int, 5&gt;{};
</code></pre>
<p>References are also a hidden danger. If you intend to assign a reference to an auto, you must ensure the auto is a reference too, otherwise you may inadvertantly make a copy of the thing
you are assigning.</p>
<pre><code class="language-c++">std::vector&lt;int&gt; &amp; dataPoints();

//...
auto points = dataPoints(); // Makes a copy
auto &amp;points = dataPoints(); // References the original
</code></pre>
<h2 id="rust-5"><a class="header" href="#rust-5">Rust</a></h2>
<p>Rust, variables are bound with a <code>let</code> command. Binding is basically assignment, but with the added proviso that a variable can be unbound if its
value is moved somewhere else. Using an unbound variable results in a compiler error.</p>
<p>The <code>let</code> may specify the variable's type, or it may also use type inference to infer it from the value it is assigned with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true; // x: bool
let y = 42; // y: i32
let z = 100.0; // z: f64
let v = vec![10, 20, 30]; // v: Vec&lt;i32&gt;
let s = &quot;Now is the winter of our discontent&quot;.to_string(); // s: String
let s2 = &quot;Battle of Waterloo&quot;; // s2: &amp;str
let a1: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Rust has no problem with using type inference in array assignments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a2 = [&quot;Mary&quot;, &quot;Fred&quot;, &quot;Sue&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Note that all array elements must be the same type, inference would generate a compiler error for an array like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile error
let a3 = [&quot;Mary&quot;, 32, true];
<span class="boring">}
</span></code></pre></pre>
<p>References in Rust are more obvious than in C++ - if you assign a reference to another variable, then the type is inferred to be a reference too.</p>
<pre><code>let x = 10;   // i32
let rx = &amp;x;  // &amp;i32
let rx2 = rx; // &amp;i32
</code></pre>
<h2 id="scope-rules"><a class="header" href="#scope-rules">Scope rules</a></h2>
<p>Scope rules in C, C++ and Rust are fairly similar - the scope that you declare the item determines its lifetime.</p>
<h3 id="shadowing-variables"><a class="header" href="#shadowing-variables">Shadowing variables</a></h3>
<p>One very useful feature of Rust is that you can declare the same named variable more than once in the same scope or nested scopes and the compiler doesn't mind. In fact you'll use this feature a lot. </p>
<p>This is called <em>shadowing</em> and works like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = do_something();
println!(&quot;Got result {:?}&quot;, result);
if let Some(result) = result {
  println!(&quot;We got a result from do_something&quot;);
}
else {
  println!(&quot;We didn't get a result from do_something&quot;);
}

let result = do_something_else();
//...
<span class="boring">}
</span></code></pre></pre>
<p>This example uses the variable name <code>result</code> 3 times. First to store the result of calling <code>do_something()</code>, then to extract some value <code>Foo</code> from  <code>Option&lt;Foo&gt;</code> and a third time for calling something else. We could have assigned <code>result</code> to <code>result2</code> and then later on assigned the value <code>do_something_else()</code> to <code>result3</code> but we didn't need to because of shadowing. </p>
<h2 id="pointers"><a class="header" href="#pointers">Pointers</a></h2>
<h3 id="in-c"><a class="header" href="#in-c">In C++</a></h3>
<p>A pointer is a variable that points to an address somewhere in memory. The pointer's <em>type</em> indicates to the compiler what to expect at the address but there is no enforcement to ensure that the address actually holds that type. A pointer might might be assigned <code>NULL</code> (or <code>nullptr</code> in C++11) or may even be garbage if nothing was assigned to it.</p>
<pre><code class="language-c++">char *name = &quot;David Jones&quot;;

int position = -1;
find_last_index(&quot;find the letter l&quot;, 'l', &amp;position);
</code></pre>
<p>Generally pointers are used in situations where references cannot be used, e.g. functions returning allocated memory or parent / child collection relationships where circular dependencies would prevent the use of references.</p>
<p>C++11 deprecates <code>NULL</code> in favour of new keyword <code>nullptr</code> to solve a problem with function overloading.</p>
<pre><code class="language-c++">void read(Data *data);
void read(int value);
// Which function are we calling here?
read(NULL);
</code></pre>
<p>Since <code>NULL</code> is essentially <code>#define NULL 0</code> and 0 is an integer, we call the wrong function by accident. So C++ introduces an explicit <code>nullptr</code> for this purpose.</p>
<pre><code class="language-c++">read(nullptr);
</code></pre>
<h3 id="in-rust"><a class="header" href="#in-rust">In Rust:</a></h3>
<p>Rust supports pointers, normally called <em>raw</em> pointers however you will rarely use them unless you need to interact with C API or similar purposes.</p>
<p>A pointer looks fairly similar to that of C++:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a reference coerced to a const pointer
let age: u16 = 27;
let age_ptr: *const u16 = &amp;age;

// This is a mut reference coerced to a mutable pointer
let mut total: u32 = 0;
let total_ptr: *mut u32 = &amp;mut total;
<span class="boring">}
</span></code></pre></pre>
<p>Although you can make a pointer outside of an unsafe block, many of the functions you might want to perform on pointers are unsafe by definition and must be inside <code>unsafe</code> blocks.</p>
<p>The documentation in full is <a href="https://doc.rust-lang.org/std/primitive.pointer.html">here</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<h3 id="in-c-1"><a class="header" href="#in-c-1">In C++</a></h3>
<p>A reference is also a variable that points to an address but unlike a pointer, it cannot be reassigned and it cannot be <code>NULL</code>. Therefore a reference is generally assumed to be safer than a pointer. It is still possible for the a reference to become dangling, assuming the address it referenced is no longer valid.</p>
<h3 id="in-rust-1"><a class="header" href="#in-rust-1">In Rust</a></h3>
<p>A reference is also lifetime tracked by the compiler.</p>
<h2 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h2>
<p>A tuple is list of values held in parenthesis. They're useful in cases where transient or ad-hoc data is being passed around and you cannot be bothered to write a special struct just for that case. </p>
<h3 id="in-c-2"><a class="header" href="#in-c-2">In C++</a></h3>
<p>C++ does not natively support tuples, but C++11 provides a template for passing them around like so:</p>
<pre><code class="language-c++">#include &lt;tuple&gt;

std::tuple&lt;int, int&gt; get_last_mouse_click() {
  return std::make_tuple(100, 20);
}

std::tuple&lt;int, int&gt; xy = get_last_mouse_click();
int x = std::get&lt;0&gt;(xy);
int y = std::get&lt;1&gt;(xy);
</code></pre>
<h3 id="in-rust-2"><a class="header" href="#in-rust-2">In Rust</a></h3>
<p>Tuples are part of the language and therefore they're far more terse and easy to work with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_last_mouse_click() -&gt; (i32, i32) {
  (100, 20)
}
// Either
let (x, y) = get_last_mouse_click();
println!(&quot;x = {}, y  = {}&quot;, x, y);
// or
let xy = get_last_mouse_click();
println!(&quot;x = {}, y  = {}&quot;, xy.0, xy.1);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals"><a class="header" href="#literals">Literals</a></h1>
<h2 id="c-3"><a class="header" href="#c-3">C++</a></h2>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Integer numbers are a decimal value followed by an optional type suffix.</p>
<p>In C++ an <a href="http://en.cppreference.com/w/cpp/language/integer_literal#The_type_of_the_literal">integer literal</a> can be expressed as just the number or also with a suffix. Values in hexadecimal, octal and binary are denoted with a prefix:</p>
<pre><code class="language-c++">// Integers
42
999U
43424234UL
-3456676L
329478923874927ULL
-80968098606968LL
// C++14
329'478'923'874'927ULL
// Hex, octal, binary
0xfffe8899bcde3728 // or 0X
07583752256
0b111111110010000 // or 0B
</code></pre>
<p>The <code>u</code>, <code>l</code>, and <code>ll</code> suffixes on integers denotes if it is <code>unsigned</code>, <code>long</code> or a <code>long long</code> type. The <code>u</code> and <code>l</code>/<code>ll</code> can be upper or lowercase. Ordinarily the <code>u</code> must precede the size but C++14 allows the reverse order, i.e. <code>ull</code> or <code>llu</code>.</p>
<p>C++14 also allows single quotes to be inserted into the number as separators - these quotes can appear anywhere and are ignored.</p>
<h3 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating point numbers</a></h3>
<p>Floating point numbers may represent whole or fractional numbers.</p>
<p>C++ offers <code>float</code> and <code>double</code> types that typically map onto the corresponding 32-bit or 64-bit IEEE-754 floating point number. All the C and C++ specifications say is that <code>float</code> must be less than or the same number of bytes as a <code>double</code></p>
<p>By default floating point numbers are <code>double</code> unless they have a <code>f</code> suffix.</p>
<pre><code class="language-c++">100.0
0.134
2.3f
12e+99
</code></pre>
<p>Compilers can also support a <code>long double</code> type which may be 64-bit (same as <code>double</code>) but may be higher such as a 80-bits (padded to 12-bytes). This is architecture dependent - x86 processors support an extended precision format with 80-bits whereas other architectures may not.</p>
<h3 id="boolean-values"><a class="header" href="#boolean-values">Boolean values</a></h3>
<p>C/C++ <code>bool</code> literals are <code>true</code> or <code>false</code>. The language supports
integral promotion where <code>true</code> can evaluate 1 and <code>false</code> to 0.</p>
<h3 id="characters-and-strings"><a class="header" href="#characters-and-strings">Characters and Strings</a></h3>
<p>A character literal is enclosed by single quotes and an optional width prefix. The prefix <code>L</code> indicates a wide character, <code>u</code> for UTF-16 and <code>U</code> for UTF-32.</p>
<pre><code class="language-c++">'a'
L'a' // wchar_t
u'\u20AC' // char16_t
U'\U0001D11E' // char32_t
</code></pre>
<p>One oddity of a <code>char</code> literal is that <code>sizeof('a')</code> yields <code>sizeof(int)</code> in C but <code>sizeof(char)</code> in C++. It isn't a good idea to test the size of a character literal.</p>
<p>A <code>char16_t</code> and <code>char32_t</code> are sufficient to hold any UTF-16 and UTF-32 code unit respectively.</p>
<p>A string is a sequence of characters enclosed by double quotes. A zero value terminator is always appended to the end. Prefixes work the same as for character literals with an additional <code>u8</code> type to indicate a UTF-8 encoded string.</p>
<pre><code class="language-c++">&quot;Hello&quot;
u8&quot;Hello&quot; // char with UTF-8
L&quot;Hello&quot;   // wchar_t
u&quot;Hello&quot;   // char16_t with UTF-16
U&quot;Hello&quot;   // char32_t with UTF-32
</code></pre>
<h3 id="user-defined-literals"><a class="header" href="#user-defined-literals">User-defined literals</a></h3>
<p>C++11 introduced <a href="http://en.cppreference.com/w/cpp/language/user_literal">user-defined literals</a>. These allow integer, floats, chars and strings to have a user defined type suffix consisting of an underscore and a lowercase string. The prefix may act as a form of decorator or even a constant expression operator which modifies the value at compile time.</p>
<p>C++14 goes further and defines user-defined literals for complex numbers and units of time.</p>
<p>See the link for more information.</p>
<h2 id="rust-6"><a class="header" href="#rust-6">Rust</a></h2>
<h2 id="integers-1"><a class="header" href="#integers-1">Integers</a></h2>
<p>In Rust <a href="https://doc.rust-lang.org/reference.html#integer-literals">number literals</a> can also be expressed as just the number or also with a suffix. The suffix denotes the signage and bit size of the value, e.g. <code>u8</code> is an unsigned 8-bit value, whereas a <code>i64</code> is a signed 64-bit value.</p>
<p>There are two special sizes called <code>usize</code> (unsigned) and <code>isize</code> signed which are not a fixed size. These values are designed for indexing and memory addressing and therefore their size is architecture dependent. On a 32-bit architecture, the <code>usize</code>/<code>isize</code> types are 32-bits, on a 64-bit architecture they are 64-bits. In Rust you will find that every collection class uses the <code>usize</code> and <code>isize</code> for every index addressable operation.</p>
<p>Values in hexadecimal, octal and binary are also denoted with a prefix:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Integers
123i32
123u32
123_444_474u32
0usize
// Hex, octal, binary
0xff_u8
0o70_i16
0b111_111_11001_0000_i32
<span class="boring">}
</span></code></pre></pre>
<p>The underscore in Rust is a separator and functions the same way as the single quote in C++14.</p>
<h3 id="floating-point-numbers-1"><a class="header" href="#floating-point-numbers-1">Floating point numbers</a></h3>
<p>Floating point numbers may represent whole or fractional numbers. As with integers they may be suffixed to indicate their type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>100.0f64
0.134f64
2.3f32 // But 2.f32 is not valid (note 1)
12E+99_E64
<span class="boring">}
</span></code></pre></pre>
<p>One quirk with floating point numbers is the decimal point is used for float assignments but it's also used for member and function invocation. So you can't say <code>2.f32</code> since it thinks you are referencing f32 on 2. Instead syntax requires you to say <code>2.0f32</code> or alter how you declare the type, e.g. <code>let v: f32 = 2.;</code>.</p>
<p>Rust does not presently support 80-bit format floats.</p>
<h2 id="booleans-1"><a class="header" href="#booleans-1">Booleans</a></h2>
<p>Boolean literals are simply <code>true</code> or <code>false</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>true
false
<span class="boring">}
</span></code></pre></pre>
<p>There is no integral promotion in Rust so you cannot just pass an expression such as <code>1</code> to a function that takes a boolean (or <code>false</code> to a function that takes an integer).</p>
<h2 id="characters-and-strings-1"><a class="header" href="#characters-and-strings-1">Characters and Strings</a></h2>
<p>A character in Rust is any UTF-32 code point enclosed by single quotes. This value may be escaped or not since .rs files are UTF-8 encoded. </p>
<p>A special prefix <code>b</code> may be used to denote a byte string, i.e. a string where each character is a single byte.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'x'
'\'' # Escaped single quote
b'&amp;' # byte character is a u8
<span class="boring">}
</span></code></pre></pre>
<p>Strings are the string text enclosed by double quotes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;This is a string&quot;
b&quot;This is a byte string&quot;
<span class="boring">}
</span></code></pre></pre>
<p>The prefix <code>b</code> denotes a byte string, i.e. single byte characters. Rust allows newlines, space, double quotes and backslashes to be escaped using backslash notation similar to C++.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&quot;This is a \
  multiline string&quot;
&quot;This string has a newline\nand an escaped \\ backslash&quot;
&quot;This string has a hex char \x52&quot;
<span class="boring">}
</span></code></pre></pre>
<p>Strings can also be 'raw' to avoid escaping. In this case, the string is prefixed r followed by zero or more hash marks, the string in double quotes and the same number of hash marks to close. Byte strings are uninterpretted byte values in a string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>r##&quot;This is a raw string that can contain \n, \ and other stuff without escaping&quot;##
br##&quot;A raw byte string with &quot;stuff&quot; like \n \, \u and other things&quot;##
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>A collection is something that holds zero or more elements in some fashion that allows you 
enumerate those elements, add or remove elements, find them and so forth.</p>
<ul>
<li>
<p>Vector - a dynamic array. Appending or removing elements from the end is cheap (providing the array is large enough to accomodate an additional item). Inserting items or removing them from any other part of the array is more expensive and involves memory movements. Generally speaking you should always reserve enough space in a vector for the most elements you anticipate it will hold. Reallocating memory can be expensive and lead to fragmentation.</p>
</li>
<li>
<p>Vecdeque - a ring buffer array. Items can be added or removed from either end relatively cheaply. Items in the array are not arranged sequentially so there is a little more complexity to managing wraparound and removal than a Vector.</p>
</li>
<li>
<p>LinkedList - a linked list individually allocates memory for each element making it cheap to add or remove elements from anywhere in the list. However there is a lot more overhead to iterating the list by index and much more heap allocation.</p>
</li>
<li>
<p>Set - a collection that holds a unique set of items. Inserting a duplicate item will not succeed. Some sets maintain the order of insertion. Sets are useful where you want to weed out duplicates from an input.</p>
</li>
<li>
<p>Map - a collection where each item is referenced by a unique key. Some maps can maintain the order of insertion.</p>
</li>
</ul>
<p>C++ and Rust have have collections as part of their standard library as is common with modern languages.</p>
<div class="table-wrapper"><table><thead><tr><th>C</th><th>C++</th><th>Rust</th></tr></thead><tbody>
<tr><td>-</td><td><code>std::vector</code></td><td><code>std::vec::Vec</code> or <code>std::collections::VecDeque</code></td></tr>
<tr><td>-</td><td><code>std::list</code></td><td><code>std::collections::LinkedList</code></td></tr>
<tr><td>-</td><td><code>std::set</code></td><td><code>std::collections::HashSet</code>, <code>std::collections::BTreeSet</code></td></tr>
<tr><td>-</td><td><code>std::map</code></td><td><code>std::collections::HashMap</code>, <code>std::collections::BTreeMap</code></td></tr>
</tbody></table>
</div>
<p>C has no standard collection classes or types. Some libraries offer collection APIs such as <a href="https://developer.gnome.org/glib/">glib</a> or <a href="https://github.com/drh/cii">cii</a>.</p>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>Iterators are a reference to a position in a collection with the means to step through the collection one element at a time.</p>
<h3 id="c-4"><a class="header" href="#c-4">C++</a></h3>
<p>C++11 provides a shorthand way of iterating a collection:</p>
<pre><code class="language-c++">std::vector&lt;char&gt; values;
for (const char &amp;c : values) {
    // do something to process the value in c
}
</code></pre>
<p>Iterators are more explicit in C++98 and before and the code in C++11 is basically equivalent to this:</p>
<pre><code class="language-c++">std::vector&lt;char&gt; values;

for (std::vector&lt;char&gt;::const_iterator i = values.begin(); i != values.end(); ++i) {
    const char &amp;c = *i;
    // do something to process the value in c
}
</code></pre>
<p>This is quite verbose, but essentially each collection type defines a mutable <code>iterator</code> and immutable <code>const_iterator</code> type and calling <code>begin</code> returns an iterator to the beginning of the collection. Calling the <code>++</code> operator overload on the iterator causes it to advance to the next element in the collection. When it hits the exclusive value returned by <code>end</code> it has reached the end of the collection.</p>
<p>Obviously with an indexed type such as a <code>vector</code> you could also reference elements by index, but it is far more efficient to use iterators for other collection types.</p>
<h4 id="processing-collections"><a class="header" href="#processing-collections">Processing collections</a></h4>
<p>C++ provides a number of utility templates in <algorithm> for modifying sequences in collections on the fly. </p>
<h3 id="rust-7"><a class="header" href="#rust-7">Rust</a></h3>
<p>Rust also has iterators which are superficially similar fashion to C++ - incrementing their way through collections. </p>
<p>However the iterator concept is taken a LOT further in Rust. Iterators can be chained together in Rust to produce some powful and terse operations.</p>
<p>A conventional loop might look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
for v in &amp;values {
    println!(&quot;Value = {}&quot;, v);
}
<span class="boring">}
</span></code></pre></pre>
<p>In this instance, the iterator is invisible. The value <code>v</code> is a reference to the <code>i32</code> of the currently iterated element so each iteration prints a different value.</p>
<p>However we can also be explicit and obtain the iterator if we desire and apply an action to each value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
values.iter().for_each(|v| println!(&quot;Value = {}&quot;, v);
<span class="boring">}
</span></code></pre></pre>
<p>In this example the code calls <code>for_each</code> on the <code>Iterator</code> which iterates over each element and calls the closure.</p>
<p>We can go further. Let's say we want to only print the first 5 results:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
values.iter().take(5).for_each(|v| println!(&quot;Value = {}&quot;, v));
<span class="boring">}
</span></code></pre></pre>
<p>Now the code calls <code>take</code> on the <code>Iterator</code> which produces a <code>Take&lt;Iterator&gt;</code> which iterates only 5 times before it ends.</p>
<p>Perhaps we want to produce a tuple, consisting of the index of the iterator and <code>f64</code> result of dividing the number by 5.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
let result = values.
    iter().
    enumerate().
    map(|v| (v.0, *v.1 as f64 / 5.0) ).
    collect::&lt;Vec&lt;(usize, f64)&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Breaking this down, we iterate, <code>enumerate()</code> produces a tuple <code>(usize, &amp;i32)</code> from the index and value, <code>map()</code> creates a new tuple <code>(usize, f64)</code> and then finally the result is gathered into a new collection. </p>
<p>As you can see iterators expose very powerful functions that are an efficient, terse and provide less chance for error than writing a loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<h2 id="c-5"><a class="header" href="#c-5">C++</a></h2>
<p>A <code>class</code> and a <code>struct</code> in C++ are largely the same thing from an implementation standpoint. They both hold fields and they both can have methods attached to the class (<code>static</code>) or instance level. </p>
<pre><code class="language-c++">class Foo {
public:
   // Methods and members here are publicly visible
   double calculateResult();
protected:
   // Elements here are only visible to ourselves and subclasses
   virtual double doOperation(double lhs, double rhs);
private:
   // Elements here are only visible to ourselves
   bool debug_;
};
</code></pre>
<p>The default access level is <code>public</code> for struct and <code>private</code> for class. Some rules about templates only apply to classes.</p>
<p>From a psychological perspect a <code>struct</code> tends to be used to hold public data that is largely static and/or passed around. A <code>class</code> tends to be something more self contained with methods that are called to access or manage private fields.</p>
<p>So these are equivalents:</p>
<pre><code class="language-c++">struct Foo { // as a struct
private:
};

class Foo { // As a class
};

// Or the other way around

struct Bar {
};

class Bar {
public:
};
</code></pre>
<p>Classes can also use an access specifier to inherit from a base class. So a class may specify <code>public</code>, <code>protected</code> or <code>private</code> when deriving from another class depending on whether it wants those methods to be visible to callers, or subclasses.</p>
<p>Classes and structs may have special constructor and destructor methods which are described in sections below.</p>
<pre><code class="language-c++">class Size {
public:
  Size(int width, int height);

  int width_;
  int height_;

  int area() const;
};
</code></pre>
<p>Then in the .cpp file you might implement the constructor and method:</p>
<pre><code class="language-C++">Size::Size(int width, int height) : width_(width), height_(height) {}

int Size::area() { return width_ * height_; }
</code></pre>
<h2 id="rust-8"><a class="header" href="#rust-8">Rust</a></h2>
<p>Rust only has structs. A <code>struct</code> consists of a definition which specifies the fields and their access level (public or not), and an <code>impl</code> section which contains the implementation of functions bound to the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Size {
  pub width: i32,
  pub height: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>An <code>impl</code> section follows containing the associated functions (<code>new</code>) and methods (<code>area</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Size {
  pub fn new(width: i32, height: i32) -&gt; Size {
    Size { width: width, height: height, }
  }

  pub fn area(&amp;self) -&gt; i32 {
    self.width * self.height
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>new()</code> function here is an associated function that returns a struct preinitialised with the arguments supplied. The <code>area()</code> method specifies a <code>&amp;self</code> argument and returns an area calculation. Any method (with <code>&amp;self</code>, or <code>&amp;mut self</code> as the first argument)  can be called from the variable bound to the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let size = Size::new(10, 20);
println!(&quot;Size = {}&quot;, size.area());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>self</code> keyword works in much the same way as C++ uses <code>this</code>, as a reference to the struct from which the function was invoked. If a function modifies the struct it must say <code>&amp;mut self</code>, which indicates the function modifies the struct.</p>
<p>There is no inheritance in Rust. Instead, a <code>struct</code> may implement zero or more traits. A trait describes some kind of behavior that can be associated with the struct and described further later on in this chapter.</p>
<p>The above impelementation can also be written with the following syntactic sugar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Size {
  pub width: i32,
  pub height: i32,
}


impl Size {
  pub fn new(width: i32, height: i32) -&gt; Self {
      Self {width, height}
  }

  pub fn area(&amp;self) -&gt; i32 {
      self.width * self.height
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note using <code>Self</code> as a type replacer and struct fields inference.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>In C++ all classes have implicit or explicit constructors. Either the compiler generates them or you do, or a mix of both.</p>
<p>An implicit default constructor, copy constructor and assignment operator will be created when a class does not define its own. We saw on page 73 why this could be really bad news.</p>
<p>What becomes obvious from reading there is a lot of noise and potential for error in C++. There would be even more if raw pointers were used instead of a <code>std::unique_ptr</code> here.</p>
<p>In Rust, things are simpler, and we'll see how it shakes out errors.</p>
<p>First off, let's declare our equivalent struct in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
  pub name: String,
  pub age: i32,
  pub credentials: Option&lt;Credentials&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Since credentials are optional, we wrap in an <code>Option</code> object, i.e. credentials might be None or it might be <code>Some(Credentials)</code>.
Any code anywhere in the system can instantiate a <code>Person</code> simply be declaring an instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let person = Person { name: String::from(&quot;Bob&quot;), age: 20, credentials: None }
<span class="boring">}
</span></code></pre></pre>
<p>In Rust you cannot create a struct without initialising all its members so we cannot have a situation where we don't know what is in each field - it MUST be set by our code.</p>
<p>But declaring the struct is a bit clumsy, especially if the struct is created in lots of places. So can write function that behaves like a constructor in C++.</p>
<p>Instead you implement a static method in the impl of the Struct which returns an initialised struct, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
  pub fn new(name: String, age: i32) -&gt; Person {
    Person { name: name.clone(), age: age, credentials: None }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that Rust does not support overloads. So if we had multiple &quot;constructor&quot; methods, they would each have to have unique names.</p>
<p>Finally what is we wanted to copy the <code>Person</code> struct?</p>
<p>By default Rust does not allow copying on user-defined structs. Assigning a variable to another variable moves ownership, it doesn't copy.</p>
<p>There are two ways to make a user-defined struct copyable</p>
<ol>
<li>implement the <code>Copy</code> trait which means assignment is implicit, but is what we want? Do we really want to make copies of a struct by accident?</li>
<li>implement <code>Clone</code> instead to add a <code>clone()</code> method and require an explicit call to <code>clone()</code> order to duplicate the struct a copy.</li>
</ol>
<p>But the compiler can derive clone() providing all the members of the struct implement the Clone trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Person {
  pub name: String,
  pub age: i32,
  pub credentials: Option&lt;Credentials&gt;, // Credentials must implement Clone
}

impl Person {
  pub fn new(name: String, age: String) -&gt; Person {
    Person { name: name.clone(), age: age, credentials: None }
  }
}

//...

let p = Person::new(String::from(&quot;Michael&quot;), 20);
let p2 = p.clone();
<span class="boring">}
</span></code></pre></pre>
<p>What we can see is that Rust's construction and <code>clone()</code> behavior is basically declarative.
We saw how C++ has all kinds of rules and nuances to construction, copy construction and assignment which make it complicated and prone to error.</p>
<h2 id="destructors"><a class="header" href="#destructors">Destructors</a></h2>
<p>A C++ destructor is a specialized method called when your object goes out of scope or is deleted.</p>
<pre><code class="language-c++">class MyClass {
public:
  MyClass() : someMember_(new Resource()) {}
  ~MyClass() {
     delete someMember_;
  }

private:
  Resource *someMember_;
}
</code></pre>
<p>In C++ you can declare a class destructor to be called when the object is about to be destroyed. You have to use a virtual destructor if your class inherits from another class in case a caller calls <code>delete</code> on the base class.</p>
<p>Since Rust does not do inheritance and does not have constructors, the manner in which you cleanup is different and simpler. Instead of a destructor you implement the <code>Drop</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for Shape {
    fn drop(&amp;mut self) {
        println!(&quot;Shape dropping!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler recognizes this trait. If you implement this trait then the compiler knows to call your <code>drop()</code> function prior to destroying your struct. Itâ€™s that simple.</p>
<p>Occasionally there might be a reason to explicitly drop a struct before it goes out of scope. Perhaps the resources held by the variable should be freed as soon as possible to release a resource which is in contention. Whatever the reason, the answer is to call <code>drop</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let some_object = SomeObject::new();
  //...
  // Ordinarily some_object might get destroyed later,
  // but this makes it explicitly happen here
  drop(some_object);
  //...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="access-specifier-rules"><a class="header" href="#access-specifier-rules">Access specifier rules</a></h2>
<p>A C++ class can hide or show methods and members to any other class, or to things that inherit from itself using the public, private and protected keywords:</p>
<ul>
<li><code>public</code> â€“ can be seen by any code internal or external to the class</li>
<li><code>private</code> â€“ can only be used by code internal to the class. Not even subclasses can access these members</li>
<li><code>protected</code> â€“ can be used by code internal to the class and by subclasses.</li>
</ul>
<p>A class may designate another function or class as a friend which has access to the private and protected members of a class.</p>
<p>Rust makes things somewhat simpler.</p>
<p>If you want a struct to be visible outside your module you mark it <code>pub</code>. If you do not mark it <code>pub</code> then it is only visible within the module and submodules.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>If you want public access a member of a struct (including modifying it if its mutable), then mark it <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
  pub age: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>If you want something to be able to call a function on your struct you mark it <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
  pub fn is_adult(&amp;self) -&gt; bool {
    self.age &gt;= 18
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions can be bound to a struct within an <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Shape {
  pub fn new(width: u32, height: u32) -&gt; Shape {
    Shape { width, height }
  }
  
  pub fn area(&amp;self) -&gt; i32 {
    self.width * self.height
  }

  pub fn set(&amp;mut self, width: i32, height: i32) {
    self.width = width;
    self.height = height;
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Functions that start with a <code>&amp;self</code> / <code>&amp;mut self</code> parameter are bound to instances.  Those without are bound to the type. So the <code>new()</code> function can be called as <code>Shape::new()</code>.</p>
<p>Where <code>&amp;self</code> is provided, the function is invoked on the instance. So for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shape = Shape::new(100, 100);
let area = shape.area();
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>&amp;mut self</code> is provided it signifies that the function mutates the struct.</p>
<p>Unlike C++, all access to the struct has to be qualified. In C++ you don't publishing_interval: Double, lifetime_count: UInt32, max_keep_alive_count: UInt32, max_notifications_per_publish: UInt32, priority: Bytehave to say <code>this-&gt;foo()</code> to call foo() from another member of the class. Rust requires code to say unambiguously <code>self.foo()</code>.</p>
<h2 id="static-functions"><a class="header" href="#static-functions">Static functions</a></h2>
<p>Static functions (&quot;associated functions&quot;) are merely functions in the <code>impl</code> block that do not have <code>&amp;self</code> or <code>&amp;mut self</code> as their first parameter, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Circle {
   fn pi() -&gt; f64 { std::f64::consts:PI }
}
//...
let pi = Circle::pi();
<span class="boring">}
</span></code></pre></pre>
<p>In other words they're not bound to an instance of a type, but to the type itself. For example, <code>Circle::pi()</code>.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>C++ allows one class to inherit from another. Generally this is a useful feature although it can get pretty complex if you implement multiple inheritance, particularly the dreaded diamond pattern.</p>
<p>As weâ€™ve found out, Rust doesnâ€™t have classes at all â€“ theyâ€™re structs with bound functions.  So how do you inherit code? The answer is you donâ€™t.</p>
<p>Instead your struct may implement traits which are a bit like partial classes.</p>
<p>A trait is declared like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HasCircumference {
  fn circumference(&amp;self) -&gt; f64;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the trait <code>HasCircumference</code> has a function called <code>circumference()</code> whose signature is defined but must be implemented.</p>
<p>A type can implement the trait by declaring and <code>impl</code> of it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl HasCircumference for Size {
  fn circumference(&amp;self) -&gt; f64 {
    2.0 * std::f64::consts::PI * self.radius
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>A trait may supply default function implementations. For example, a <code>HasDimensions</code> trait might implement <code>area()</code> to spare the implementor the bother of doing it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HasDimensions {
  fn width(&amp;self) -&gt; u32;
  fn height(&amp;self) -&gt; u32;

  fn area(&amp;self) -&gt; u32 {
    self.width() * self.height()
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>In C++ an object lives from the moment it is constructed to the moment it is destructed. </p>
<p>That lifetime is implicit if you declare the object on the stack. The object will be created / destroyed as it goes in and out of scope. It is also implicit if your object is a member of another object - the lifetime is within the containing object, and the declaration order of other members in the containing object.</p>
<p>However, if you allocate your object via <code>new</code> then it is up to you when to <code>delete</code>. If you <code>delete</code> too soon, or forget to <code>delete</code> then you may destabilize your program.  C++ encourages using smart pointers that manage the lifetime of your object, tying it to the implicit lifetime of the smart pointer itself - when the smart pointer is destroyed, it deletes the held pointer. A more sophisticated kind of smart pointer allows multiple instances of the same pointer to exist at once, and reference counting is used so that when the last smart pointer is destroyed, it destroyes the pointer.</p>
<p>Even so, C++ itself will not care if you initialized a class with a reference or pointer to something that no longer lives. If you do this, your program will crash.</p>
<p>Let's write an <code>Incrementor</code> class which increments an integer value and returns that value.</p>
<pre><code class="language-c++">class Incrementor {
public:
	Incrementor(int &amp;value) : value_(value) {}
	int increment() { return ++value_; }

private:
	int &amp;value_;
};
</code></pre>
<p>This seems fine, but what if we use it like this?</p>
<pre><code class="language-c++">Incrementor makeIncrementor() {
  // This is a bad idea
	int value = 5;
	return Incrementor(value);
}
</code></pre>
<p>This code passes a reference to an <code>int</code> into the class constructor and returns the <code>Incrementor</code> from the function itself. But when <code>increment()</code> is called the reference is dangling and anything can happen.</p>
<h2 id="rust-lifetimes"><a class="header" href="#rust-lifetimes">Rust lifetimes</a></h2>
<p>Rust <em>does</em> care about the lifetime of objects and tracks them to ensure that you cannot reference something that no longer exists. Most of the time this is automatic and self-evident from the error message you get if you try something bad. </p>
<p>The compiler also implements a <em>borrow checker</em> which tracks references to objects to ensure that:</p>
<ol>
<li>References are held no longer than the lifetime of the object they refer to.</li>
<li>Only a single mutable reference is possible at a time and not concurrently with immutable references. This is to prevent data races.</li>
</ol>
<p>The compiler will generate compile errors if it finds code in violation of its rules.</p>
<p>So let's write the equivalent of <code>Incrementor</code> above but in Rust. The Rust code will hold a reference to a integer <code>i32</code> and increment it from a bound function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Incrementor {
  value: &amp;mut i32
}

impl Incrementor {
  pub fn increment(&amp;mut self) -&gt; i32 {
    *self.value += 1;
    *self.value
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Seems fine, but the first error we get is:</p>
<pre><code>2 |   value: &amp;mut u32
  |          ^ expected lifetime parameter
</code></pre>
<p>We tried to create a struct that manages a reference, but the compiler doesn't know anything about this reference's lifetime and so it has generated a compile error.</p>
<p>To help the compiler overcome its problem, we will annotate our struct with a lifetime which we will call <code>'a</code>. The label is anything you like but typically it'll be a letter. </p>
<p>This lifetime label is a hint on our struct that says the reference we use inside the struct must have a lifetime of at least as much the struct itself - namely that <code>Incrementor&lt;'a&gt;</code> and <code>value: &amp;'a mut i32</code> share the same lifetime constraint and the compiler will enforce it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Incrementor&lt;'a&gt; {
  value: &amp;'a mut i32
}

impl &lt;'a&gt; Incrementor&lt;'a&gt; {
  pub fn increment(&amp;mut self) -&gt; i32 {
    *self.value += 1;
    *self.value
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>With the annotation in place, we can now use the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut value = 20;
let mut i = Incrementor { value: &amp;mut value };
println!(&quot;value = {}&quot;, i.increment());
<span class="boring">}
</span></code></pre></pre>
<p>Note that the annotation <code>'a</code> could be any label we like - <code>'increment</code> would work if we wanted, but obviously its more longwinded.</p>
<p>There is a special lifetime called <code>'static</code> that refers to things like static strings and functions which have a lifetime as long as the runtime and may therefore be assumed to always exist.</p>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime elision</a></h3>
<p>Rust allows reference lifetimes to be elided (a <a href="https://ericlippert.com/2013/01/24/five-dollar-words-for-programmers-elision/">fancy word</a> for omit) in most function signatures.</p>
<p>Basically, it assumes that when passing a reference into a function, that the lifetime of the reference is implicitly longer than the function itself so the need to annotate is not necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_person(name: &amp;str) -&gt; Option&lt;Person&gt;
// instead of
fn find_person&lt;'a&gt;(name: &amp;'a str) -&gt; Option&lt;Person&gt;
<span class="boring">}
</span></code></pre></pre>
<p>The rules for elision are described in the further reference link.</p>
<h3 id="further-reference"><a class="header" href="#further-reference">Further reference</a></h3>
<p>Lifetimes are a large subject and the documentation is <a href="https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Rust comments are similar to C++ except they may contain Unicode because .rs files are UTF-8 encoded:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
 This is a comment
*/

// This a comment with Unicode, ä½ å¥½
<span class="boring">}
</span></code></pre></pre>
<p>But in addition anything that uses triple slash <code>///</code> annotation can be parsed by a tool called <code>rustdoc</code> to produce documentation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This is a comment that becomes documentation for do_thing below
pub fn do_thing() {}
/// Returned by server if the resource could not be found
pub const NOT_FOUND = 404;
<span class="boring">}
</span></code></pre></pre>
<p>Runnining <code>cargo doc</code> on a project will cause HTML documentation to be produced from annotated comments within the file. </p>
<p>Annotation is written in Markdown format. That means you have a human readable language for writing rich-text documentation and if it's not enough you can resort to HTML via tags.</p>
<p>See here for <a href="https://doc.rust-lang.org/book/documentation.html">full documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes-references-and-borrowing"><a class="header" href="#lifetimes-references-and-borrowing">Lifetimes, References and Borrowing</a></h1>
<p>C/C++ have very little enforcement of object lifetimes aside from checking to see if a variable exists in scope or not, as well as the initialisation of reference variables. This can easily lead to situations where the reference / pointer to some object is left &quot;dangling&quot;, i.e. the object has been destroyed but it is possible to call to where it used to be causing runtime errors.</p>
<p>Rust takes a far stricter view of lifetimes and ownership.</p>
<ol>
<li>Data moves on assignment</li>
<li>Data must implement a <code>Copy</code> trait if it wants to implicitly copy on assignment and there are strict rules on this - basically every member of the struct must be a primitive.</li>
<li>Data must implement a <code>Clone</code> trait if it wants to implicity create a clone of itself.</li>
<li>Data can be &quot;borrowed&quot; (with similar notation and meaning as a reference in C++) but the compiler tracks lifetimes and it is an error for a borrow to exceed the lifetime of the object it references.</li>
<li>Data can only be mutably borrowed by a single reference. It is a compile error for there to be any other references in existence at the same time. This is to prevent one place from modifying data that other places may be reading.</li>
</ol>
<h2 id="binding"><a class="header" href="#binding">Binding</a></h2>
<p>When you assign an object to a variable in Rust, you are said to be binding it. i.e your variable &quot;owns&quot; the object for as long as it is in scope and when it goes out of scope it is destroyed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let v1 = vec![1, 2, 3, 4]; // v1 is bound to the Vec
  ...
  // v1 goes out of scope, Vec is dropped
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-on-assignment"><a class="header" href="#moving-on-assignment">Moving on assignment</a></h2>
<p>In C++ when I copy a value from <code>v1</code> to <code>v2</code>, I have two copies of the same data, independent of each other. This can cause some problems:</p>
<pre><code class="language-c++">class Data {
  Data() : data_(new char[100]) {}
  ~Data() {
    delete []data_;
  }
private:
  char *data_;
}
//...
Data v1;
Data v2 = v1;
// What happens when these go out of scope?
</code></pre>
<p>The problem here is that by assigning <code>v1</code> to <code>v2</code> we now have two classes who share the same private pointer <code>data_</code> and the last to go out of scope and delete the pointer will crash. We could mitigate the problem assuming we noticed it in a couple of ways:</p>
<ol>
<li>Implement a copy constructor and assignment operator to go with the destructor. This is a pattern called the <em>rule of three</em> and while it solves the issue, it complicates our simple class and brings its own issues (e.g. handling <code>v1 = v1</code> properly). </li>
<li>Inherit from a base class with a private copy constructor. This causes the compiler to generate an error on assignment. This is how the <code>boost::noncopyable</code> works</li>
<li>Implement move on assignment. A move means that the assignment passes ownership of the data from <code>v1</code> to <code>v2</code> and the value in <code>v1</code> is invalid and will not be unwound or destroyed. This is even more complex than 1) and usually leads to the <em>rule of five</em> which is even more complex.</li>
</ol>
<p>Rust simplifies this by treating everything as move on assignment.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Data {
  data: Box&lt;[u8; 100]&gt;
}
// ...
let v1 = Data { data: Box::new([0u8; 100])};
let v2 = v1;
// ...
<span class="boring">}
</span></code></pre></pre>
<p>The assignment moves the data from <code>v1</code> to <code>v2</code> and marks <code>v1</code> as invalid. If you attempt to reference <code>v1</code> any more in your code, it will generate a compile error. If there was a panic and the stack unwound, the data in <code>v2</code> would be unwound and the data in <code>v1</code> would be ignored.</p>
<p>Likewise, if we pass by value to a function then that also moves ownership:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let v1 = Data { data: Box::new([0u8; 100])};
  we_own_it(v1);
  println!(&quot;v = {:?}&quot;, v1);
}

fn we_own_it(v: Data) {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>When we called <code>we_own_it(v1)</code> we moved ownership of the data from <code>v1</code> to the function parameter and it never came back.</p>
<p>If we absolutely wanted the data to come back we could do it in this somewhat clumsy inefficient way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v1 = we_own_and_return_it(v1)
...
fn we_own_and_return_it(v: Data) -&gt; Data {
  // ...
  v1
}
<span class="boring">}
</span></code></pre></pre>
<p>So we:</p>
<ol>
<li>Assign the data to <code>v1</code></li>
<li>Move the data to <code>v</code> when we call <code>we_own_and_return_it</code></li>
<li>Return <code>v</code> as the result of the function</li>
<li>Move the data back to <code>v1</code>.</li>
</ol>
<p>That's a lot of moving and a further section will explain borrowing.</p>
<h3 id="variables-must-be-bound-to-something"><a class="header" href="#variables-must-be-bound-to-something">Variables must be bound to something</a></h3>
<p>Just one more point. Variables must be bound to something. You cannot use a variable if it hasn't been initialized with a value of some kind:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;
println!(&quot;The value of x is {}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>It is quite valid in C++ to declare variable and do nothing with it. Or conditionally do something to the variable which confuses the compiler so it only generates a warning.</p>
<pre><code class="language-c++">int result;
{
   // The scope is to control the lifetime of a lock
   lock_guard&lt;mutex&gt; guard(data_mutex);
   result = do_something();
}
if (result == 0) {
  debug(&quot;result succeeded&quot;);
}
</code></pre>
<p>The Rust compiler will throw an error, not a warning, if variables are uninitialised. It will also warn you if you declare a variable and end up not using it.</p>
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<p>We've seen that ownership of an object is tracked by the compiler. If you assign one variable to another, ownership is bound to the assignee. The original variable is invalid and the compiler will generate errors if it is used.</p>
<p>Sometimes we only want to <em>borrow</em> data, use it temporarily without moving it around or the added noise in the code of reassignment.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let mut v = Vec::new(); // empty vector
  fill_vector(&amp;mut v);
  // ...
  println!(&quot;Vector contains {:?}&quot;, v);
}
//...
fn fill_vector(v: &amp;mut Vec&lt;i32&gt;) {
  v.push(1);
  v.push(2);
  v.push(3);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we create an empty vector and pass a mutable reference to it to a function called fill_vector(). The compiler knows that the function is borrowing v and then ownership is returned to v after the function returns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>An expression is something that evaluates to something. Just like C++ more or less...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5 + 5; // expression evaluates to 10
<span class="boring">}
</span></code></pre></pre>
<h2 id="but-blocks-are-expressions-too"><a class="header" href="#but-blocks-are-expressions-too">But blocks are expressions too</a></h2>
<p>Where it gets more interesting is that a block of code, denoted by curly braces also evaluates to an expression. This is legal code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {};
println!(&quot;x = {:?}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>What was assigned to x? In this case the block was empty so x was assigned with the value of <code>()</code>. The value <code>()</code> is a special unitary type that essentially means neither yes or no. It just means &quot;value&quot;.  That is the default type of any function or type. It works a little like <code>void</code> in C++ meaning the value is meaningless so don't even look at it.</p>
<pre><code>x = ()
</code></pre>
<p>This block also returns a value of <code>()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = { println!(&quot;Hello&quot;); };
println!(&quot;x = {:?}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>Again, that's because although the block does stuff (print Hello), it doesn't evaluate to anything so the compiler returns <code>()</code> for us.</p>
<p>So far so useless. But we can change what the block expression evaluates to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {
    let pi = 3.141592735;
    let r = 5.0;
    2.0 * pi * r
};
println!(&quot;x = {}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>Now x assigned with the result of the last line which is an expression. Note how the line is not terminated with a semicolon. That becomes the result of the block expression. If weâ€™d put a semicolon on the end of that line as we did with the println!(&quot;Hello&quot;), the expression would evaluate to ().</p>
<h3 id="use-in-functions"><a class="header" href="#use-in-functions">Use in functions</a></h3>
<p>Trivial functions can just omit the return statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_values(x: i32, y: i32) -&gt; i32 {
  x + y
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="you-can-use-return-in-blocks-too"><a class="header" href="#you-can-use-return-in-blocks-too">You can use return in blocks too</a></h3>
<p>Sometimes you might explicitly need to use the return statement. The block expression evaluates at the end of the block so if you need to bail early you could just use return.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find(value: &amp;str) -&gt; i32 {
  if value.len() == 0 {
    return -1;
  }
  database.do_find(value)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="simplifying-switch-statements"><a class="header" href="#simplifying-switch-statements">Simplifying switch statements</a></h3>
<p>In C or C++ you'll often see code like this:</p>
<pre><code class="language-c++">std::string result;
switch (server_state) {
  case WAITING:
    result = &quot;Waiting&quot;;
    break;
  case RUNNING:
    result = &quot;Running&quot;;
    break;
  case STOPPED:
    result = &quot;Stopped&quot;;
    break;
  }
}
</code></pre>
<p>The code wants to test a value in server_state and assign a string to result. Aside from looking a bit clunky it introduces the possibility of error since we might forget to assign, or add a break, or omit one of the values. </p>
<p>In Rust we can assign directly into result of from a match because each match condition is a block expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = match server_state {
    ServerState::WAITING =&gt; &quot;Waiting&quot;,
    ServerState::RUNNING =&gt; &quot;Running&quot;,
    ServerState::STOPPED =&gt; &quot;Stopped&quot;,
};
<span class="boring">}
</span></code></pre></pre>
<p>Not only is this half the length it reduces the scope for error. The compiler will assign the block expression's value to the variable result. It will also check that each match block returns the same kind of type (so you can't return a float from one match and strings from others). It will also generate an error if the ServerState enum had other values that our match didn't handle.</p>
<h3 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary operator</a></h3>
<p>The ternary operator in C/C++ is an abbreviated way to perform an if/else expression condition, usually to assign the result to a variable.</p>
<pre><code class="language-c++">bool x = (y / 2) == 4 ? true : false;
</code></pre>
<p>Rust has no such equivalent to a ternary operator but it can be accomplished using block expressions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = if y / 2 == 4 { true } else { false };
<span class="boring">}
</span></code></pre></pre>
<p>Unlike C/C++ you could add additiona else ifs, matches or anything else to that providing each branch returns the same type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditions"><a class="header" href="#conditions">Conditions</a></h1>
<p>Conditional code is similar between C++ and Rust. You test the boolean truth of an expression and you can use boolean operators such as &amp;&amp; and || to join expressions together.</p>
<pre><code class="language-c++">int x = 0;
while (x &lt; 10) {
  x++;
}
int y = 10;
bool doCompare = true;
if (doCompare &amp;&amp; x == y) {
  printf(&quot;They match!\n&quot;);
}
</code></pre>
<p>In Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0;
while x &lt; 10 {
  x = x + 1;
}
let y = 10;
let do_compare = true;
if do_compare &amp;&amp; x == y {
  println!(&quot;They match!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>The most notable difference is that Rust omits the outer braces so the code is slightly cleaner. You don't have to omit the outer braces but the compiler will issue a warning if you leave them in.</p>
<h2 id="ternary-operator-1"><a class="header" href="#ternary-operator-1">Ternary operator</a></h2>
<p>The ternary operator is that special ? : shorthand notation you can use to in C++ for simple conditionals.</p>
<pre><code class="language-c++">int x = (y &gt; 200) ? 10 : 0;
</code></pre>
<p>Rust does not support this notation, however you may take advantage of how a block evaluates as an expression to say this instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = if y &gt; 200 { 10 } else { 0 };
<span class="boring">}
</span></code></pre></pre>
<p>So basically you can do one line conditional assignments using if and else. Also note that you could even throw in an &quot;else if&quot; or two if that's what you wanted to do:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = get_temperature();
let water_is = if (c &gt;= 100) { &quot;gas&quot; } else if (c &lt; 0) { &quot;solid&quot; } else { &quot;liquid&quot; };
<span class="boring">}
</span></code></pre></pre>
<h2 id="conditional-if-let"><a class="header" href="#conditional-if-let">Conditional &quot;if let&quot;</a></h2>
<p>One unusual feature is the &quot;if let&quot; pattern. This combines a test to see if something matches a pattern and if it does, to automatically assign the result to the tuple. It would be most commonly see in code that returns an enum such as a <code>Result</code> or <code>Option</code>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn search(name: &amp;str) -&gt; Option&lt;Person&gt; { /* ... */ }
//...
if let Some(person) = search(&quot;fred&quot;) {
  println!(&quot;You fould a person {}&quot;, person);
}
else {
  println!(&quot;Could not find person&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="switch--match"><a class="header" href="#switch--match">Switch / Match</a></h1>
<h2 id="cc-switch"><a class="header" href="#cc-switch">C/C++ switch</a></h2>
<p>A <code>switch</code> statement in C or C++ allows a condition or a variable to be compared to a series of values and for code associated with those values to executed as a result. There is also a default clause to match any value that is is not caught explicitly.</p>
<pre><code class="language-c++">int result = http_get();
switch (result) {
case 200:
  success = true;
  break;
case 404:
  log_error(result);
  // Drop through
default:
  success = false;
  break;
}
</code></pre>
<p>Switch statements can be a source of error because behaviour is undefined when a <code>default</code> clause is not supplied. It is also possible to inadvertently forget the <code>break</code> statement. In the above example, the code explicitly &quot;drops&quot; from the 404 handler into the default handler. This code would work fine providing someone didn't insert some extra clauses between 404 and default...</p>
<p>Additionally switch statements only work on numeric values or <code>bool</code>.</p>
<h2 id="rust-9"><a class="header" href="#rust-9">Rust</a></h2>
<p><a href="https://doc.rust-lang.org/book/match.html">Match</a> is similar to a <code>switch</code> statement but it is a lot more powerful.</p>
<ol>
<li>A <code>match</code> works on integers, ranges of integers, bools, enums, tuples, arrays and structs.</li>
<li>It will destructure tuples, arrays and structs.</li>
<li>It requires a default handler if necessary.</li>
</ol>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result {
  Good,
  Error(u32),
  Unknown
}

let result = doSomething();
match result {
  Result::Good =&gt; { println!(&quot;Good&quot;); }
  Result::Error(e) =&gt; { println!(&quot;Got an error {}&quot;, e); }
  _ =&gt; { /* do nothing */ }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting"><a class="header" href="#casting">Casting</a></h1>
<h2 id="cc-casting"><a class="header" href="#cc-casting">C/C++ casting</a></h2>
<p>Casting is the act of coercing one type to be another, or dynamically producing the equivalent value in the other type.</p>
<p>C++ has a range of cast operators that turn a pointer or value of one kind into a pointer or value of another kind.</p>
<ul>
<li><code>const_cast&lt;T&gt;(value)</code> - removes the const enforcement from a value so it may be modified.</li>
<li><code>static_cast&lt;T&gt;(value)</code> - attempts to convert between types using implicit and user defined conversions.</li>
<li><code>reinterpret_cast&lt;T&gt;(value)</code> - a compiler directive to just treat the input as some other kind. It does not involve any form of conversion.</li>
<li><code>dynamic_cast&lt;T&gt;(value)</code> - attempts to convert a class pointer / reference to/from other classes in its inheritance hierarchy. Involves runtime checks.</li>
<li>Traditional C-style cast - a C++ compiler will attempt to interpret it as a <code>const_cast</code>, a <code>static_cast</code> and a <code>reinterpret_cast</code> in varying combinations.</li>
</ul>
<p>That's a very brief summary of casting which probably invokes more questions than it answers. Casting in C++ is very complex and nuanced. Some casts merely instruct the compiler to ignore const or treat one type as another. A static cast might involve code generation to convert a type. A dynamic cast might add runtime checks and throw exceptions.</p>
<h2 id="coercion"><a class="header" href="#coercion">Coercion</a></h2>
<p>Rust more or less eliminates casting by disallowing the situations where casting is necessary:</p>
<ul>
<li>Const cast - don't do it. You can const cast in unsafe blocks but you really should not without a good reason.</li>
<li>Static cast - implement <code>Into</code> or <code>From</code> traits for the same functionality</li>
<li>Reinterpret cast - unsafe operation</li>
<li>Dynamic cast - Rust does not have inheritance</li>
</ul>
<p>Basically if you wish to &quot;cast&quot; you must do one of the following.</p>
<ol>
<li>A numeric type may be coerced to another numeric type using the <a href="https://doc.rust-lang.org/book/casting-between-types.html#as"><code>as</code></a> keyword.</li>
<li>Complex types can implement <code>Into&lt;Foo&gt;</code> or <code>From&lt;Foo&gt;</code> traits that allows one structured type to be turned into another.</li>
<li>Unsafe code can transmutate memory, essentially reinterpretting the contents.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 123i32;
let b = a as usize;
<span class="boring">}
</span></code></pre></pre>
<h2 id="into-and-from-traits"><a class="header" href="#into-and-from-traits">Into and From traits</a></h2>
<p>Anything beyond this requires implementing the <code>Into&lt;&gt;</code> or <code>From&lt;&gt;</code> traits and making conversion an explicit action.</p>
<p>TODO</p>
<p>The compiler also does not allow code to cast away <code>const</code>-ness or treat one type as another except through <code>unsafe</code> code blocks.</p>
<h1 id="transmutation"><a class="header" href="#transmutation">Transmutation</a></h1>
<p>Rust allows some types to be <a href="https://doc.rust-lang.org/book/casting-between-types.html#transmute">transmuted</a> to others. Transmute is an <code>unsafe</code> action but it allows a memory location to be treated as another type, e.g. an array of bytes as an integer.</p>
<p>TODO example</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<h2 id="scalar-values"><a class="header" href="#scalar-values">Scalar values</a></h2>
<p>In C++ an <code>enum</code> is a list of scalar values to an integer value. i.e. it is basically a bunch of constants with values.</p>
<pre><code class="language-cpp">enum HttpResponse {
  okay = 200,
  not_found = 404,
  internal_error = 500,
};
</code></pre>
<p>C++11 extends this concept a little, allowing you to declare an <code>enum</code> that uses another kind of integral type, e.g. a <code>char</code> to hold the values.</p>
<pre><code class="language-cpp">enum LibraryCode : char {
  checked_in = 'I',
  checked_out = 'O',
  checked_out_late = 'L'
};
</code></pre>
<p>In Rust an <a href="https://doc.rust-lang.org/book/enums.html"><code>enum</code></a> can be a scalar value just like in C++. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum HttpResponse {
  Ok = 200,
  NotFound = 404,
  InternalError = 500
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="as-a-typed-union"><a class="header" href="#as-a-typed-union">As a typed union</a></h2>
<p>C/C++ have a construct called a <code>union</code> that describes a variable that can contain one of many possible fields:</p>
<pre><code class="language-c">union VariantValue {
  char *s;
  uint8_t u8;
  uint16_t u16;
  double f64;
}
</code></pre>
<p>So this <code>VariantValue</code> can hold a pointer to a string, or an unsigned byte, or an unsigned word, or a double precision float. It is up to the caller and callee to know from the context which value is used.</p>
<p>It is quite common for a union to be wrapped up in a struct that has a type field describing what the payload is, for example:</p>
<pre><code class="language-c">enum VariantType {
  VT_STRING,
  VT_UINT8,
  VT_UINT16,
  VT_DOUBLE
};

struct Variant {
  VariantType vt;
  VariantValue value;
}
</code></pre>
<p>This <code>Variant</code> has a <code>VariantType</code> enumeration that says which field in <code>VariantValue</code> should be read. We can then proceed to use the code something like this:</p>
<pre><code class="language-c++">Variant v;
v.type = VT_STRING;
v.value.s = &quot;Hello World&quot;;
printValue(v);

void printValue(const Variant &amp;v) {
  switch (v.vt) {
    case VT_STRING: 
      std::cout &lt;&lt; v.value.s &lt;&lt; endl;
      break;
    case VT_UINT8:
      std::cout &lt;&lt; v.value.u8 &lt;&lt; endl;
      break;
    case VT_UINT16:
      std::cout &lt;&lt; v.value.u16 &lt;&lt; endl;
      break;
    case VT_DOUBLE:
      std::cout &lt;&lt; v.value.f64 &lt;&lt; endl;
      break;
  }
}
</code></pre>
<p>Rust provides all of the above functionality through <code>enum</code>. Instead of the above we could declare an <code>enum</code> in Rust where values can hold a payload:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Variant {
  String(String),
  UInt8(u8),
  UInt16(u16),
  Double(f64)
};
<span class="boring">}
</span></code></pre></pre>
<p>So here, the enum <code>String</code> has a payload value of a <code>String</code> type. This <code>Variant</code> type can be easily initialised and the value inferred:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = Variant::String(&quot;Hello World&quot;.into());
printValue(&amp;v);

fn printValue(v: &amp;Variant) {
  match v {
    Variant::String(ref v) =&gt; println!(&quot;{}&quot;, v),
    Variant::UInt8(v) =&gt; println!(&quot;{}&quot;, v),
    Variant::UInt16(v) =&gt; println!(&quot;{}&quot;, v),
    Variant::Double(v) =&gt; println!(&quot;{}&quot;, v),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This code is functionally the same as C++, but it is a lot terser and a lot safer. Essentially the variant is constructed in a single line and passed into the function. The <code>match</code> extracts the payload according to the match pattern and calls the handler. </p>
<p>Note: you'll see in the match on <code>Variant::String(ref v)</code> that it uses a reference to the value. This is because otherwise it would move the value from the <code>Variant</code> which would cause a compiler error. The variant is supplied to the function as a reference and we cannot move values out of it. It is fine for the other branches of the match because numeric types have an intrinsic <code>Copy</code> trait and don't need to move to do this.</p>
<h3 id="rust-has-union-too"><a class="header" href="#rust-has-union-too">Rust has union too</a></h3>
<p>Rust does have a <code>union</code> keyword that works very much like C/C++. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union VariantValue {
  s: String,
  uint8: u8,
  uint16: u16,
  double: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>But since Rust does not know what the type of the value is, you are required to use <code>unsafe</code> blocks anywhere you read or write values to the union:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = VariantValue{ s: &quot;Hello World!&quot;.into };

unsafe {
  // This code has to know v contains a string
  println!(&quot;Value of value is {}&quot;, v.s);
}
<span class="boring">}
</span></code></pre></pre>
<p>Ordinarily you'll probably only ever use <code>union</code> from Rust if you're talking with C or C++.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<h2 id="c-6"><a class="header" href="#c-6">C++</a></h2>
<h3 id="for-loops"><a class="header" href="#for-loops">For loops</a></h3>
<p>A <code>for</code> loop in C/C++ consists of 3 expression sections housed in the <code>for()</code> section and a block of code to execute:</p>
<p>The three segments of a for statement allow:</p>
<ul>
<li>Zero or more variables to be initialized (can be empty)</li>
<li>Zero or more conditions to be true for the loop to continue (can be empty)</li>
<li>Zero or more actions to perform on each iteration (can be empty).</li>
</ul>
<p>So this is a valid for loop:</p>
<pre><code class="language-cpp">// Infinite
for (;;) {
  //...
}
</code></pre>
<p>So is this:</p>
<pre><code class="language-cpp">for (int i = 10, j = 0; (j = i * i) &lt;= 100; i--) {
  //...
}
</code></pre>
<p>This is clearly a convoluted and somewhat confusing loop because it mixes assignment and conditional tests into the terminating text, but it is one which is entirely legal.</p>
<h4 id="iterating-a-range"><a class="header" href="#iterating-a-range">Iterating a range</a></h4>
<p>A C++ loop consists of an initialising expression, a condition expression and a a loop expression separated by semicolons. So a loop that iterates from 0 to 100 looks like this:</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 100; i++ ) {
  cout &lt;&lt; &quot;Number &quot; &lt;&lt; i &lt;&lt; endl;
}
</code></pre>
<h4 id="iterating-c-collections"><a class="header" href="#iterating-c-collections">Iterating C++ collections</a></h4>
<p>C++ introduces the concept of iterators to its collection classes. An <code>iterator</code> is something that can increment or decrement to traverse a collection.</p>
<p>So to iterate a collection from one end to the other, an iterator is assigned with the collection's <code>begin()</code> iterator and incremented until it matches the <code>end()</code> iterator.</p>
<pre><code class="language-cpp">for (std::vector&lt;string&gt;::const_iterator i = my_list.begin(); i != my_list.end(); ++i ) {
  cout &lt;&lt; &quot;Value = &quot; &lt;&lt; *i &lt;&lt; end;
}
</code></pre>
<p>C++11 provides new range based for-loop with simpler syntax when iterating over arrays and collections:</p>
<pre><code class="language-cpp">std::vector values;
...
for (const auto &amp; v: values) {
  ...
}

int x[5] = { 1, 2, 3, 4, 5 };
for (int y : x) {
  ...
}
</code></pre>
<h3 id="infinite-loop"><a class="header" href="#infinite-loop">Infinite Loop</a></h3>
<p>An infinite loop is one that never ends. The typical way to do this in C++ is to test against an expression that always evaluates to true or use an empty for loop:</p>
<pre><code class="language-cpp">while (true) {
  poll();
  do_work();
}
// Or with a for loop
for (;;) {
  poll();
  do_work();
}
</code></pre>
<h3 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h3>
<p>C++ has conditional <code>while() {}</code> and <code>do { } while()</code> forms. The former tests the expression before it even runs while the latter runs at least once before testing the expression.</p>
<pre><code class="language-cpp">while (!end) {
  std::string next = getLine();
  end = next == &quot;END&quot;;
}
</code></pre>
<p>The do-while form in C++ will execute the loop body at least once because the condition is only tested after each iteration instead of before.</p>
<pre><code class="language-cpp">int i = 0;
do {
  i = rand();
} while (i &lt; 20);
</code></pre>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue">Break and Continue</a></h3>
<p>If you need to exit a loop or start the next iteration early then you use the <code>break</code> and <code>continue</code> keywords. The break keyword terminates the loop, the continue, causes the loop to proceed to the next iteration.</p>
<pre><code class="language-cpp">bool foundAdministrator = false;
for (int i = 0; i &lt; loginCredentials; ++i) {
   const LoginCredentials credentials = fetchLoginAt(i);
   if (credentials.disabled) {
     // This user login is disabled so skip it
     continue;
   }
   if (credentials .isAdmin) {
     // This user is an administrator so no need to search rest of list
     foundAdministrator = true;
     break;
   }
   // ...   
}
</code></pre>
<h2 id="rust-10"><a class="header" href="#rust-10">Rust</a></h2>
<h3 id="for-loop"><a class="header" href="#for-loop">For loop</a></h3>
<p>Rust's <code>for</code> loop is actually sugar over the top of iterators. If a structured type implements the trait <code>IntoIterator</code> it can be looped over using a <code>for</code> loop.</p>
<p>Basically in pseudo code, the loop desugars to this:</p>
<pre><code class="language-pseudocode">If structure type can be turned `IntoIterator`
  Loop
   If let Some(item) = iterator.next() {
     do_action_to_item(item)
   Else
     break;
  End
Else 
  Compile Error
Done
</code></pre>
<h4 id="iterating-a-range-1"><a class="header" href="#iterating-a-range-1">Iterating a range</a></h4>
<p>A <code>Range</code> object in Rust is expressed as <code>from..to</code> where <code>from</code> and <code>to</code> are values or expressions that evaluate to values.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let range=0..33;
// Variables
let min = 0;
let max = 100;
let range2 = min..max;
<span class="boring">}
</span></code></pre></pre>
<p>A range is inclusive / exclusive, i.e. the minimum value is included in the <code>Range</code> but the maximum value is exclusive.</p>
<p>Here is a simple loop that counts from 0 to 9</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 0..10 {
  println!(&quot;Number {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>The value <code>0..10</code> is a <code>Range</code> that runs from 0 to exclusive of 10. A range implements the <code>Iterator</code> trait so the for loop advances one element at a time until it reaches the end.</p>
<p>Iterators have a lot of functions on them for doing fancy stuff, but one which is useful in loops is the <code>enumerate()</code> function. This transforms the iterator into returning a tuple containing the index and the value instead of just the value.</p>
<p>So for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (i, x) in (30..50).enumerate() {
   println!(&quot;Index {} is value {}&quot;, i, x);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="for-loop---iterating-arrays-and-collections"><a class="header" href="#for-loop---iterating-arrays-and-collections">For loop - Iterating arrays and collections</a></h3>
<p>Here is a loop that iterates an array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = [2, 4, 6, 7, 8, 11, 33, 111];
for v in &amp;values {
   println!(&quot;v = {}&quot;, v);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note you can only iterate over an array by reference because iterating it by value would be destructive. </p>
<p>We can directly use the <code>iter()</code> function that arrays and collections implement which works by reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![2, 4, 6, 7, 8, 11, 33, 111];
for v in values.iter() {
   println!(&quot;v = {}&quot;, v);
}
<span class="boring">}
</span></code></pre></pre>
<p>If the collection is a map, then iterators will return a key and value tuple</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut values = HashMap::new();
values.insert(&quot;hello&quot;, &quot;world&quot;);
//...
for (k, v) in &amp;values {
  println!(&quot;key = {}, value = {}&quot;, k, v);
}
<span class="boring">}
</span></code></pre></pre>
<p>Another way to iterate is using the <code>for_each()</code> function on the iterator itself:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = [2, 4, 6, 7, 8, 11, 33, 111];
values.iter().for_each(|v| println!(&quot;v = {}&quot;, v));
<span class="boring">}
</span></code></pre></pre>
<h3 id="break-and-continue-1"><a class="header" href="#break-and-continue-1">Break and Continue</a></h3>
<p>Rust also has <code>break</code> and <code>continue</code> keywords and they operate in a similar fashion - they operate on the innermost loop. A <code>continue</code> will start on the next iteration while a <code>break</code> will terminate the loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values = vec![2, 4, 6, 7, 8, 11, 33, 111];
for v in &amp;values {
  if *v % 2 == 0 {
    continue;
  }
  if *v &gt; 20 {
    break;
  }
  println!(&quot;v = {}&quot;, v);
} 
<span class="boring">}
</span></code></pre></pre>
<h4 id="labels"><a class="header" href="#labels">Labels</a></h4>
<p>The <code>break</code> and <code>continue</code> work by default on the current loop. There will be occasions where you intend to break out
of an enclosing loop instead. For those occasions you can label your loops and pass that label into the <code>break</code> or `continue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'x: for x in 0..10 {
  'y: for y in 0..10 {
     if x == 5 &amp;&amp; y == 5 {
       break 'x;
     }
     println!(&quot;x = {}, y = {}&quot;, x, y);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="infinite-loop-1"><a class="header" href="#infinite-loop-1">Infinite Loop</a></h3>
<p>Rust has an explicit infinite <code>loop</code> that runs indefinitely:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
  poll();
  do_work();
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust recommends using this form when an infinite loop is required to assist with code generation. Note that an 
infinite loop can still be broken out of using a <code>break</code> statement.</p>
<h3 id="while-loop-1"><a class="header" href="#while-loop-1">While Loop</a></h3>
<p>A <code>while</code> loop in Rust looks pretty similar to one written in C/C++. The main difference is that parentheses are not necessary around the conditional test.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while request_count &lt; 1024 {
  process_request();
  request_count = request_count + 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust has no equivalent to the do-while loop form. It can be simulated but it looks a bit inelegant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
loop {
  i = i + 1;
  if i &gt;= 20 { break; }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="while-let-loop"><a class="header" href="#while-let-loop">While let loop</a></h3>
<p>Just as there is an <code>if let</code> which tests and assigns a value that matches a pattern, there is also a <code>while let</code> equivalent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iterator = vec.into_iter();
while let Some(value) = iterator.next() {
  process(value);
}
<span class="boring">}
</span></code></pre></pre>
<p>This loop will break when the iterator returns <code>None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>In C++ the standard form of a function is this:</p>
<pre><code class="language-c++">// Declaration
int foo(bool parameter1, const std::string &amp;parameter2);

// Implementation
int foo(bool parameter1, const std::string &amp;parameter2) {
  return 1;
}
</code></pre>
<p>Usually you would declare the function, either as a forward reference in a source file, or in a header. Then you would implement the function in a source file. </p>
<p>If a function does not return something, the return type is <code>void</code>. If the function does return something, then there should be return statements for each exiting branch within the function.</p>
<p>You can forego the function declaration in two situations:</p>
<ol>
<li>If the function is inline, i.e. prefixed with the <code>inline</code> keyword. In which case the function in its entireity is declared and implemented in one place. </li>
<li>If the function is not inline but is declared before the code that calls it in the same source file. So if function <code>foo</code> above was only used by one source file, then just putting the implementation into the source would also act as the declaration</li>
</ol>
<p>In Rust the equivalent to <code>foo</code> above is this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(parameter1: bool, parameter2: &amp;str) -&gt; i32 {
  // implementation
  1
}
<span class="boring">}
</span></code></pre></pre>
<p>The implementation <em>is</em> the declaration there is no separation between the two. Functions that return nothing omit the <code>-&gt;</code> return section. The function can also be declared before or after whatever calls it. By default the function is private to the model (and submodules) that implement it but making it <code>pub fn</code> exposes it to other modules.</p>
<p>Like C++, the function must evaluate to something for each exiting branch but this is mandatory. </p>
<p>Also note, that the <code>return</code> keyword is not usually unecessary. Here is a function that adds two values together and returns them with no return:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
  x + y
}
<span class="boring">}
</span></code></pre></pre>
<p>Why is there no <code>return</code>? As we saw in the section on Expressions, a block evaluates to a value if we omit the semi-colon from the end so <code>x + y</code> is the result of evaluating the function block and becomes what we return.</p>
<p>There are occasions were you explicitly need the return keyword. Typically you do that if you want to exit the function before you get to the end of the function block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_data(number_of_times: ui32) -&gt; ui32 {
  if number_of_times == 0 {
    return 0;
  }
  let mut result : ui32 = 0;
  for i in number_of_times {
    result += i;
  }
  result
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="variable-arguments"><a class="header" href="#variable-arguments">Variable arguments</a></h2>
<p>C++ functions can take a variable number of arguments with the ... ellipsis pattern. This is used in functions such as print, scanf etc.</p>
<pre><code class="language-c++">void printf_like(const char *pattern, ...);
</code></pre>
<p>Rust does not support variadic functions (the fancy name for this ability). However you could pass additional arguments in an array slice if the values are the same, or as a dictionary or a number of other ways.</p>
<p>TODO Rust example of array slice</p>
<p>Another option is to write your code as a macro. Macros can take any number of expressions so you are able to write code that takes variable arguments. This is how macros such println!, format! and vec! work.</p>
<h2 id="default-arguments"><a class="header" href="#default-arguments">Default arguments</a></h2>
<p>C++ arguments can have default values.</p>
<pre><code class="language-c++">std::vector&lt;Record&gt; fetch_database_records(int number_to_fetch = 100);
</code></pre>
<p>A function defines what its name is, what types it takes and what value (if any) it returns.</p>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function overloading</a></h2>
<p>C++ functions can be overloaded, e.g.</p>
<pre><code class="language-c++">std::string to_string(int x);
std::string to_string(float x);
std::string to_string(bool x);
</code></pre>
<p>Rust does not support overloading. As an alternative, each variation of the function would have to be named uniquely.</p>
<h2 id="c11-alternative-syntax"><a class="header" href="#c11-alternative-syntax">C++11 alternative syntax</a></h2>
<p>C++11 introduces a new syntax which is slightly closer to Rust's in style.</p>
<pre><code class="language-c++">auto function_name(type parameter1, type parameter2, ...) -&gt; return-type;
</code></pre>
<p>This form was created to allow C++ function declarations to more closely to resemble lambda functions in some scenarios and to help with decltype return values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<h2 id="c-7"><a class="header" href="#c-7">C++</a></h2>
<p>C++ has 4 types of polymorphism:</p>
<ol>
<li>Function name overloading - multiple definitions of the same function taking different arguments. </li>
<li>Coercion - implicit type conversion, e.g. assigning a double to an int or a bool.</li>
<li>Parametric - compile type substitution of parameters in templates</li>
<li>Inclusion - subtyping a class with virtual methods overloads their functionality. Your code can use the pointer to a base class, yet when you call the method you are calling the function implemented by the subtype.</li>
</ol>
<p>These conspire to allow the same named function to be called with different parameters that may or may not match their signatures with the compiler following a set of rules to determine what you the programmer meant.</p>
<h3 id="function-name-overloading"><a class="header" href="#function-name-overloading">Function name overloading</a></h3>
<pre><code class="language-c++">class Variant {
public:
  void set(); // Null variant
  void set(bool value);
  void set(int value);
  void set(float value);
  void set(Array *value);
};
</code></pre>
<h3 id="beware-implicit-conversion"><a class="header" href="#beware-implicit-conversion">Beware implicit conversion</a></h3>
<p>One of the biggest issues that you might begin to see from the above example is that is too easy to inadvertantly call the wrong function because C++ will also implicitly convert types. </p>
<p>For example we have a class <code>Foo</code> which has a constructor.</p>
<pre><code class="language-c++">class Foo {
public:
  Foo(int i) { /*...*/ }
};

// A function that does something with Foo
void do_foo(Foo f) {
  //.. do something to foo
}

// A piece of code that calls do_foo().
do_foo(1);
//...

</code></pre>
<p>What you may not notice at first glance is <code>do_foo()</code> was called with <code>1</code> but it still compiled. Why? Because the compiler took it upon itself to convert that <code>1</code> into <code>Foo(1)</code> and feed it to the function. Because of this a subtle error has crept in. So C++ has an <code>explicit</code> keyword to stop this happening:</p>
<pre><code class="language-c++">class Foo {
public:
  explicit Foo(int i) { /*...*/ }
};

// A piece of code that calls do_foo().
Foo i1(20);
do_foo(1); // Compiler error
//...
</code></pre>
<p>But you can see it's all becoming very ornery and that's before even considering that C++ has default parameter values <em>and</em> default constructors. So you might call a function using one signature and be calling something entirely different after the compiler resolves it.</p>
<h2 id="rust-11"><a class="header" href="#rust-11">Rust</a></h2>
<p>Rust has limited support for polymorphism. This can be very frustrating as we'll see and it is a pain point that many new programmers will run into. Why can C++ do polymorphism and Rust can't? </p>
<p>The two plausible answers are a) not to repeat the mistakes of C++, b) the language hasn't gotten to addressing the issue properly.</p>
<p>But for the moment the rules are as follows:</p>
<ol>
<li>Function name overloading - there is none. See section below for alternatives.</li>
<li>Coercion. Rust allows limited, explict coercion between numeric types using the <code>as</code> keyword. Otherwise see below for use on <code>Into</code> and <code>From</code> traits.</li>
<li>Parameteric - similar to C++ via generics.</li>
<li>Inclusion - there is no inheritance in Rust. The nearest thing to a virtual method is a trait with an implemented function that an implementation overrides with its own. However this override is at compile time.</li>
</ol>
<h3 id="alternatives-to-function-name-overloading"><a class="header" href="#alternatives-to-function-name-overloading">Alternatives to function name overloading</a></h3>
<p>If you have a few functions you can just disambiguate them, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(name: &amp;str) -&gt; Foo { /* ... */ }
fn new_age(name: &amp;str, age: u16) -&gt; Foo { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>This can look very messy after a while, so there is another alternative - conversion traits.</p>
<p>You might also do this by saying you can supply any value, struct or tuple that implements a, e.g. New</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new&lt;T&gt;(value: T) where T: Into&lt;NewArgs&gt; {
  //....
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="use-traits"><a class="header" href="#use-traits">Use traits</a></h4>
<p>A common way to do polymorphism is with <em>traits</em>.</p>
<p>There are two standard traits for this purpose:</p>
<ul>
<li>The <code>From&lt;&gt;</code> trait converts from some type into the our type. </li>
<li>The <code>Into&lt;&gt;</code> trait converts some type (consuming it in the process) into our type </li>
</ul>
<p>You only need to implement <code>From</code> or <code>Into</code> because one implies the other.</p>
<p>The <code>From</code> trait is easier to implement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::From;

impl From&lt;&amp;'static str&gt; for Foo {
  fn from(v: &amp;'static str) -&gt; Self {
    Foo { /* ... */ }
  }
}

impl From&lt;(&amp;'static str, u16)&gt; for Foo {
  fn from(v: (&amp;'static str, u16)) -&gt; Self {
    Foo { /* ... */ }
  }
}
//...

let f = Foo::from(&quot;Bob&quot;);
let f = Foo::from((&quot;Mary&quot;, 16));
<span class="boring">}
</span></code></pre></pre>
<p>But let's say we want an explicit <code>new</code> constructor function on type <code>Foo</code>. In that case, we could write it using the <code>Into</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
  pub fn new&lt;T&gt;(v: T) -&gt; Foo where T: Into&lt;Foo&gt; {
    let result = Foo::foo(v);
    // we could code here that we do here after making Foo by whatever means
    result
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Since <code>From</code> implies <code>Into</code> we can just call the constructor like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = Foo::new(&quot;Bob&quot;);
let f = Foo::new((&quot;Mary&quot;, 16));
<span class="boring">}
</span></code></pre></pre>
<p>If you prefer you could implement <code>Into</code> but it's more tricky since it consumes the input, which might not be what you want.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This Into works on a string slice
impl Into&lt;Foo&gt; for &amp;'static str {
    fn into(self) -&gt; Foo {    
        //... constructor
    }    
}

// This Into works on a tuple consisting of a string slice and a u16
impl Into&lt;Foo&gt; for (&amp;'static str, u16) {    
    fn into(self) -&gt; Foo {    
        //... constructor
    }    
}

//...
let f: Foo = &quot;Bob&quot;.into();
let f: Foo = (&quot;Mary&quot;, 16).into();
// OR
let f = Foo::new(&quot;Bob&quot;);
let f = Foo::new((&quot;Mary&quot;, 16));
<span class="boring">}
</span></code></pre></pre>
<h4 id="use-enums"><a class="header" href="#use-enums">Use enums</a></h4>
<p>Remember that an enumeration in Rust can contain actual data, so we could also implement a function that takes an enumeration as an argument that has values for each kind of value it accepts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FooCtorArgs {
   String(String),
   StringU16(String, u16)
}

impl Foo {
  pub fn new(v: FooCtorArgs) {
    match v {
      FooCtorArgs::String(s) =&gt; { /* ... */ }
      FooCtorArgs::StringU16(s, i) =&gt; { /* ... */ }
    }
  }
}
//...
let f = Foo::new(FooCtorArgs::String(&quot;Bob&quot;.to_string()));
let f = Foo::new(FooCtorArgs::StringU16(&quot;Mary&quot;.to_string(), 16));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<h2 id="c-8"><a class="header" href="#c-8">C</a></h2>
<p>C supports a conventional way of error propagation - functions can return a value to indicate the success or failure of the operation.</p>
<pre><code class="language-c">if (strcmp(&quot;hello&quot;, &quot;world&quot;) != 0) {
  printf(&quot;Strings do not match&quot;);
}
</code></pre>
<p>In addition most C compilers offer <code>setjmp()</code> and <code>longjmp()</code>. These functions are used together to allow a program to set a place in the stack from which code further down the stack can &quot;long jump&quot; back to in the case of an error or some other condition. Note that C has no destructors so the code itself is responsible for freeing resources and memory it may have allocated in between the two points in the stack.</p>
<p>There is little in the language beyond this, however some compilers may offer <code>structured exception handling</code> (SEH) as a poor-man's version of the functionality in C++. </p>
<p>Generally speaking <code>setjmp()</code>, <code>longjmp()</code> and SEH do not mix well with their C++ counterparts so if they are used at all should only be in the same language context, and not across C to C++ boundaries. If C++ code attempts to <code>longjmp()</code> it will not invoke destructors in the same manner as a try-catch block.</p>
<h2 id="c-9"><a class="header" href="#c-9">C++</a></h2>
<p>C++ allows C-style error handling but also allows code to throw and catch exceptions. </p>
<p>As the name suggests, exceptions indicate an exceptional error but some code may use them considerably more than that.</p>
<p>A thrown exception interrupts the current flow of logic and allows something further up the stack to catch the exception and recover. The compiler instruments the code so that any intervening objects on the stack are destroyed as the stack is unwound. Note however that this only applies to stack allocated objects, not those which are heap allocated.</p>
<p>If nothing catches the throw then the thread itself will exit. Uncaught exceptions on the main thread cause the entire program to terminate.</p>
<pre><code class="language-c++">void do_something() {
  if (!read_file()) {
    throw std::runtime_error(&quot;read_file didn't work!&quot;);
  }
}
...
try {
  do_something();
}
catch (std::exception e) {
   std::cout &lt;&lt; &quot;Caught exception -- &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
}
</code></pre>
<h3 id="exceptions-vs-error-codes"><a class="header" href="#exceptions-vs-error-codes">Exceptions vs Error codes</a></h3>
<p>Most coding guidelines suggest using exceptions sparingly for truly exceptional situations, and use return codes and other forms of error propagation for ordinary failures.</p>
<p>However C++ has no simple way to confer error information for ordinary failures. Here are some common ways that they do:</p>
<ul>
<li>Functions that return a <code>bool</code>, an <code>int</code>, or a pointer with special meaning. e.g. <code>false</code>, <code>-1</code> or <code>NULL</code> for failure.</li>
<li>Functions that return a result code or enum. This might have a <code>GOOD</code> value and a bunch of <code>ERROR_</code> values. An extreme example would be <code>HRESULT</code> used by Windows that bitpacks information about goodness, severity and origin into a result and requires macros to extract the information.</li>
<li>Functions that have a special out parameter that is filled in with additional detail in the case of failure.</li>
<li>Functions that provide further information about the last error in <code>errno()</code> or some similar function supplied by the library.</li>
<li>Exceptions that are thrown for any failure and must be caught. </li>
<li>Exceptions that are thrown sometimes and error codes are returned other times.</li>
<li>Functions that are overloaded into two forms, one that throws an exception, another that stores the error in an error parameter. The boost library has functions like this.</li>
</ul>
<p>Since there is no consistent way to deal with errors, every library and function has its own ad hoc way to return information.</p>
<h2 id="rust-12"><a class="header" href="#rust-12">Rust</a></h2>
<h3 id="panic"><a class="header" href="#panic">Panic</a></h3>
<p>Rust has a limited form of exception handling called a panic which is invoked through a <code>panic!()</code> macro.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if connection_status == Status::Error {
  panic!(&quot;We should have been connected by now&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>As the name suggests, a panic is a serious problem, usually in the programming logic. Panics are generally a way to fail the program, obtain a stack trace and fix the position where it happened so it doesn't happen again.</p>
<p>As with C++ exceptions, the panic will unwind all the way to the top of the thread and will kill the thread. If the thread is the main thread, the entire process is terminated.</p>
<p>You can catch most panics with a <code>catch_unwind()</code> function that takes the code to trap as a closure. For example, this code will call <code>simulate_panic()</code>, catch the problem, report the error to the program to handle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::panic::catch_unwind;

if let Err(cause) = catch_unwind(|| simulate_panic()) {
  println!(&quot;Code suffered a panic, cause = {:?}&quot;, cause);
}

fn simulate_panic() {
  panic!(&quot;I failed&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>The panic is a very heavy handed mechanism and is not suitable for standard error handling. It should be used for <em>exceptional</em> circumstances, not those which are likely to occur frequently.</p>
<h3 id="result-and-option"><a class="header" href="#result-and-option">Result and Option</a></h3>
<p>Rust provides two enumeration types called <code>Result</code> and <code>Option</code> that allow functions to propagate results to their caller. </p>
<p>These should be your every day option for error handling.</p>
<h4 id="resultt-e"><a class="header" href="#resultt-e">Result&lt;T, E&gt;</a></h4>
<p>The result type is used by functions that return something on success or they return an error. The type is a generic, so the code decides what the type for success and error are: The <code>Result&lt;T, E&gt;</code> takes a success value type <code>T</code> and an error type <code>E</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E)
}
<span class="boring">}
</span></code></pre></pre>
<p>So perhaps we have <code>validate_files()</code> function that either succeeds or it returns with an error. We can define it like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ErrorResultCode {
  ResourcesNotFound(Vec&lt;String&gt;),
  DataCorrupted,
  PermissionDenied
}

fn validate_files() -&gt; Result&lt;(), ErrorResultCode&gt; { /* ... */ }
//...
match validate_files() {
  Ok(_) =&gt; { println!(&quot;Success&quot;); }
  Err(err) =&gt; {
    match err {
      ErrorResultCode::ResourcesNotFound(resources) =&gt; {
        println!(&quot;Fail resources not found&quot;);
        resources.for_each(|resource| println!(&quot;Not found {}&quot;, resource));
      }
      ErrorResultCode::DataCorrupted =&gt; { println!(&quot;Fail data corrupted&quot;); }
      ErrorResultCode::PermissionDenied =&gt; { println!(&quot;Fail permission denied&quot;); }
    }
  }
}

<span class="boring">}
</span></code></pre></pre>
<p>The return code <code>Result&lt;(), ErrorResultCode&gt;</code> means calling the function will either return:</p>
<ul>
<li><code>Ok(T)</code> where the payload is the <code>()</code> unity type/value. i.e. when we succeed we get back nothing more of interest.</li>
<li><code>Err(E)</code> where the payload is <code>ErrorResultCode</code> which we can inspect further if we want to.</li>
</ul>
<h4 id="option"><a class="header" href="#option">Option<T></a></h4>
<p>The <code>Option</code> enum either returns <code>None</code> or <code>Some(T)</code> where the <code>Some</code> contains a type <code>T</code> payload of data.</p>
<p>This type is particularly useful for functions that either return something or nothing, e.g. a database query.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
   None
   Some(T)
}
<span class="boring">}
</span></code></pre></pre>
<p>For example, we might have a function that searches a database for a person's details, and it either finds them or it doesn't.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person { /* ... */}

fn find_person(name: &amp;str) {
   let records = run_query(format!(&quot;select * from persons where name = {}&quot;, sanitize_name(name)));
   if records.is_empty() {
      None
   }
   else {
      let person = Person::new(records[0]);
      Some(person)
   }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="the--directive"><a class="header" href="#the--directive">The ? directive</a></h4>
<p>Let's say you have 2 functions <code>delete_user</code> and <code>find_user</code>. The function <code>delete_user</code> first calls <code>find_user</code> to see if the user even exists and then proceeds to delete the user or return the error code that it got from <code>find_user</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_user(name: &amp;str) -&gt; Result&lt;(), ErrorCode&gt; {
  let result = find_user(name);
  if let Ok(user) = result {
     // ... delete the user
     Ok(())
  }
  else {
    Err(result.unwrap_err())
  }
}

fn find_user(name: &amp;str) -&gt; Result&lt;User, ErrorCode&gt; {
  //... find the user OR
  Err(ErrorCode::UserDoesNotExist)
}
<span class="boring">}
</span></code></pre></pre>
<p>We have a lot of code in <code>delete_user</code> to handle success or failure in <code>find_user</code> and throw its failure code upwards. So Rust provides a convenience <code>?</code> mark on the end of the call to a function that instructs the compiler to generate the if/else branch we hand wrote above, reducing the function to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_user(name: &amp;str) -&gt; Result&lt;(), ErrorCode&gt; {
  let user = find_user(name)?;
  // ... delete the user
  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Providing you want to propogate errors up the call stack, this can eliminate a lot of messy conditional testing in the code and make it more robust.</p>
<p>Older versions of Rust used a special <code>try!()</code> macro for this same purpose (not to be confused with <code>try-catch</code> in C++) which does the same thing. So if you see code like this, it would be the same as above.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_user(name: &amp;str) -&gt; Result&lt;(), ErrorCode&gt; {
  let user = try!(find_user(name));
  // ... delete the user
  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-expressions--closures"><a class="header" href="#lambda-expressions--closures">Lambda Expressions / Closures</a></h1>
<h2 id="lambdas-in-c11"><a class="header" href="#lambdas-in-c11">Lambdas in C++11</a></h2>
<p>A <a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx">lambda expression</a> is an anonymous function that can be declared and passed around from within the scope of the call itself.</p>
<p>A lambda can be particularly useful when you want to sort, filter, search or otherwise do some trivial small action without the bother of declaring and maintaining a separate function.</p>
<p>In C++ a lambda looks like this:</p>
<pre><code class="language-c++">float values[10] = { 9, 3, 2.1, 3, 4, -10, 2, 4, 6, 7 };
std::sort(values, values + 10, [](float a, float b) {
  return a &lt; b;
});
</code></pre>
<p>This lambda is passed to a std::sort function to sort an array of values by some criteria.</p>
<p>A C++ lambda can (but doesn't have to) capture variables from the enclosing scope if it wishes and it can specify capture clauses in the <code>[]</code> section that define how capture is made. Captures can be by value or reference, and can explicitly list the variables to capture, or specify to capture everything by reference or assignment. A lambda that captures variables effectively becomes a closure.</p>
<pre><code class="language-c++">auto v1 = 10.;
auto v2 = 2.;
// Capture by value
auto multiply = [v1, v2]() { return v1 * v2; };
// Capture by reference
auto sum = [&amp;v1, &amp;v2]() { return v1 + v2; };
cout &lt;&lt; multiply() &lt;&lt; endl;
cout &lt;&lt; sum() &lt;&lt; endl;
v1 = 99; // Now v1 in sum() references 99
cout &lt;&lt; multiply() &lt;&lt; endl;
cout &lt;&lt; sum() &lt;&lt; endl;
</code></pre>
<p>We can see from the output that <code>multiply()</code> has captured copies of the values in <code>v1</code> and <code>v2</code>, whereas <code>sum()</code> captures by reference and so it is sensitive to changes in the variables:</p>
<pre><code>20
12
20
101
</code></pre>
<p>A capture can also specify a default capture mode by specifying <code>=</code> in the capture clause or by reference <code>&amp;</code> and then specify capture behaviour for specific variables.</p>
<p>So our captures above could be simplified to:</p>
<pre><code class="language-c++">// Capture by value
auto multiply = [=]() { return v1 * v2; };
// Capture by reference
auto sum = [&amp;]() { return v1 + v2; };
</code></pre>
<p>Note that C++ lambdas can exhibit dangerous behaviour - if a lambda captures references to variables that go out of scope, the lambda's behaviour is undefined. In practice that could mean the application crashes.</p>
<h2 id="closures-in-rust"><a class="header" href="#closures-in-rust">Closures in Rust</a></h2>
<p>Rust implements closures. A closure is like a lambda except it automatically captures anything it references from the enclosing environment. i.e. by default it can access any variable that is in the enclosing scope.</p>
<p>However it is important to note that using captured variables also limits the closure to the lifetime of the variables it uses. i.e. We could not spawn a thread that uses variables from its enclosing environment because the thread could outlive them.</p>
<p>Here is the same sort snippet we saw in C++ expressed as Rust. This closure doesn't borrow anything from its enclosing scope but it does take a pair of arguments to compare two values for sorting. The <code>sort_by()</code> function repeatedly invokes the closure to sort the array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ord;
let mut values = [ 9.0, 3.0, 2.1, 3.0, 4.0, -10.0, 2.0, 4.0, 6.0, 7.0 ];
values.sort_by(|a, b| a &lt; b );
println!(&quot;values = {:?}&quot;, values);
<span class="boring">}
</span></code></pre></pre>
<p>A closure that uses a variable from the enclosing scope borrows it by default. That means the borrowed variable can't change while the closure is in scope. To change the value we must ensure the closure goes out of scope to free the borrow, e.g. with a block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 100;
{
  let square = || x * x;
  println!(&quot;square = {}&quot;, square());
}
x = 200;
<span class="boring">}
</span></code></pre></pre>
<p>Remember how the closure cannot exist outside the lifetime of the variables it uses from its enclosing environment. If this is a limitation you can <code>move</code> ownership of variables used by the closure so it owns a bitwise copy of them and they become inaccessible from the outerscope. Since our closure was accessing an integer, the move becomes an implicit copy. So our <code>square</code> closure has its own <code>x</code> assigned the value <code>100</code>. Even if we change <code>x</code> in the outer scope to <code>200</code>, the closure has its own independent copy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 100;
let square = move || x * x;
println!(&quot;square = {}&quot;, square()); // 10000
x = 200;
println!(&quot;square = {}&quot;, square()); // 10000
<span class="boring">}
</span></code></pre></pre>
<p>This is the equivalent to the C++ code above that used lambda expressions to bind to copies and references:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v1 = 10.0;
let v2 = 2.0;
let multiply = move || v1 * v2;
let sum = |x: &amp;f64, y: &amp;f64| x + y;
println!(&quot;multiply {}&quot;, multiply());
println!(&quot;sum {}&quot;, sum(&amp;v1, &amp;v2));
v1 = 99.0;
println!(&quot;multiply {}&quot;, multiply());
println!(&quot;sum {}&quot;, sum(&amp;v1, &amp;v2));
<span class="boring">}
</span></code></pre></pre>
<p>This will yield the same results as the C++ code. The main difference here is that rather than binding our closure to a reference, we passed the reference values in as parameters to the closure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates--generics"><a class="header" href="#templates--generics">Templates / Generics</a></h1>
<p>C++ offers templates as a way to write generic code using an abstract type and then specialize it by substituting one or more types into a concrete class.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
inline void debug(const T &amp;v) {
  cout &lt;&lt; &quot;The value of object is &quot; &lt;&lt; v &lt;&lt; endl;
}
//...
debug(10);
</code></pre>
<p>This template uses the type of the parameter (int this case 10) to create an inline function that prints out the value of that type:</p>
<pre><code>The value of object is 10
</code></pre>
<p>Classes can also be made from templates:</p>
<pre><code class="language-c++">template &lt;class T&gt;
class Stack {
private:
  vector&lt;T&gt; elements;
public:
  void push(const T &amp;v) {
    // ...
  }
  T pop() {
    // ...
  }
}
//...
Stack&lt;double&gt; doubleStack;
</code></pre>
<p>This class implements a simple stack using a template to indicate the type of object it contains.</p>
<p>This is a very powerful mechanism and the C++ library makes extensive use of it. </p>
<p>Where templates can become a bit of a mess is that the templates are inline and the compiler will expand out anything you call before attempting to compile it. </p>
<p>An innocuous error such as using a type that has no default copy constructor in a collection can cause the compiler to go nuts and output a wall of indecipherable errors. </p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<p>Rust's equivalent to a template is called a generic. A generic generalizes a function or a trait so it works with different types that match the criteria.</p>
<p>So the Rust equivalent of the <code>debug()</code> function in C++ would be this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

fn debug&lt;T&gt;(data: T) where T: fmt::Display {
  println!(&quot;The value of object is {}&quot;, data);
}
//...
debug(10);
<span class="boring">}
</span></code></pre></pre>
<p>Here we describe a function that takes a generic type <code>T</code> where the constraint is that <code>T</code> must implement the trait <code>std::fmt::Display</code>. Any struct that implements this trait can passed into the call. Since integer types implement the trait, we can just call it directly as <code>debug(10)</code> and the compiler is happy.</p>
<h2 id="generic-structs"><a class="header" href="#generic-structs">Generic structs</a></h2>
<p>Similarly we can use generics on a struct. So the equivalent in Rust of the C++ template class <code>Stack</code> is this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Stack&lt;T&gt; {
  elements: Vec&lt;T&gt;
}

impl&lt;T&gt; Stack&lt;T&gt; {
  fn new() -&gt; Stack&lt;T&gt; { Stack { elements: Vec::new() } }

  fn push(v: T) {
    //...
  }

  fn pop() -&gt; Option&lt;T&gt; {
    //...
    None
  }
}
//...
let double_stack: Stack&lt;f64&gt; = Stack::new();
<span class="boring">}
</span></code></pre></pre>
<h2 id="where-clause"><a class="header" href="#where-clause">Where clause</a></h2>
<p>The <code>where</code> clause can be added to impose constraints on what generic type must do to be allowed to be supplied to the generic function or struct.</p>
<p>For example we might have a function that takes a closure as an argument. A closure is a function and so we want to define the shape that the closure will take.</p>
<p>So:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compare&lt;T, F&gt;(a: T, b: T, f: F) -&gt; bool 
  where F: FnOnce(T, T) -&gt; bool 
{
  f(a, b)
}

let comparer = |a, b| a &lt; b;
let result = compare(10, 20, comparer);
<span class="boring">}
</span></code></pre></pre>
<p>Here we have defined a <code>compare()</code> function that takes a couple of values of the same type. The <code>where</code> clause states that the function must take two values of the same type and return a boolean. The compiler will ensure any closure we pass in matches that criteria, as indeed our <code>comparer</code> closure does.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>C++ has various ways to give compiler <em>directives</em> during compilation:</p>
<ul>
<li>Compile flags that control numerous behaviours</li>
<li><code>#pragma</code> statements - <code>once</code>, <code>optimize</code>, <code>comment</code>, <code>pack</code> etc. Some pragmas such as <code>comment</code> leave a &quot;comment&quot; in the output file that compilers such as Microsoft C++ use to control the import / export of symbols, static linking and other functionality.</li>
<li><code>#define</code> with ubquitous <code>#ifdef</code> / <code>#else</code> / <code>#endif</code> blocks</li>
<li>Keywords <code>inline</code>, <code>const</code>, <code>volatile</code> etc. These keyword hint the code and allow the compiler to make decisions that might change its output or optimization. </li>
<li>Compilers may have their own proprietary extensions, e.g. <code>__declspec</code> is keyword in Microsoft's compiler that allows the behaviour of structs / classes to be modified.</li>
</ul>
<p>Rust uses a notation called <em>attributes</em> that serves a similar role to all of these things but in a more consistent form.</p>
<p>An attribute <code>#[foo]</code> applies to the next item it is declared before. A common attribute is used to denote a unit test case with <code>#[test]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn this_is_a_test() {
  //... this function is marked as a test so &quot;cargo test&quot; will run it
}
<span class="boring">}
</span></code></pre></pre>
<p>Attributes can also be expressed as <code>#![foo]</code> which affects the thing they're contained <em>by</em> rather the thing that follows them. So this is equivalent to the last example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_is_a_test() {
  #![test]
  //... this function is marked as a test so &quot;cargo test&quot; will run it
}
<span class="boring">}
</span></code></pre></pre>
<p>Attributes are enclosed in a <code>#[ ]</code> block and provide compiler directives that allow:</p>
<ul>
<li>Functions to be marked as unit or benchmark tests <code>#[test]</code></li>
<li>Functions to be marked for conditional compilation for a target OS. A function can be defined that only compiles for one target. e.g. perhaps the code that communicates with another process on Windows and Linux is encapsulated in the same function but implemented differently.</li>
<li>Enable / disable lint rules</li>
<li>Enable / disable compiler features. Certain features of rust may be experimental or deprecated and may have to be enabled to be accessed.</li>
<li>Change the entry point function from <code>main</code> to something else</li>
<li>Conditional compilation according to target architecture, OS, family, endianess, pointer width</li>
<li>Inline hinting</li>
<li>Deriving certain traits</li>
<li>Enabling compiler features such as plugins that implement procedural macros.</li>
<li>Importing macros from other crates</li>
<li>Used by certain crates like serde and rocket to instrument code - NB Rocket uses unstable compiler hooks for this and in so doing limits itself to working in nightly builds only. </li>
</ul>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>Conditional compilation allows you to test the target configurations and optionally compile functions or modules in or not. </p>
<p>The main configurations you will test include:</p>
<ul>
<li>Target architecture - &quot;x86&quot;, &quot;x86_64&quot;, mips&quot;, &quot;arm&quot; etc.</li>
<li>Target OS - &quot;windows&quot;, &quot;macos&quot;, &quot;ios&quot;, &quot;linux&quot;, &quot;android&quot;, &quot;freebsd&quot; etc.</li>
<li>Target family - &quot;unix&quot; or &quot;windows&quot;</li>
<li>Target environment - &quot;gnu&quot;, &quot;msvc&quot; etc</li>
<li>Target endianess</li>
<li>Target pointer width</li>
</ul>
<p>So if you have a function which is implemented one way for Windows and another for Linux you might code it like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(windows)]
fn get_app_data_dir() -&gt; String { /* ... */ }

#[cfg(not(windows))]
fn get_app_data_dir() -&gt; String { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>Many more possibilities are listed in the <a href="https://doc.rust-lang.org/reference/attributes.html#crate-only-attributes">documentation</a>.</p>
<h2 id="data-structure-formats"><a class="header" href="#data-structure-formats">Data structure formats</a></h2>
<p>By default, a structure is packed however the compiler chooses. The compiler might even choose to reorder fields to make the data smaller, e.g. if the struct has a lot of booleans interspersed with other types it might pack the booleans together. </p>
<p>But if you are exchanging data with C you might use an attribute to ensure the struct is the correct order, padding and alignment:</p>
<pre><code>#[repr(C)]
struct Data {
  //... 
}
</code></pre>
<p>Or more complex:</p>
<pre><code>#[repr(C, align(8))] {

}
</code></pre>
<p>This fulfills a similar role to <code>__declspec</code> in C++ compilers.</p>
<h2 id="linking-to-native-libraries"><a class="header" href="#linking-to-native-libraries">Linking to native libraries</a></h2>
<p>In C/C++ code is first compiled and then it is linked, either by additional arguments to the compiler, or by invoking a linker.</p>
<p>In Rust most of your linking is taken care for you providing you use <code>cargo</code>. </p>
<ol>
<li>All your sources are compiled and linked together. </li>
<li>External crates are automatically built as static libs and linked in. </li>
<li>But if you have to link against something external through FFI you have to write a <code>#link</code> directive in your <code>lib.rs</code> or <code>main.rs</code>. This is somewhat analogous to the <code>#pragma(comment, &quot;somelib&quot;)</code> in C++.</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>#pragma (comment, &quot;somelib&quot;)</code></td><td><code>#[link(name = &quot;somelib&quot;)]</code></td></tr>
<tr><td>-</td><td><code>#[link(name = &quot;somelib&quot;, kind = &quot;static&quot;)]</code></td></tr>
</tbody></table>
</div>
<p>The default kind for <code>#link</code> is <code>dynamic</code> library but <code>static</code> can be explicitly stated specified.</p>
<h2 id="inlining-code"><a class="header" href="#inlining-code">Inlining code</a></h2>
<p>Inlining happens where your function logic is inserted in-place to the code that invokes it. Usually you want inlining when the function does something trivial such as return a value or execute a simple conditional. The overhead of duplicating the code is outweighed by the performance benefit.</p>
<p>Inlining is achieved in C++ by declaring and implementing a function, class method or template method in a header or marking it with the inline keyword.</p>
<p>In Rust, inlining is only a hint. Rust recommends not forcing inlning, rather leaving it as a hint for the LLVM compiler to do with as it sees fit.</p>
<div class="table-wrapper"><table><thead><tr><th>C++</th><th>Rust</th></tr></thead><tbody>
<tr><td>Explicitly with <code>inline</code> or implicitly through methods implemented in class or  struct</td><td><code>#[inline]</code>, <code>#[inline(always)]</code>, <code>#[inline(never)]</code></td></tr>
</tbody></table>
</div>
<p>Another alternative to explicitly inlining code is to use the link-time optimisation in LLVM.</p>
<pre><code>rustc -C lto
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h1>
<p>Multithreading allows you to run parts of your programming concurrently, performing tasks in parallel. Every program has a <em>main</em> thread - i.e. the one your <code>main()</code> started from, in addition to which are any that you create.</p>
<p>Examples of reasons to use threads:</p>
<ul>
<li>Long running operations, e.g. zipping up a large file.</li>
<li>Activity that is blocking in nature, e.g. listening for connections on a socket</li>
<li>Processing data in parallel, e.g. physics, collision detection etc.</li>
<li>Asynchronous activities, e.g. timers, polling operations.</li>
</ul>
<p>In addition, if you use a graphical toolkit, or 3rd party libraries they may spawn their own threads that you do not know about. </p>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread safety</a></h2>
<p>One word you will hear a lot in multithreading is thread safety. </p>
<p>By that we mean:</p>
<ul>
<li>Threads should not be able to modify the data at the same time. When this happens it is called a data race and can corrupt the data, causing a crash. e.g. two threads trying to append to a string at the same time.</li>
<li>Threads must not lock resources in a way that could cause deadlock i.e. thread 1 obtains a lock on resource B and blocks on resource A, while thread 2 obtains a lock on resource A and blocks on resource B. Both threads are locked forever waiting for a resource to release that never will be.</li>
<li>Race conditions are bad, i.e. the order of thread execution produces unpredictable results on the output from the same input.</li>
<li>APIs that can be called by multiple threads must either protect their data structures or make it an explicit problem of the client to sort out.</li>
<li>Open files and other resources that are accessed by multiple threads must be managed safely.</li>
</ul>
<h3 id="protecting-shared-data"><a class="header" href="#protecting-shared-data">Protecting shared data</a></h3>
<p>Data should never be read at the same time it is written to in another thread. Nor should data be written to at the same time by two threads.</p>
<p>The common way to prevent this is either:</p>
<ul>
<li>Use a mutex to guard access to the data. A mutex is a special class that only one thread can lock at a time. Other threads that try to lock the mutex will wait until the lock held by another thread is relinquished</li>
<li>Use a read-write lock. Similar to a mutex, it allows one thread to lock the thread for writing data, however it permits multiple threads to have read access, providing nothing is already writing to it. For data that is read more frequently than it is modified, this is a lot more efficient than just a mutex.</li>
</ul>
<h3 id="avoiding-deadlock"><a class="header" href="#avoiding-deadlock">Avoiding deadlock</a></h3>
<p>The best way to avoid deadlock is only ever obtain a lock to one thing ever and release it as soon as you are done. But if you have to lock more than one thing, ensure the locking order is consistent between all your threads. So if thread 1 locks A and B, then ensure that thread 2 also locks A and B in that order and not B then A. The latter is surely going to cause a deadlock.</p>
<h2 id="c--c-2"><a class="header" href="#c--c-2">C / C++</a></h2>
<p>C and C++ predate threading to some extent so until C++11 the languages have had little built-in support for multi-threading and what there was tended to be compiler specific extensions.</p>
<p>A consequence of this is that C and C++ have ZERO ENFORCEMENT of thread safety. If you data race - too bad. If you forget to write a lock in one function even if you remembered all the others - too bad. You have to discipline yourself to think concurrently and apply the proper protections where it is required. </p>
<p>The consequence of not doing so may not even be felt until your software is in production and that one customer starts complaining that their server freezes about once a week. Good luck finding that bug!</p>
<h3 id="multithreading-apis"><a class="header" href="#multithreading-apis">Multithreading APIs</a></h3>
<p>The most common APIs would be:</p>
<ul>
<li><code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code> - from C++11 onwards</li>
<li>POSIX threads, or pthreads. Exposed by POSIX systems such as Linux and most other Unix derivatives, e.g. OS X. There is also pthread-win32 support built over the top of Win32 threads.</li>
<li>Win32 threads. Exposed by the Windows operating system.</li>
<li>OpenMP. Supported by many C++ compilers.</li>
<li>3rd party libraries like Boost and Qt provide wrappers that abstract the differences between thread APIs. </li>
</ul>
<p>All APIs will have in common:</p>
<ul>
<li>Thread creation, destruction, joins (waiting on threads) and detaches (freeing the thread to do what it likes).</li>
<li>Synchronization between threads using locks and barriers.</li>
<li>Mutexes - mutual exclusion locks that protect shared data.</li>
<li>Conditional variables - a means to signal and notify of conditions becoming true.</li>
</ul>
<h3 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h3>
<p>The <code>std::thread</code> represents a single thread of execution and provides an abstraction over platform dependent ways of threading.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void DoWork(int loop_count) {
    for (int i = 0; i &lt; loop_count; ++i) {
        cout &lt;&lt; &quot;Hello world &quot; &lt;&lt; i &lt;&lt; endl;
    }
}

int main() {
    thread worker(DoWork, 100);
    worker.join();
}
</code></pre>
<p>The example spawns a thread which invokes the function and passes the parameter into it, printing a message 100 times.</p>
<h3 id="stdmutex"><a class="header" href="#stdmutex">std::mutex</a></h3>
<p>C++ provides a family of various <code>mutex</code> types to protect access to shared data.</p>
<p>The mutex is obtained by a <code>lock_guard</code> and other attempts to obtain the mutex are blocked until the lock is relinquished.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

using namespace std;

mutex data_guard;
int result = 0;

void DoWork(int loop_count) {
	for (auto i = 0; i &lt; loop_count; ++i) {
		lock_guard&lt;mutex&gt; guard(data_guard);
		result += 1;
	}
}

int main() {
	thread worker1(DoWork, 100);
	thread worker2(DoWork, 150);
	worker1.join();
	worker2.join();
	cout &lt;&lt; &quot;result = &quot; &lt;&lt; result &lt;&lt; endl;
}
</code></pre>
<h3 id="posix-threads"><a class="header" href="#posix-threads">POSIX threads</a></h3>
<p>The pthreads API is prefixed <code>pthread_</code> and works like so:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;

using namespace std;

void *DoWork(void *data) {
    const int loop_count = (int) data;
    for (int i = 0; i &lt; loop_count; ++i) {
        cout &lt;&lt; &quot;Hello world &quot; &lt;&lt; i &lt;&lt; endl;
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t worker_thread;
    int result = pthread_create(&amp;worker_thread, NULL, DoWork, (void *) 100);
    // Wait for the thread to end
    result = pthread_join(worker_thread, NULL);
}
</code></pre>
<p>This example spawns a thread which invokes DoWork with the payload of 100 which causes the function to print a message 100 times.</p>
<h3 id="win32-threads"><a class="header" href="#win32-threads">Win32 Threads</a></h3>
<p>Win32 threading has functions analogous to those in POSIX. They have names such as <code>CreateThread</code>, <code>ExitThread</code>, <code>SetThreadPriority</code> etc.</p>
<h3 id="openmp-api"><a class="header" href="#openmp-api">OpenMP API</a></h3>
<p>Open Multi-Processing (OpenMP) is an API for multi-threaded parallel processing. OpenMP relies on compiler support because you use special <code>#pragma</code> directives in your source to control thread creation and access to data.</p>
<p>GCC, Clang and Visual C++ have support for OpenMP so it is an option.</p>
<p>OpenMP is a complex standard but the use of directives can make for cleaner code than invoking threading APIs directly. The downside is it is also more opaque hiding what the software is doing, making it considerably more difficult to debug.</p>
<p>OpenMP is described in detail at the OpenMP <a href="http://www.openmp.org/">website</a>.</p>
<h3 id="thread-local-storage"><a class="header" href="#thread-local-storage">Thread local storage</a></h3>
<p>Thread local storage, or TLS is static or global data which is private to every thread. Each thread holds its own copy of this data so it can modify it without fear of causing a data race.</p>
<p>Compilers also have proprietary ways to decorate types as thread local:</p>
<pre><code class="language-c++">__thread int private; // gcc / clang
__declspec(thread) int private; // MSVC
</code></pre>
<p>C++11 has gained a <code>thread_local</code> directive to decorate variables which should use TLS.</p>
<pre><code class="language-c++">thread_local int private
</code></pre>
<h2 id="rust-13"><a class="header" href="#rust-13">Rust</a></h2>
<p>We saw with C++ that you had to be disciplined to remember to protect data from race conditions. </p>
<p>Rust doesn't give you that luxury -</p>
<ol>
<li>Any data that you share must be protected in a thread safe fashion</li>
<li>Any data that you pass between threads must be marked thread safe</li>
</ol>
<h3 id="spawning-a-thread"><a class="header" href="#spawning-a-thread">Spawning a thread</a></h3>
<p>Spawning a thread is easy enough by calling <code>spawn</code>, supplying the closure you want to run in the context of your new thread.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

thread::spawn(move || {
  println!(&quot;Hello&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively you can supply a function to <code>spawn</code> which is called in the same manner.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_thread() {
  println!(&quot;Hello&quot;);
}
//...
thread::spawn(my_thread);
<span class="boring">}
</span></code></pre></pre>
<p>If you supply a closure then it must have a lifetime of <code>'static</code> because threads can outlive the thing that created them. i.e. they are detached by default. </p>
<p>A closure can make use of move values that are marked <code>Send</code> so the compiler allows ownership to transfer between threads.</p>
<p>Likewise function / closure may also return a value which is marked <code>Send</code> so the compiler can transfer ownership between the terminating thread and the thread which calls <code>join</code> to obtain the value.</p>
<p>So the thread above is detached. If we wanted to wait for the thread to complete, the <code>spawn</code> returns a <code>JoinHandle</code> that we can call <code>join</code> to wait for termination.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let h = thread::spawn(move || {
  println!(&quot;Hello&quot;);
});
h.join();
<span class="boring">}
</span></code></pre></pre>
<p>If the closure or function returns a value, we can use <code>join</code> to obtain it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let h = thread::spawn(move || 100 * 100);
let result = h.join().unwrap();
println!(&quot;Result = {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<h3 id="data-race-protection-in-the-compiler"><a class="header" href="#data-race-protection-in-the-compiler">Data race protection in the compiler</a></h3>
<p>Data races are bad news, but fortunately in Rust the compiler has your back. You MUST protect your shared data or it won't compile.</p>
<p>The simplest way to protect your data is to wrap the data in a mutex and provide each thread instance with a reference counted copy of the mutex.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shared_data = Arc::new(Mutex::new(MySharedData::new()));

// Each thread we spawn should have a clone of this Arc
let shared_data = shared_data.clone();
thread::spawn(move || {
  let mut shared_data = shared_data.lock().unwrap();
  shared_data.counter += 1;
});
<span class="boring">}
</span></code></pre></pre>
<p>Here is a full example that spawns 10 threads that each increment the counter.</p>
<pre><pre class="playground"><code class="language-rust">struct MySharedData {
  pub counter: u32,
}

impl MySharedData {
  pub fn new() -&gt; MySharedData {
    MySharedData {
	  counter: 0
	}
  }
}

fn main() {
  spawn_threads();
}

fn spawn_threads() {
  let shared_data = Arc::new(Mutex::new(MySharedData::new()));
  
  // Spawn a number of threads and collect their join handles
  let handles: Vec&lt;JoinHandle&lt;_&gt;&gt; = (0..10).map(|_| {
	let shared_data = shared_data.clone();
    thread::spawn(move || {
	  let mut shared_data = shared_data.lock().unwrap();
	  shared_data.counter += 1;
	})
  }).collect();
  
  // Wait for each thread to complete
  for h in handles {
    h.join();
  }
  
  // Print the data
  let shared_data = shared_data.lock().unwrap();
  println!(&quot;Total = {}&quot;, shared_data.counter);
}
</code></pre></pre>
<p>So the basic strategy will be this:</p>
<ol>
<li>Every thread will get it's own atomic reference to the mutex. </li>
<li>Each thread that wishes to access the shared must obtain a lock on the mutex.</li>
<li>Once the lock is released, the next waiting thread can obtain access.</li>
<li>The compiler will enforce this and generate errors if ANYTHING is wrong.</li>
</ol>
<h3 id="read-write-lock"><a class="header" href="#read-write-lock">Read Write Lock</a></h3>
<p>A read write lock works much like a mutex - we wrap the shared data in a <code>RwLock</code>, and then in an <code>Arc</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shared_data = Arc::new(RwLock::new(MySharedData::new()));
<span class="boring">}
</span></code></pre></pre>
<p>Each thread will then either need to obtain a read lock or a write lock on the shared data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shared_data = shared_data.read().unwrap();
// OR
let mut shared_data = shared_data.write().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The advantage of a <code>RwLock</code> is that many threads can concurrently read the data, providing nothing is writing to it. This may be more efficient in many cases.</p>
<h3 id="sending-data-between-threads-using-channels"><a class="header" href="#sending-data-between-threads-using-channels">Sending data between threads using channels</a></h3>
<p>TODO mpsc channel</p>
<h3 id="thread-local-storage-1"><a class="header" href="#thread-local-storage-1">Thread local storage</a></h3>
<p>As with C++ you may have reason to use thread local storage</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread_local! {
  // TODO
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="useful-crates"><a class="header" href="#useful-crates">Useful crates</a></h3>
<h4 id="rayon"><a class="header" href="#rayon">Rayon</a></h4>
<p>The <a href="https://github.com/rayon-rs/rayon">rayon</a> crate implements parallel iterators that allow your collections to be iterated in parallel. The crate
utilises work stealing and divide and conquer algorithms couple to a thread pool to process collections more quickly
than they could be in a sequential fashion.</p>
<p>Generally speaking this is a drop-in replacement with the exception that you call <code>par_iter</code> instead of <code>iter</code>. The crate
implements a <code>ParallelIterator</code> trait on collection classes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;
fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.par_iter()
         .map(|&amp;i| i * i)
         .sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>See the crate site for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lint"><a class="header" href="#lint">Lint</a></h1>
<p>C/C++ compilers can issue many useful warnings but the amount of static analysis they can do is usually quite limited.</p>
<p>The Rust compiler performs a far more rigorous lifecycle check on data and then follows up with a lint check that inspects your code for potentially bad or erroneous</p>
<p>In particular it looks for:</p>
<ul>
<li>Dead / unused code</li>
<li>Unreachable code</li>
<li>Deprecated methods</li>
<li>Undocumented functions</li>
<li>Camel case / snake case violations</li>
<li>Unbounded recursion code (i.e. no conditionals to stop recursion)</li>
<li>Use of heap memory when stack could be used</li>
<li>Unused extern crates, imports, variables, attributes, mut, parentheses</li>
<li>Using &quot;while true {}&quot; instead of &quot;loop {}&quot;</li>
</ul>
<p>Lint rules can be enforced more strictly or ignored by using attributes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(rule)]
#[warn(rule)]
#[deny(rule)]
#[forbid(rule)]
<span class="boring">}
</span></code></pre></pre>
<p>A full list of lint rules can be found by typing &quot;rustc -W help&quot;:</p>
<pre><code>                         name  default  meaning
                         ----  -------  -------
                box-pointers   allow    use of owned (Box type) heap memory
           fat-ptr-transmutes  allow    detects transmutes of fat pointers
 missing-copy-implementations  allow    detects potentially-forgotten implementations of `Copy`
missing-debug-implementations  allow    detects missing implementations of fmt::Debug
                 missing-docs  allow    detects missing documentation for public members
                trivial-casts  allow    detects trivial casts which could be removed
        trivial-numeric-casts  allow    detects trivial casts of numeric types which could be removed
                  unsafe-code  allow    usage of `unsafe` code
...
</code></pre>
<p>There are a lot more checks than listed above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<h2 id="c--c-preprocessor"><a class="header" href="#c--c-preprocessor">C / C++ Preprocessor</a></h2>
<p>C languages are little unusual in that they are compiled in two phases. The first phase is called the preprocess. In this phase, the preprocessor looks for directives starting with a # symbol and runs string substitution and conditional inclusion / exclusion based on those directives. Only after the file has been preprocessed does the compiler attempt to compile it.</p>
<p>Preprocessor directives start with a <code>#</code> symbol. For example the <code>#define</code> directive creates a macro with an optional value:</p>
<pre><code class="language-c++">#define IS_WINDOWS
#define SHAREWARE_VERSION 1
</code></pre>
<p>We'll explore macros more in a moment. Another directive is the <code>#if\#else\#endif</code> or <code>#ifdef\#else\#endif</code> which can be used to include code from one branch or the other of a test according to what matches.</p>
<pre><code class="language-c++">#if SHAREWARE_VERSION == 1
showNagwarePopup();
#endif
//...
#ifdef IS_WINDOWS
writePrefsToRegistry();
#else
writePrefsToCfg();
#endif
</code></pre>
<p>Another directive is <code>#include</code>. In C and C++, public functions and structures are typically defined and implemented in separate files. The <code>#include</code> directive allows a header to be pulled in to the front of any file that makes use of those definitions.</p>
<pre><code class="language-c++">// System / external headers tend to use angle style
#include &lt;string&gt;
#include &lt;stdio.h&gt;

// Local headers tend to use double quotes
#include &quot;MyClass.h&quot;
</code></pre>
<p>The important thing to remember in all of this is ALL of these things happen before the compiler even starts! Your <code>main.c</code> might only be 10 lines of code but if you <code>#include</code> some headers the preprocessor may be feeding many thousands of lines of types, functions into the compiler, all of which are evaluated before they get to your code.</p>
<h2 id="c--c-macros"><a class="header" href="#c--c-macros">C / C++ Macros</a></h2>
<p>Macros are string substitution patterns performed by the preprocessor before the source is compiled. As such they can be very prone to error and so have been deprecated in favour of constants and inline functions.</p>
<p>Here is a simple macro that would behave in an unexpected manner:</p>
<pre><code class="language-c++">#define MULTIPLY(x, y) x * y
//
int x = 10, y = 20;
int result = MULTIPLY(x + 1, x + y);
// Value is NOT 330 (11 * 30), it's 41 because macro becomes x + 1 * x + y
</code></pre>
<p>The macro is very simple - multiply x by y. But it fails if either argument is an expression. Judicious use of parentheses might avoid the error in this case, but we could break it again using some pre or post increments.</p>
<p>Macros in C++ are also unhygenic, i.e. the macro can inadvertently conflict with or capture values from outside of itself causing errors in the code.</p>
<pre><code class="language-c++">#define SWAP(x, y) int tmp = y; y = x; x = y;
//
int tmp = 10;
int a = 20, b = 30;
SWAP(a, b); // ERROR
</code></pre>
<p>Here our SWAP macro uses a temporary value called <code>tmp</code> that already existed in the scope and so the compiler complains. A macro might avoid this by using shadow variables enclosed
within a <code>do / while(0)</code> block to avoid conflicts but it is less than ideal.</p>
<pre><code class="language-c++">#define SWAP(x, y) do { int tmp = y; y = x; x = y } while(0);
</code></pre>
<p>Consequently inline functions are used wherever possible. Even so macros are still frequently used in these roles:</p>
<ul>
<li>To conditionally include for a command-line flag or directive, e.g. the compiler might <code>#define WIN32</code> so code can conditionally compile one way or another according to its presence.</li>
<li>For adding guard blocks around headers to prevent them being #include'd more than once. Most compilers implement a &quot;#pragma once directive&quot; which is an increasingly common alternative</li>
<li>For generating snippets of boiler plate code (e.g. namespace wrappers), or things that might be compiled away depending on #defines like DEBUG being set or not.</li>
<li>For making strings of values and other esoteric edge cases</li>
</ul>
<p>Writing a macro is easy, perhaps too easy:</p>
<pre><code class="language-c++">#define PRINT(x) \
  printf(&quot;You printed %d&quot;, x);
</code></pre>
<p>This macro would expand to printf before compilation but it would fail to compile or print the wrong thing if x were not an integer.</p>
<h2 id="rust-macros"><a class="header" href="#rust-macros">Rust macros</a></h2>
<p>Macros in Rust are quite a complex topic but they are more powerful and safer than the ones in C++.</p>
<ul>
<li>Rust macros are hygenic. That is to say if a macro contains variables, their names do not conflict with, hide, or otherwise interfere with named variables from the scope they're used from.</li>
<li>The pattern supplied in between the brackets of the macro are tokenized and designated as parts of the Rust language. identifiers, expressions etc. In C / C++ you can #define a macro to be anything you like whether it is garbage or syntactically correct. Furthermore you can call it from anywhere you like because it is preprocessed even before the compiler sees the code.</li>
<li>Rust macros are either declarative and rule based with each rule having a left hand side pattern &quot;matcher&quot; and a right hand side &quot;substitution&quot;. Or they're procedural and actualy rust code turns an input into an output (see section below).</li>
<li>Macros must produce syntactically correct code.</li>
<li>Declarative macros can be exported by crates and used in other code providing the other code elects to enable macro support from the crate. This is a little messy since it must be signalled with a #[macro_export] directive.</li>
</ul>
<p>With all that said, macros in Rust <em>are</em> complex - perhaps too complex - and generally speaking should be used as sparingly as possible.</p>
<p>Here is a simple declarative macro demonstrating repetition called hello_x!(). It will take a comma separated list of expressions and say hello to each one of them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! hello_x {
  ($($name:expr),*) =&gt; (
    $(println!(&quot;Hello {}&quot;, $name);)*
  )
}
// The code can supply as many arguments it likes to this macro
hello_x!(&quot;Bob&quot;, &quot;Sue&quot;, &quot;John&quot;, &quot;Ellen&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Essentially the matcher matches against our comma separate list and the substitution generates one println!() with the message for each expression.</p>
<pre><code>Hello Bob
Hello Sue
Hello John
Hello Ellen
</code></pre>
<p>What if we threw some other expressions into that array?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>hello_x!(&quot;Bob&quot;, true, 1234.333, -1);
<span class="boring">}
</span></code></pre></pre>
<p>Well that works too:</p>
<pre><code>Hello Bob
Hello true
Hello 1234.333
Hello -1
</code></pre>
<p>What about some illegal code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>hello_x!(Aardvark {});
<span class="boring">}
</span></code></pre></pre>
<p>We get a meaningful error originating from the macro.</p>
<pre><code>error[E0422]: `Aardvark` does not name a structure
  |
8 | hello_x!(Aardvark {});
  |          ^^^^^^^^
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
&lt;anon&gt;:5:7: 5:35 note: in this expansion of println! (defined in &lt;std macros&gt;)
&lt;anon&gt;:8:1: 8:23 note: in this expansion of hello_x! (defined in &lt;anon&gt;)
</code></pre>
<h2 id="real-world-example---vec"><a class="header" href="#real-world-example---vec">Real world example - vec!()</a></h2>
<p>Rust comes with a lot of macros for reducing some of the leg work of tedious boiler plate. For example the vec!() macro is a way to declare a std::Vec and prepopulate it with some values.</p>
<p>Here is the actual vec! macro source code taken from the Rust source:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! vec {
    ($elem:expr; $n:expr) =&gt; (
        $crate::vec::from_elem($elem, $n)
    );
    ($($x:expr),*) =&gt; (
        &lt;[_]&gt;::into_vec(box [$($x),*])
    );
    ($($x:expr,)*) =&gt; (vec![$($x),*])
}
<span class="boring">}
</span></code></pre></pre>
<p>It looks complex but we will break it down to see what it does. Firstly it has a match-like syntax with three branches that expand to anything that matches the left hand side:</p>
<h3 id="first-branch"><a class="header" href="#first-branch">First branch</a></h3>
<p>The first matcher matches a pattern such as <code>1; 100</code>. The value <code>1</code> goes into <code>$elem</code>, the value <code>100</code> goes into <code>$n</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>($elem:expr; $n:expr) =&gt;  (
        $crate::vec::from_elem($elem, $n)
    );
<span class="boring">}
</span></code></pre></pre>
<p>The <code>$crate</code> is a special value that resolves to the module crate which happens to be std.</p>
<p>So this expands to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!(1; 100);
// 1st branch matches and it becomes this
let v = std::vec::from_elem(1, 100);
<span class="boring">}
</span></code></pre></pre>
<h3 id="second-branch"><a class="header" href="#second-branch">Second branch</a></h3>
<p>The second matcher contains a glob expression - zero or more expressions separated by comma (the last comma is optional). Each matching expression ends up in <code>$x</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>($($x:expr),*) =&gt; (
        &lt;[_]&gt;::into_vec(box [$($x),*])
    );
<span class="boring">}
</span></code></pre></pre>
<p>So we can write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!(1, 2, 3, 4, 5);
// 3nd branch matches and it becomes this
let v = &lt;[_]&gt;::into_vec(box [1, 2, 3, 4, 5]);
<span class="boring">}
</span></code></pre></pre>
<p>The box keyword tells Rust to allocate the supplied array on the heap and moves the ownership by calling a helper function called into_vec() that wraps the memory array with a Vec instance. The &lt;[_]&gt;:: at the front is a turbo-fish notation to make the into_vec() generic function happy.</p>
<h3 id="third-branch"><a class="header" href="#third-branch">Third branch</a></h3>
<p>The third branch is a little odd and almost looks the same as the second branch. But take at look the comma. In the last branch it was next to the asterisk, this time it is inside the inner $().</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>($($x:expr,)*) =&gt; (vec![$($x),*])
<span class="boring">}
</span></code></pre></pre>
<p>The matcher matches when the the comma is there and if so recursively calls vec!() again to resolve to the second branch matcher:</p>
<p>Basically it is there so that there can be a trailing comma in our declaration and it will still generate the same code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd branch matches this
let v = vec!(1, 2, 3, 4, 5,);
// and it becomes this
let v = vec!(1, 2, 3, 4, 5);
// which matches 2nd branch to become
let v = &lt;[_]&gt;::into_vec(box [1, 2, 3, 4, 5]);
<span class="boring">}
</span></code></pre></pre>
<h2 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h2>
<p>So far we've talked about declarative macros that expand out to be Rust code based upon how they pattern match the rules defined by the macro.</p>
<p>A second kind of macro is the <em>procedural macro</em>. A procedural macro is a plugin written in Rust that is compiled and loaded by the compiler to produce arbitrary Rust code as its output.</p>
<p>A procedural macro can therefore be thought of as a code generator but one that forms part of the actual compiler. Procedural macros can be particularly useful for:</p>
<ul>
<li>Serialization / deserialization (e.g. the <a href="https://github.com/serde-rs/serde">serde</a> module generates code for reading and writing structs to a variety of formats - JSON, YAML, TOML, XML etc.)</li>
<li>Domain Specific Languages (e.g. embedded SQL, regular expressions etc).</li>
<li>Aspect oriented programming (e.g. extra debugging, performance metrics etc)</li>
<li>New lint and derive rules</li>
</ul>
<p>For more information look at this section on <a href="https://doc.rust-lang.org/book/compiler-plugins.html">compiler plugins</a> in the Rust book.</p>
<h2 id="other-forms-of-conditional-compilation"><a class="header" href="#other-forms-of-conditional-compilation">Other forms of conditional compilation</a></h2>
<p>We saw that the C / C++ preprocessor can be used for conditional compilation. The equivalent in Rust is attributes. See the attributes section to see how they may be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-allocation"><a class="header" href="#memory-allocation">Memory allocation</a></h1>
<p>This section is concerned with memory allocation, i.e. creating objects that reside on the heap and not on the stack, and the manner in which they are created and are destroyed.</p>
<h2 id="c-10"><a class="header" href="#c-10">C++</a></h2>
<p>C and C++ have various standard ways to allocate memory:</p>
<ol>
<li><code>malloc</code>/<code>calloc</code>/<code>realloc()</code> and <code>free()</code> functions</li>
<li><code>new</code> and <code>delete</code> (C++ only)</li>
<li><code>new[]</code> and <code>delete[]</code> for arrays (C++ only)</li>
</ol>
<p>Invoking <code>malloc()</code>/<code>free()</code> on a C++ class or struct is never a good idea since it will not call the corresponding class constructor or destructor. The <code>realloc()</code> function allocates a new piece of memory, copying the contents of an existing piece of memory before freeing the original.</p>
<pre><code class="language-c++">// malloc / free
char *buffer = (char *) malloc(1024);
...
free(buffer);
// new / delete
Stack *stack = new Stack();
...
delete stack;
// new[] / delete[]
Node *nodes = new Node[100];
...
delete []nodes;
</code></pre>
<p>In each case the allocation must be matched by the corresponding free action so immediately we can see scope for error here:</p>
<ol>
<li>Ownership rules can get messy, especially when a class is passed around a lot - who deletes the object and when?</li>
<li>Not using the correct <code>new</code> &amp; <code>delete</code> pair, causing a memory leak. e.g. calling <code>delete</code> instead of <code>delete[]</code></li>
<li>Forgetting to free memory at all causing a memory leak.</li>
<li>Freeing memory more than once.</li>
<li>Calling a dangling pointer, i.e. a pointer which refers to freed memory.</li>
<li>Allocating / freeing in a way that causes heap fragmentation. Reallocation can cause fragmentation to happen a lot faster.</li>
</ol>
<p>C++ has smart pointers which manage the lifetime on objects and are a good way to programmer error:</p>
<pre><code class="language-c++">{
  std::auto_ptr&lt;Database&gt; db(new Database());
  //... object is deleted when db goes out of scope
}

// C++11
{
  std::unique_ptr&lt;Database&gt; db(new Database());
  //... object is deleted when db goes out of scope

  std::unique_ptr&lt;Node[]&gt; nodes&lt;new Node[100]);
  //... arrays of objects are supported too
}

// C++11
{
  std::shared_ptr&lt;Database&gt; db(new Database());
  // Reference count db
  setDatabase(db);
  //... object is deleted when last shared_ptr reference to it goes out of scope

  std::shared_ptr&lt;Node[]&gt; nodes&lt;new Node[100]);
  //... arrays of objects are supported too
}
</code></pre>
<p>Unfortunately it is not always possible to use smart pointers but wherever possible they should be used.</p>
<h3 id="other-ways-of-allocating-memory"><a class="header" href="#other-ways-of-allocating-memory">Other ways of allocating memory</a></h3>
<p>Virtually every C and C++ library has solutions for managing memory. They all their own indivual concept of ownership which is usually different from one to the next. Boost and Qt have their own memory management &quot;smart&quot; pointers. Qt even requires certain objects to be deleted &quot;later&quot; by a message processing loop on the thread that created the object. Some libraries even adopt a COM-like model of reference counting objects with smart pointers. Most C libraries will expose an alloc and free function for creating and destroying context objects that callers pass to the API.</p>
<p>Memory allocation can even be overwritten and replaced in some circumstances. In C, the standard malloc / free can be substituted for another memory allocator, e.g. TCMalloc
<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a>. Or perhaps the code wants to use garbage collected memory in which case <a href="http://www.hboehm.info/gc/">Bohem GC</a> is a popular library for that purpose. Boehm can also be used for leak detection since it can find objects which were never released. C++ can also <a href="http://en.cppreference.com/w/cpp/memory/new/operator_new">override</a> the global or class specific new / delete operators. Some standard C++ template classes also allow memory allocation to be overridden.</p>
<h2 id="rust-14"><a class="header" href="#rust-14">Rust</a></h2>
<p>As you can guess by now Rust tends to be a lot more strict about allocation that C/C++. Lifetimes of objects are tracked and enforced by the compiler and that includes memory allocated objects.</p>
<p>In normal safe programming there is no explicit new / delete so there is no way to forget to free an object. There are no pointers either so code cannot call a dangling pointer or inadvertently call a null pointer.</p>
<ol>
<li>A <code>Box</code> is a managed pointer that holds a heap allocated object. A box cannot be cloned, so there is only one owner at any time.</li>
<li>A <code>Cell</code> is a mutable memory location - it can hold any kind of copyable type and the value within it can be changed.</li>
<li>A <code>RefCell</code> is a mutable memory location that can hold a reference</li>
</ol>
<p>The advantage for programmers, is that once you define the lifetime of an object properly it just comes into existence and goes away correctly. In many cases this lifetime management comes with zero runtime cost, or if there is a cost it is no more than the same code correctly written in C/C++.</p>
<p>Rust requires most heap allocated memory to be contained by one or more of the structs below. The struct manages the lifetime and access to the object inside ensuring the lifetime is managed correctly.</p>
<h3 id="box"><a class="header" href="#box">Box<T></a></h3>
<p>A <code>Box</code> is memory managed on the heap. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Blob {
  data: Box&lt;[u8; 16384]&gt;
}

impl Blob {
  pub fn new() {
    Efficient {
      data: Box::new([0u8; 16384])
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Whoever owns the box can access it. Essentially, that means you can pass the box around from one place to another and whatever binds to it last can open it. Everyone elseâ€™s binding becomes invalid and will generate a compile error.</p>
<p>A box can be useful for abstraction since it can refer to a struct by a trait it implements allowing decoupling between types.</p>
<p>TODO example of a struct holding a box with a trait implemented by another struct</p>
<p>It can be useful for situations where one piece of code creates an object on behalf of another piece of code and hands it over. The Box makes sure that the ownership is explicit at all times and when the box moves to its new owner, so does the lifetime of the object itself.</p>
<h3 id="cell"><a class="header" href="#cell">Cell<T></a></h3>
<p>A <code>Cell</code> is something that can copied with a <code>get()</code> or <code>set()</code> to overwrite its own copy. As the contents must be copyable they must implement the Copy trait.</p>
<p>The <code>Cell</code> has a zero-cost at runtime because it doesnâ€™t have to track borrows but the restriction is it only works on Copy types. Therefore it would not be suitable for large objects or deep-copy objects.</p>
<h3 id="refcell"><a class="header" href="#refcell">RefCell<T></a></h3>
<p>Somewhat more useful is the <code>RefCell&lt;T&gt;</code> but it incurs a runtime penalty to maintain read-write locks.</p>
<p>The <code>RefCell</code> holds a reference to an object that can be borrowed either mutably or immutably. These references are read-write locked so there is a runtime cost to this since the borrow must check if something else has already borrowed the reference.</p>
<p>Typically a piece of code might borrow the reference for a scope and then the borrow disappears when it goes out of scope. If a borrow happens before the last borrow releases, it will cause a panic.</p>
<h2 id="reference-counting-objects"><a class="header" href="#reference-counting-objects">Reference Counting objects</a></h2>
<p>Rust implements <code>Rc&lt;&gt;</code> and <code>Arc&lt;&gt;</code> for the purpose of reference counting objects that need to be shared and used by different parts of code. Rc&lt;&gt; is a single threaded reference counted wrapper, while <code>Arc&lt;&gt;</code> is atomic reference counted wrapper. You use one or the other depending on whether threads are sharing the object.</p>
<p>A reference counted object is usually wrapping a <code>Box</code>, <code>Cell</code> or <code>Refcell</code>. So multiple structs can hold a reference to the same object.</p>
<h3 id="rc"><a class="header" href="#rc">Rc<T></a></h3>
<p>From <code>std::rc::Rc</code>. A reference counted object can be held by multiple owners at a time. Each own holds a cloned <code>Rc&lt;T&gt;</code> but the T contents are shared. The last reference to the object causes the contents to be destroyed.</p>
<h3 id="arc"><a class="header" href="#arc">Arc<T></a></h3>
<p>From <code>std::sync::Arc</code>. An atomic reference counted object that works like <code>Rc&lt;T&gt;</code> except it uses an atomically incremented counter which makes it thread safe. There is more overhead to maintain an atomic reference count. If multiple threads access the same object they are compelled to use <code>Arc&lt;T&gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-function-interface-1"><a class="header" href="#foreign-function-interface-1">Foreign Function Interface</a></h1>
<p>Rust doesn't work in a vaccum and was never intended as such. Instead it was always assumed that it would need to call other code and other code would need to call it,</p>
<ul>
<li>Call other libraries via their entry points</li>
<li>Produce C ABI libraries in Rust that can be called by code written in another language. e.g. C, C++, Python, Ruby etc.</li>
</ul>
<p>To that end it has the Foreign Function Interface, the means to define external functions, expose its own functions without name mangling and to invoke unsafe code that would otherwise be illegal in Rust.</p>
<h2 id="calling-out-to-c-libraries"><a class="header" href="#calling-out-to-c-libraries">Calling out to C libraries</a></h2>
<p>Rust supports the concept of a foreign function interface which is a definition of an external function or type that is resolved at link time.</p>
<p>For example, we might wish to link to a library called foo.lib, and invoke a command foo_command().</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;foo&quot;)]
extern {
  fn foo_command(command: *mut u8)
}
<span class="boring">}
</span></code></pre></pre>
<p>To call this function we have to turn off safety checks first because we are stepping out of the bounds of Rust's lifetime enforcement. To do this we wrap the call in an unsafe block to disable the safety checks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn run_command(command: &amp;[u8]) {
  unsafe {
    foo_command(command.as_ptr());
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note how we can use unsafe features like pointers inside of this unsafe block. This allows interaction with the outside world while still enforcing safety for the rest of our code.</p>
<h2 id="making-rust-code-callable"><a class="header" href="#making-rust-code-callable">Making Rust code callable</a></h2>
<p>The converse is also possible. We can produce a C ABI library from Rust that can be invoked by some other code.</p>
<p>For example, imagine we have some code written in Python. The code works fine but it is not performant and the bottle neck is in just one portion of the code, e.g. some file operation like a checksum. We want our code to consist of a make_checksum() and a release_checksum().</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libc;

use std::ffi::CString;
use std::ptr;
use libc::{c_char, c_void, malloc, memset, strcpy, free};

#[no_mangle]
pub extern &quot;C&quot; fn make_checksum(filepath: *const c_char) -&gt; *mut c_char {
    // Your code here
    if filepath == ptr::null() {
      return ptr::null_mut::&lt;c_char&gt;()
    }

    unsafe {
        // Imagine our checksum code here...
        let result = malloc(12);
        memset(result, 0, 12);
        strcpy(result as *mut c_char, CString::new(&quot;abcdef&quot;).unwrap().as_ptr());
        return result as *mut c_char;
    }
}

#[no_mangle]
pub extern &quot;C&quot; fn release_checksum(checksum: *const c_char) {
    unsafe {
        free(checksum as *mut c_void);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now in Python we can invoke the library simply:</p>
<pre><code class="language-Python">import ctypes

checksum = ctypes.CDLL(&quot;path/to/our/dll&quot;);
cs = checksum.make_checksum(&quot;c:/somefile&quot;);
...
checksum.release_checksum(cs)
</code></pre>
<p>The <a href="https://doc.rust-lang.org/book/ffi.html">FFI specification</a> goes into a lot more detail than this and explains concepts such as callbacks, structure packing, stdcall, linking and other issues that allow full interoperability.</p>
<h2 id="libc-1"><a class="header" href="#libc-1">libc</a></h2>
<p>Rust maintains a crate called <a href="https://github.com/rust-lang/libc">libc</a> which holds types and functions corresponding to C.</p>
<p>A dependency to libc would be added to the <code>Cargo.toml</code> of your project:</p>
<pre><code>[dependencies]
libc = &quot;0.2.17&quot;
</code></pre>
<p>And the file that uses the functions would contain a preamble such as this saying what types and functions it calls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libc;

use libc::{c_char, malloc, free, atoi};
<span class="boring">}
</span></code></pre></pre>
<h2 id="other-libraries"><a class="header" href="#other-libraries">Other libraries</a></h2>
<p>There are also crates that have the definitions of structures, types and functions.</p>
<ul>
<li><a href="https://github.com/retep998/winapi-rs">WinAPI</a> bindings for Win32 programming APIs.</li>
<li><a href="https://github.com/sfackler/rust-openssl">OpenSSL</a> bindings for OpenSSL</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixing-problems-in-cc"><a class="header" href="#fixing-problems-in-cc">Fixing Problems in C/C++</a></h1>
<p>This section is not so much concerned with <em>the correct</em> way code should be written but what with the C/C++ languages allow. Successive versions of these languages have attempted to retrofit good practice, but not by eliminating
the bad one!</p>
<p>All of these things should be considered bad and any construct in the language that enables them is also bad:</p>
<ul>
<li>Calling a pure virtual function in a constructor / destructor of a base class</li>
<li>Calling a dangling pointer</li>
<li>Freeing memory more than once</li>
<li>Using default copy constructors or assignment operators without following the rule of three</li>
<li>Overflowing a buffer, e.g. being off by one with some string operation or not testing a boundary condition</li>
<li>Memory leaks due to memory allocation / ownership issues</li>
<li>Heap corruption</li>
</ul>
<p>The C++ programming language is a very large specification, one that only grows and gets more nuanced and qualified with each release.</p>
<p>The problem from a programmer's perspective is understanding what things C++ allows them to do as oppose to what things they should do.</p>
<p>In each case we'll see how Rust might have stopped us getting into this situation in the first place.</p>
<h2 id="what-about-c"><a class="header" href="#what-about-c">What about C?</a></h2>
<p>C++ will come in for most of the criticism in this section. Someone might be inclined to think that therefore C does not suffer from problems.</p>
<p>Yes that is true to some extent, but it is akin to arguing we don't need shoes because we have no legs. C++ exists and is popular because it is perceived as a step up from C.</p>
<ul>
<li>Namespaces</li>
<li>Improved type checking</li>
<li>Classes and inheritance</li>
<li>Exception handling</li>
<li>More useful runtime library including collections, managed pointers, file io etc.</li>
</ul>
<p>The ability to model classes and bind methods to them is a major advance. The ability to write RAII style code does improve the software's chances of keeping its memory and resource use under control.</p>
<h2 id="compilers-will-catch-some-errors"><a class="header" href="#compilers-will-catch-some-errors">Compilers Will Catch Some Errors</a></h2>
<p>Modern C/C++ compilers can spot some of the errors mentioned in this section. But usually they'll just throw a warning out. Large code bases always generate warnings, many of which are innocuous and it's easy to see why some people become numb to them as they scroll past.</p>
<p>The simplest way to protect C / C++ from dumb errors is to elevate serious warnings to be errors. While it is not going to protect against every error it is still better than nothing.</p>
<ul>
<li>
<p>In Microsoft VC++ enable a high warning level, e.g. /W4 and possibly /WX to warnings into errors.</p>
</li>
<li>
<p>In GCC enable -Wall, -pedantic-errors and possibly -Werror to turn warnings into errors. The pedantic flag rejects code that doesn't follow ISO C and C++ standards. There are a lot of errors that can be <a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options">configured</a>.</p>
</li>
</ul>
<p>However this will probably throw up a lot of noise in your compilation process and some of these errors may be beyond your means to control.</p>
<p>In addition it is a good to run a source code analysis tool or linter. However these tend to be expensive and in many cases can be extremely unwieldy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-constructor--assignment-operators"><a class="header" href="#copy-constructor--assignment-operators">Copy Constructor / Assignment Operators</a></h1>
<p>Imagine this class in C++:</p>
<pre><code class="language-c++">struct Person {
    //...
};

class PersonList {
  std::vector&lt;Person&gt; *personList_;
public:
  PersonList() : personList_(new std::vector&lt;Person&gt;) {
  }

  ~PersonList() {
    delete personList_;
  }

  // ... Methods to add / search list
};
</code></pre>
<p>Note we're deliberately going to use a raw pointer to a vector for illustrative purposes. In your real code you'd probably use a scoped pointer.</p>
<p>Prior to C++11, all assignment was via copy construction and assignment operators. You would copy one instance to another via a constructor and also by an assignment operator. In some cases a constructor will be used instead of an assignment:</p>
<pre><code class="language-c++">PersonList x; 
PersonList y = x; // Copy constructor, not assignment
PersonList z;
z = x; // Assignment operator
</code></pre>
<p>By default C++ generates all the code to copy and assign the bytes in one class to another without any effort. Lucky us!</p>
<p>Except we're not lucky, we just got slimed. The default byte copy takes the pointer in <code>personList_</code> and makes a 
copy of it. Now if we copy <code>x</code> to <code>y</code>, or assign <code>x</code> to <code>z</code> we have three classes pointing to the same private data! 
On top of that, <code>z</code> allocated its own <code>personList_</code> during its default constructor but the byte copy assignment 
overwrote it with the one from <code>x</code> so its old <code>personList_</code> value just leaks.</p>
<p>Of course we might be able to use a <code>std::unique_ptr</code> to hold our pointer. In which case the compiler would 
generate an error. But it might not always be that simple. <code>personList_</code> may have been opaquely 
allocated by an external library so have no choice but to manage its lifetime through the constructor and destructor.</p>
<h2 id="the-rule-of-three"><a class="header" href="#the-rule-of-three">The Rule of Three</a></h2>
<p>This is such a terrible bug enabling problem in C++ that it has given rise to the so-called the Rule of Three<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>The rule says that if we explicitly declare a destructor, copy constructor or copy assignment operator in a C++ class
then we probably need to implement all three of them to safely handle assignment and construction. In other words 
the burden for fixing C++'s default and dangerous behaviour falls onto the developer.</p>
<p>So let's fix the class:</p>
<pre><code class="language-c++">struct Person {
    //...
};

class PersonList {
    std::vector&lt;Person&gt; *personList_;
public:
    PersonList() : personList_(new std::vector&lt;Person&gt;) {
    }

    PersonList(const PersonList &amp;other) :
            personList_(new std::vector&lt;Person&gt;)    {
        personList_-&gt;insert(
                personList_-&gt;end(), other.personList_-&gt;begin(),
                other.personList_-&gt;end());
    }

    ~PersonList() {
        delete personList_;
    }

    PersonList &amp; operator=(const PersonList &amp;other) {
        // Don't forget to check if someone assigns an object to itself
        if (&amp;other != this) {
            personList_-&gt;clear();
            personList_-&gt;insert(
                    personList_-&gt;end(), other.personList_-&gt;begin(),
                    other.personList_-&gt;end());
        }
        return *this;
    }

    // ... Methods to add / search list
};
</code></pre>
<p>What a mess!</p>
<p>We've added a copy constructor and an assignment operator to the class to handle copying safely. The code even had to check if it was being assigned to itself in case someone wrote <code>x = x</code>. Without that test, the receiving instance would clear itself in preparation to adding elements from itself which would of course wipe out all its contents.</p>
<p>Alternatively we might disable copy / assignments by creating private constructors that prevents them being called by external code:</p>
<pre><code class="language-c++">class PersonList {
    std::vector&lt;Person&gt; *personList_;

private:
    PersonList(const PersonList &amp;other) {}
    PersonList &amp; operator=(const PersonList &amp;other) { return *this; }

public:
    PersonList() : personList_(new std::vector&lt;Person&gt;) {
    }

    ~PersonList() {
        delete personList_;
    }
    // ... Methods to add / search list
};
</code></pre>
<p>Another alternative would be to use noncopyable types within the class itself. For example, the copy would fail if the pointer were managed with a C++11 <code>std::unique_ptr</code> (or Boost's <code>boost::scoped_ptr</code>).</p>
<p>Boost also provides a <code>boost::noncopyable</code> class which provides yet another option. Classes may inherit from noncopyable which implements a private copy constructor and assignment operator so any code that tries to copy will generate a compile error.</p>
<h2 id="move-constructor"><a class="header" href="#move-constructor">Move Constructor</a></h2>
<p>C++11 introduces move semantics. That basically you can avoid copying from one instance to another and instead <em>move</em>. A move essentially means shifting all the bytes over from one class to another and then rendering the first class in a valid, inoperable state.</p>
<p>In our <code>PersonList</code> adding a move constructor would be relatively simple - we put the pointer in the new class and render the old pointer as null. A move constructor uses a <code>&amp;&amp;</code> notation.</p>
<pre><code class="language-c++">    PersonList(const PersonList &amp;&amp;other) :
      personList_(nullptr) {
      personList_ = other.personList_;
      other.personList_ = nullptr;
    }
</code></pre>
<h2 id="move-assignment-operator"><a class="header" href="#move-assignment-operator">Move assignment operator</a></h2>
<p>Ah, but we also need a move assignment operator:</p>
<pre><code class="language-c++">  PersonList &amp; operator=(const PersonList &amp;&amp;other) {
      // Don't forget to check if someone assigns an object to itself
      if (&amp;other != this) {
          // We have to clear out anything we're holding already
          if (this-&gt;personList_) {
            delete this-&gt;personList_;
          }
          // Now take the other guy's data
          this.personList_ = other.personList_;
          other.personList_ = nullptr;
      }
      return *this;
  }
</code></pre>
<p>And finally, our constructor needs tweaking since if data moves out of us, we need to ensure we test for that before deleting it.</p>
<pre><code class="language-c++">  ~PersonList() {
    if (personList_)
        delete personList_;
    }
  }
</code></pre>
<h2 id="the-rule-of-five"><a class="header" href="#the-rule-of-five">The Rule of Five</a></h2>
<p>So adding a move constructor and move assignment operator means the Rule of Three has become the Rule of Five(!).</p>
<p>What a mess.</p>
<h2 id="how-rust-helps"><a class="header" href="#how-rust-helps">How Rust helps</a></h2>
<h3 id="move-is-the-default"><a class="header" href="#move-is-the-default">Move is the default</a></h3>
<p>Rust helps by making move semantics the default. i.e. unless you need to copy data from one instance to another, you don't. If you assign a struct from one variable to another, ownership moves with it. The old variable is marked invalid by the compiler and it is an error to access it.</p>
<p>But if you do want to copy data from one instance to another then you have two choices.</p>
<ul>
<li>Implement the <code>Clone</code> trait. Your struct will have an explicit <code>clone()</code> function you can call to make a copy of the data.</li>
<li>Implement the <code>Copy</code> trait. Your struct will now implicitly copy on assignment instead of move. Implementing <code>Copy</code> also implies implementing <code>Clone</code> so you can still explicitly call <code>clone()</code> if you prefer.</li>
</ul>
<p>Primitive types such as integers, chars, bools etc. implement <code>Copy</code> so you can just assign one to another</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is all good
let x = 8;
let y = x;
y = 20;
assert_eq!(x, 8);
<span class="boring">}
</span></code></pre></pre>
<p>But a <code>String</code> cannot be copied this way. A string has an internal heap allocated pointer so copying is a more expensive operation. So <code>String</code> only implements the <code>Clone</code> trait which requires you to explicitly duplicate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let copyright = &quot;Copyright 2017 Acme Factory&quot;.to_string();
let copyright2 = copyright.clone();
<span class="boring">}
</span></code></pre></pre>
<p>The default for any struct is that it can neither be copied nor cloned.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
  name: String,
  age: u8
}
<span class="boring">}
</span></code></pre></pre>
<p>The following code will create a <code>Person</code> object, assigns it to <code>person1</code>. And when <code>person1</code> is assigned to <code>person2</code>, ownership of the data also moves:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let person1 = Person { name: &quot;Tony&quot;.to_string(), age: 38u8 };
let person2 = person1;
<span class="boring">}
</span></code></pre></pre>
<p>Attempting to use <code>person1</code> after ownership moves to <code>person2</code> will generate a compile error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, person1.name); // Error, use of a moved value
<span class="boring">}
</span></code></pre></pre>
<p>To illustrate consider this Rust which is equivalent to the PersonList we saw in C++</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PersonList {
    pub persons: Vec&lt;Person&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>We can see that <code>PersonList</code> has a <code>Vec</code> vector of <code>Person</code> objects. Under the covers the <code>Vec</code>  will allocate space in the heap to store its data.</p>
<p>Now let's use it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = PersonList { persons: Vec::new(), };
let mut y = x;
// x is not the owner any more...
x.persons.push(Person{ name: &quot;Fred&quot;.to_string(), age: 30u8} );
<span class="boring">}
</span></code></pre></pre>
<p>The variable <code>x</code> is on the stack and is a <code>PersonList</code> but the persons member is partly allocated from the heap.</p>
<p>The variable <code>x</code> is bound to a PersonList on the stack. The vector is created in the heap. If we assign <code>x</code> to <code>y</code> then we could have two stack objects sharing the same pointer on the heap in the same way we did in C++.</p>
<p>But Rust stops that from happening. When we assign <code>x</code> to <code>y</code>, the compiler will do a bitwise copy of the data in x, but it will bind ownership to <code>y</code>.  When we try to access the in the old var Rust generates a compile error.</p>
<pre><code>error[E0382]: use of moved value: `*x.persons`
   |
10 | let mut y = x;
   |     ----- value moved here
11 | x.persons.push(Person{});
   | ^^^^^^^^^ value used here after move
   |
   = note: move occurs because `x` has type `main::PersonList`, which does not implement the `Copy` trait
</code></pre>
<p>Rust has stopped the problem that we saw in C++. Not only stopped it but told us why it stopped it - the value moved from x to y and so we can't use x any more.</p>
<h3 id="implementing-the-copy-trait"><a class="header" href="#implementing-the-copy-trait">Implementing the Copy trait</a></h3>
<p>The <code>Copy</code> trait allows us to do direct assignment between variables. The trait has no functions, and acts as a marker in the code to denote data that should be duplicated on assignment.</p>
<p>You can implement the <code>Copy</code> trait by deriving it, or implementing it. But you can only do so if all the members of the struct also derive the trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct PersonKey {
  id: u32,
  age: u8,
}

// Alternatively...

impl Copy for PersonKey {}

impl Clone for PersonKey {
  fn clone(&amp;self) -&gt; PersonKey {
     *self
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>So <code>PersonKey</code> is copyable because types <code>u32</code> and <code>u8</code> are also copyable and the compiler will take the <code>#[derive(Copy)]</code> directive and modify the move / copy semantics for the struct.</p>
<p>But when a struct contains a a type that does not implement <code>Copy</code> you will get a compiler error. So this struct <code>Person</code> will cause a compiler error because <code>String</code> does not implement <code>Copy:</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Person {
  name: String,
  age: u8
}
// Compiler error!
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-the-clone-trait"><a class="header" href="#implementing-the-clone-trait">Implementing the Clone trait</a></h3>
<p>The <code>Clone</code> trait adds a <code>clone()</code> function to your struct that produces an independent copy of it. We can derive it if every member of the struct can be cloned which in the case of <code>Person</code> it can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Person {
  name: String,
  age: u8
}
...
let x = Person { /*...*/ };
let y = x.clone();
<span class="boring">}
</span></code></pre></pre>
<p>Now that Person derives <code>Clone</code>, we can do the same for PersonList because all its member types implement that trait - a Person can be cloned, a Vec can be cloned, and a Box can be cloned:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct PersonList {
    pub persons: Box&lt;Vec&lt;Person&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>And now we can clone <code>x</code> into <code>y</code> and we have two independent copies.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//...
let mut x = PersonList { persons: Box::new(Vec::new()), };
let mut y = x.clone();
// x and y are two independent lists now, not shared
x.persons.push(Person{ name: &quot;Fred&quot;.to_string(), age: 30} );
y.persons.push(Person{ name: &quot;Mary&quot;.to_string(), age: 24} );
<span class="boring">}
</span></code></pre></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In summary, Rust stops us from getting into trouble by treated assigns as moves when a non-copyable variable is assigned from one to another. But if we want to be able to clone / copy we can make our intent explicit and do that too.</p>
<p>C++ just lets us dig a hole and fills the dirt in on top of us.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="missing-braces-in-conditionals"><a class="header" href="#missing-braces-in-conditionals">Missing Braces in Conditionals</a></h1>
<p>Every programmer eventually encounters an error like this and spends hours trying to figure out why it wasn't working.</p>
<pre><code class="language-c++">const bool result = fetch_files();
if (result) {
  process_files()
}
else
  print_error()
  return false;

// Now cleanup and return success
cleanup_files();
return true;
</code></pre>
<p>The reason of course was the else statement wasn't enclosed in braces so the wrong code was executed. The compiler might spot dead code in this instance but that may not always be the case. Even if it did, it might only issue a warning instead of an error.</p>
<p>The problem can be especially annoying in deeply nested conditions where a misplaced brace can attach to the wrong level.
This problem has lead real-world security issues. For example here is the infamous <a href="https://www.imperialviolet.org/2014/02/22/applebug.html">&quot;goto fail&quot;</a> bug that occured in some Apple products. This (intentional?) bug occured during an SSL handshake and was exploitable. :</p>
<pre><code class="language-c++">static OSStatus
SSLVerifySignedServerKeyExchange(
   SSLContext *ctx, bool isRsa, SSLBuffer signedParams,
   uint8_t *signature, UInt16 signatureLen)
{
  OSStatus        err;
  //...

  if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0)
    goto fail;
  if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
    goto fail;
    goto fail;
  if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0)
    goto fail;
  //...

fail:
  SSLFreeBuffer(&amp;signedHashes);
  SSLFreeBuffer(&amp;hashCtx);
  return err;
}
</code></pre>
<p>Note how the &quot;goto fail&quot; is repeated twice and not bound to the condition but is indented as if it was. The code would jump straight into the fail label and return with an err indicating success (since the prior SHA1 update had succeeded). If conditionals</p>
<h2 id="how-rust-helps-1"><a class="header" href="#how-rust-helps-1">How Rust helps</a></h2>
<p>Rust requires if-else expressions and loops to be associated with blocks.</p>
<p>So this code won't compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i32 = do_something();
if x == 200 {
  // ...
}
else
  println!(&quot;Error&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If you try you will get an error like this.</p>
<pre><code>rustc 1.13.0-beta.1 (cbbeba430 2016-09-28)
error: expected `{`, found `println`
  |
8 |   println!(&quot;Error&quot;);
  |   ^^^^^^^
  |
help: try placing this code inside a block
  |
8 |   println!(&quot;Error&quot;);
  |   ^^^^^^^^^^^^^^^^^^
error[E0425]: unresolved name `do_something`
  |
3 | let mut x: i32 = do_something();
  |                  ^^^^^^^^^^^^ unresolved name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignment-in-expressions"><a class="header" href="#assignment-in-expressions">Assignment in Expressions</a></h1>
<p>C and C++ allow you do do things like this:</p>
<pre><code class="language-c++">int result;
while (result = getNextResponseCode()) {
  // In C++ result is non-zero which is evaluated as boolean true
  // In C result is non-zero which is treated as statement success
  if (result == 200) {
    //...
  }
  else if (result = 404) { // BUG!!!
    //...
  }
}
</code></pre>
<p>Our loop here is calling <code>doSomething()</code>, and continuing for as long as <code>result</code> is non-zero. Inside the loop it then further tests the value. But look at the second test, we wrote <code>=</code> instead of <code>==</code>, the language is fine about it and introduced a bug.</p>
<p>Some compilers may warn if a result is assigned to a constant but it is still allowed.</p>
<p>We saw this <code>goto fail</code> example in section &quot;Missing braces in conditionals&quot;:</p>
<pre><code class="language-c++">if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0)
  goto fail;
</code></pre>
<p>We could inadvertantly break it as easily in the other direction if we used <code>==</code> instead of <code>=</code>, i.e. comparing err to the function call and then comparing that to 0.</p>
<pre><code class="language-c++">if ((err == SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0)
  goto fail;
</code></pre>
<h2 id="in-rust-3"><a class="header" href="#in-rust-3">In Rust</a></h2>
<p>Rust does not allow assignment within simple expressions so they will fail to compile. This is done to prevent subtle errors with <code>=</code> being used instead of <code>==</code>.</p>
<p>Let's look how we might do the equivalent (but not optimal way) in Rust using a block expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut result;
while { result = getNextResponseCode(); result &gt; 0 } {
  if result == 200 {
    //...
  }
  else if result == 404 {
    //...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we declare a mutable <code>result</code> var and run a loop against a block expression. The block expression assigns a value to <code>result</code> and then evaluates as <code>result &gt; 0</code>. We also use a <code>match</code> to test the value of result since that makes sense in this context.</p>
<p>So this is functionally the same thing as C++ but it's a little bit noisy.</p>
<p>Can we do better? Yes if change the function signature of <code>getNextResponseCode()</code> to return an enum such as <code>Option&lt;&gt;</code> or <code>Result&lt;&gt;</code>. Rust has a <code>while let</code> construct that allows us to test if a enum value matches a pattern and to automatically assign the payload to another value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn getNextResponseCode() -&gt; Option&lt;u32&gt; { /*... */}
//...
while let Some(result) = getNextResponseCode() {
  if result == 200 {
    //...
  }
  else if result == 404 {
    //...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This code will run the loop, calling <code>getNextResponseCode()</code> and if it evaluates to <code>Some(value)</code> then <code>value</code> is copied to variable <code>result</code>. If it does not match the pattern then the loop breaks.</p>
<p>This is good design in Rust. It is always to convey information in a function's signature. Not only do we make the distinction between a bad result and a good one, but we can use <code>while let</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-member-initialisation"><a class="header" href="#class-member-initialisation">Class Member Initialisation</a></h1>
<p>C++ does not require that you initialise all variables in every constructor.</p>
<ul>
<li>A member that is a C++ class with its own default constructor doesn't need to be initialised.</li>
<li>A member that is a C++ class without a default constructor must be explicitly initialised.</li>
<li>A member that is a reference must be explicitly initialised.</li>
<li>Primitive types, including pointers do not have to be initialised although the compiler may warn if they are not.</li>
<li>Members do not have to be initialised in the order they are declared although the compiler may warn if they are not.</li>
</ul>
<p>C++11 allows classes to have default member initializers which are used in the absence of a constructor setting the 
value to something else:</p>
<pre><code class="language-c++">class Coords {
public:
    double x = 0.0;
    double y = 0.0;
    double z = 0.0;

    // 2D initializer, x and y are set with the inputs, z is set to 0
    Coords(double x, double y) : x(x), y(y) {}
};
</code></pre>
<p>This is obviously a lot easier to read and ensures that if we have multiple constructors that we don't have to initialize
members if the default value will do.</p>
<p>However what is not so nice is that initialisation is spread all over the place in the code. Some of it may be in a header file, some in the 
constructor. Nothing is very clear at all.</p>
<h2 id="how-rust-helps-2"><a class="header" href="#how-rust-helps-2">How Rust helps</a></h2>
<p>You MUST initialise all members of a struct. You CANNOT forget to initialise anything or it becomes a compiler error. This
always means fields in structs are in an initialised state.</p>
<p>So this will not compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Alphabet {
  a: i32,
  b: u32,
  c: bool,
}

// Forgot to init b
let a = Alphabet { a: -10, c: true };
<span class="boring">}
</span></code></pre></pre>
<p>If you try you will get an error like this:</p>
<pre><code>rustc 1.13.0-beta.1 (cbbeba430 2016-09-28)
error[E0063]: missing field `b` in initializer of `main::Alphabet`
  |
9 |     let a = Alphabet { a: -10, c: true };
  |             ^^^^^^^^ missing `b`
</code></pre>
<ul>
<li>Forcing you to initialise the members of the struct ensures the struct is always in a consistent predictable state.</li>
<li>Ordering of initialisation does not matter providing all of the fields are set.</li>
</ul>
<p>Structs often implement a <code>new()</code> function which encapsulates this initialisation and acts like a class constructor in C++, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Coord {
  pub x: f64,
  pub y: f64,
  pub z: f64,
}

impl Coord {
  pub fn new(x: f64, y:f64) {
    Coord { x: x, y: y, z: 0f64 }
  }
}
///...
let coord1 = Coord::new(100f64, 200f64);
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively the struct might implement one or more <code>From&lt;&gt;</code> traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;(f64, f64)&gt; for Coord {
  fn from(value: (f64, f64)) -&gt; Coord {
    Coord { x: value.0, y: value.1, z: 0.0 }
  }
}

impl From&lt;(f64, f64, f64)&gt; for Coord {
  fn from(value: (f64, f64, f64)) -&gt; Coord {
    Coord { x: value.0, y: value.1, z: value.2 }
  }
}


//...
let coord = Coord::from((10.0, 20.0));
let coord = Coord::from((10.0, 20.0, 30.0));
<span class="boring">}
</span></code></pre></pre>
<p>There can be multiple <code>From</code> trait implementations so we can implement a form of polymorphism.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="headers-and-sources"><a class="header" href="#headers-and-sources">Headers and Sources</a></h1>
<p>A header file contains definitions of classes, types, macros etc that other files need to #include in order to resolve their use of those things.</p>
<p>Splitting the implementation and definition across different files is an added burden for maintaining code but it can also lead to some serious errors.</p>
<ul>
<li>Headers used across multiple projects that have different compiler settings</li>
<li>Issues with pragmas and alignment</li>
<li>Issues with different #definitions that affect byte length</li>
<li>Issues with different typedefs that affect byte length</li>
</ul>
<p>Each consumer of the header must do so with the exact same settings that affect the size of every type, struct and class in the file plus any issues with packing / alignment. If these settings are not the same, it can cause instability, corruption or problems that only manifest themselves at at runtime.</p>
<p>Headers also make the compiler slower because source that consumes the header inevitably pulls in other headers which pull in other headers.</p>
<h2 id="guard-blocks--pragma-once"><a class="header" href="#guard-blocks--pragma-once">Guard blocks / #pragma once</a></h2>
<p>Headers will also be expanded as many times as they are <code>#include</code>'d. To prevent the expansion happening more than once per source file, they're usually protected by guard blocks.</p>
<pre><code class="language-c++">#ifndef FOO_H
#define FOO_H
....
#endif
</code></pre>
<p>If the same header is included more than once, the second time through it is preprocessed into nothing.</p>
<h3 id="pragma-once"><a class="header" href="#pragma-once">#pragma once</a></h3>
<p>Most modern compilers also support a <code>#pragma once</code> directive. This allows the compiler to completely ignore an <code>#include</code> which it knows it has already included at least once before per source file. </p>
<p>This is more efficient than guard blocks because the compile doesn't even bother opening or processing the file again and just skips over it. There may be situations where this is not suitable, but usually it results in faster compilation.</p>
<h3 id="precompiled-headers"><a class="header" href="#precompiled-headers">Precompiled Headers</a></h3>
<p>Some compilers also support precompiled headers to speed up compilation. The compiler builds a database lookup when compiling a single source file and subsequent source compiles with reference to that database. This solution can speed up compilation but it complicates the build process since one file has flags to generate the precompiled header file and other sources have flags to reference it.</p>
<h2 id="pimpl-pattern"><a class="header" href="#pimpl-pattern">Pimpl pattern</a></h2>
<p>A popular workaround for header issues is the Pimpl pattern. It is a way to separate a class into a public part and a private implementation part.</p>
<p>The public class is almost an interface definition in its purity that can be defined in the header with minimal dependencies. It forward references the implementation class and stores it as a member:</p>
<pre><code class="language-c++">#pragma once

// Gory details are in the .cpp file
class ComplexThingImpl;

class ComplexThing {
  ComplexThingImpl *pimpl_;
public:
  ComplexThing();
  ~ComplexThing();

  // See note 1 below

  void somethingReallyComplex();
};
</code></pre>
<p>The constructor for the outer class would allocate the implementation class and method calls would call through to the inner.</p>
<p>The private implementation class is defined in the source file and can pull in as many extra headers as it needs, pragmas whatever without hurting consumers or compile times of the header.</p>
<pre><code class="language-c++">// source file
#include &quot;random/header.hpp&quot;
// Lots of includes here
#include &lt;...&gt;
#include &quot;more/stuff.hpp&quot;

class  ComplexThingImpl {
  // Lots of member variables and stuff here
  // ...
public:
  void somethingReallyComplex();
}

void ComplexThingImpl::somethingReallyComplex() {
  // Lots of complex stuff here
  // ...
}

ComplexThing::ComplexThing() :
  pimpl_(new ComplexThingImpl()) {
}

ComplexThing::~ComplexThing() {
  delete pimpl_;
}

void ComplexThing:: somethingReallyComplex() {
  pimpl_-&gt;somethingReallyComplex();
}
</code></pre>
<p>This solution is known as Pimpl (private implementation) pattern and while it can work to protect consumers and speed up builds it also adds complexity and overhead to development. Instead of 2 definitions of a class to maintain (header / source) you now have 4(!) because there is a public and private impl class. Changing the signature of a method means changing it in potentially 4 places, plus the line in the public class that invokes the private counterpart.</p>
<p>One danger for Pimpl is that the private class is allocated from the heap. Code that uses a lot of temporary Pimpl objects could contribute to heap fragmentation.</p>
<p>Note 1: Remember the rule of three? That applies to this object too. The example doesn't show it but if we copy constructed or assigned ComplexThing to another instance we'd be in a heap of trouble. So on top of the issues with making PImpl work we also have to prevent the other ones. The easiest way to lock it down would be to derive from <code>boost::noncopyable</code> if you were using boost or make the copy constructor <code>private</code>, or use delete it in C++11.</p>
<h2 id="how-rust-helps-3"><a class="header" href="#how-rust-helps-3">How Rust helps</a></h2>
<p>In Rust the definition and the implementation are the same thing. So immediately we have exactly one thing to maintain.</p>
<p>Writing a function defines the function. Let's assume we have a functions.rs file</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// functions.rs
pub fn create_directory_structure() {
  // Implementation
}
<span class="boring">}
</span></code></pre></pre>
<p>Anyone can call it as <code>functions::create_directory_structure()</code>. The compiler will validate the call is correct.</p>
<p>A struct's definition and its implementation are also written once. e.g. <code>directory.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// directory.rs
pub struct Directory {
  pub path: String,
}
impl Directory {
  pub fn mkdir(&amp;self) {
    // implementation
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementations can be defined in a private Rust module and only public structs exposed to consumers.</p>
<p>If we were a library crate (which we'll call <code>file_utils</code>) wishing to expose these objects to consumers we would write a top-level <code>lib.rs</code> which says what files our lib comprises of and we want to expose.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs for file_utils
mod functions;
mod directory;
pub use functions::*;
pub use directory::Directory;
<span class="boring">}
</span></code></pre></pre>
<p>Now a consumer can use our crate easily:</p>
<pre><pre class="playground"><code class="language-rust">extern crate file_utils;
use file_utils::*;
fn main() {
   create_directory_structure();
   let d = Directory { /* ... */ };
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forward-declarations"><a class="header" href="#forward-declarations">Forward Declarations</a></h1>
<p>C++ prevents us from referring to a class or function which has not been defined yet. The compiler will complain even if the class or function is in the same file it is referenced from.</p>
<p>This means ordering matters. If our function or class is used by other files, we have to declare the function in a header. If our function is private to a source file, we have to declare it in the source file, and possibly make it static.</p>
<p>For classes we can make a forward reference. This acts as a hint to compiler to say a class does exist with this name and it will be told about it shortly. But it's a hack and it imposes limits on how we can use the forward declared class.</p>
<p>For example, DataManager below can hand out Data objects but the Data object has a reference to the DataManager. Since each class refers to each other there is no simple way to make the compiler happy except with a forward declaration.</p>
<pre><code class="language-c++">class Data; // Forward declaration

class DataManager {
public:
  Data *getDataById(const std::string &amp;id);
};

class Data {
public:
  Data(DataManager &amp;dataManager);
}
</code></pre>
<p>But forward declaration compromises the design of the code. For example we couldn't hold the Data objects in a collection class:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>class Data;

class DataManager {
  std::map&lt;std::string, Data&gt; data_;
public:
  Data *getDataById(const std::string &amp;id);
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler would complain because it doesn't know anything about the constructors or size of Data. So instantly the design has to change because of a dumb compiler restriction. e.g. we might store a pointer to Data instead in the map but then we'd have to remember to delete it. So forward references increase the potential for bugs.</p>
<pre><code class="language-c++">class Data;

class DataManager {
  // Great, now we have to remember to new / delete Data and we increase
  // memory fragmentation
  std::map&lt;std::string, Data*&gt; data_;
public:
  Data *getDataById(const std::string &amp;id);
}
</code></pre>
<h2 id="how-rust-helps-4"><a class="header" href="#how-rust-helps-4">How Rust helps</a></h2>
<p>In Rust forward declarations are unnecessary. The struct and functionâ€™s definition reside in a .rs and can be referenced with a use directive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace-collisions"><a class="header" href="#namespace-collisions">Namespace Collisions</a></h1>
<p>C code has no namespaces at all and namespaces in C++ are optional. </p>
<ul>
<li>C has learned to live without namespaces. Most C code uses prefixes on functions and structs to avoid collisions, e.g <code>sqlite3_exec()</code> is a function belonging to SQLite3. The prefix stops the function colliding with <code>exec()</code> which is a standard POSIX function that got there first. So the prefix acts as a pseudo namespace. But it adds noise to our code and would not be necessary if namespaces were supported and enforced.</li>
<li>C++ makes them easy to declare but there is no compunction for any code to bother or to do so in anything but the most perfunctory way.</li>
<li>Macros are not affected by namespaces. For example, if <code>TRUE</code> and <code>FALSE</code> are defined by some header they taint everything that <code>#include</code>'s those definitions.</li>
</ul>
<p>By default all C++ code resides in a global namespace:</p>
<pre><code class="language-c++">void hello() {
  // My function hello is in the global namespace, i.e. ::hello()
}

int main() {
  // Main entry point
  hello();
}
</code></pre>
<p>The function <code>hello()</code> is part of the global namespace. The call to it within <code>main</code> could be replaced with calls to <code>::hello()</code>. The problem of course is that the more code we write into the global namespace, or the more libraries we pull in that have no namespaces, the more chance there is of collisions.</p>
<p>Namespacing requires code enclose the namespaced portion in a block.</p>
<pre><code class="language-c++">namespace application {
  // stuff in here belongs to application::
}
//...
application::App app(&quot;my app&quot;);
</code></pre>
<p>It is also easy to abuse namespaces, for example this happens sometimes and is NOT a good idea:</p>
<pre><code class="language-c++">// Inside of foo.h...
using namespace std;
//... all code after here is tainted with std
</code></pre>
<p>Any file that says <code>#include &quot;foo.h&quot;</code> will inadvertently tell the compiler to automatically look up unscoped types and functions against std which may not be what the code wants at all.</p>
<p>Nested namespacing is also possible but it can look messy.</p>
<pre><code class="language-c++">namespace application { namespace gui {
  // stuff in here belongs to application::gui::
} }
//... eg.
application::gui::Point2d point(100,100);
</code></pre>
<p>If we forget to close a brace when nesting headers it becomes very easy to make C++ throw up a wall of incoherent errors.</p>
<h2 id="how-rust-helps-5"><a class="header" href="#how-rust-helps-5">How Rust helps</a></h2>
<p>In Rust every file is implicitly a module (equivalent to a namespace). You cannot NOT use modules because you get them automatically.</p>
<p>If you have a collision between the names of crates or modules y</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros-1"><a class="header" href="#macros-1">Macros</a></h1>
<p>Macros in C/C++ are basically little rules that are defined by a preprocessor and substituted into the code that the compiler ultimately attempts to compile.</p>
<p>Modern coding practice these days is to use inline functions and constants instead of macros.</p>
<p>But the reality is they can still be (ab)used and code often does. For example code might insert debug statements or logging which is compiled away in release mode.</p>
<p>Another common use is on Windows where the type <code>TCHAR</code> compiles to be either <code>char</code> or <code>wchar_t</code> depending on <code>#define UNICODE</code> being present or not. Along with it go macros like <code>USES_CONVERSION</code>, <code>A2CT</code>, <code>T2CW</code> etc. Code should compile cleanly either way but the reality is usually it doesn't.</p>
<p>A classic problem would be something like this:</p>
<pre><code class="language-c++">#define SQUARED(x) x * x
// And in code
float result = SQUARED(++x);
That would expand to
float result = ++x * ++x;
</code></pre>
<p>So the value in result would be wrong and the value in x would be incremented twice.</p>
<h2 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation errors</a></h2>
<p>Consider we are compiling this structure:</p>
<pre><code class="language-c++">// Header
struct Tooltip
#if TOOLTIP_VERSION &gt; 4
  char buffer[128];
#else
  char buffer[64];
#endif
};
</code></pre>
<p>And in C++</p>
<pre><code class="language-c++">Tooltip tooltip;
memset(&amp;tooltip, 0, sizeof(tooltip));
</code></pre>
<p>If we fail to define <code>TOOLTIP_VERSION</code> to the same value in the implementation as in the caller, then this code may stomp all over memory because it thinks the struct is 128 bytes in one place and 64 bytes in another.</p>
<h2 id="namespace-issues"><a class="header" href="#namespace-issues">Namespace issues</a></h2>
<p>Macros aren't namespaced and in some cases this leads to problems where a macro definition collides with a well qualified symbol.
For example code that <code>#include &lt;windows.h&gt;</code> gets a <code>#define TRUE 1</code>. But that excludes any other code that expects to compile on Windows from ever using <code>TRUE</code> as a const no matter how well they qualify it. Consequently code has to do workarounds such as <code>#undef</code> macros to make code work or using another value.</p>
<pre><code class="language-c++">#ifdef TRUE
#define TMP_TRUE TRUE
#undef TRUE
#endif
bool value = myapp::TRUE;
#ifdef TMP_TRUE
#define TRUE TMP_TRUE
#undef TMP_TRUE
#endif
</code></pre>
<p>Ugh. But more likely we'll rename myapp::TRUE to something like myapp::MYAPP_TRUE to avoid the conflict. It's still an ugly workaround for a problem caused by inconsiderate use of macros.</p>
<p>Commonly used words like TRUE, FALSE, ERROR, OK, SUCCESS, FAIL are more or less unusable thanks to macros.</p>
<h2 id="how-rust-helps-6"><a class="header" href="#how-rust-helps-6">How Rust helps</a></h2>
<p>Rust provides developers with consts, inline attributes, and platform / architecture attributes for the purpose of conditional compilation.</p>
<p>Rust offers macros but they consist of a set of matching rules than must generate syntactically Rust. Macro expansion is performed by the compiler so it is capable of generating errors on the macro if the macro is in error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-mismatching"><a class="header" href="#type-mismatching">Type Mismatching</a></h1>
<p>Consider two methods. Both are called evaluate() and they are overloaded. The main() method calls evaluate(&quot;Hello world&quot;). What version is called in the compiled code?</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

void evaluate(bool value) {
    cout &lt;&lt; &quot;Evaluating a bool &quot; &lt;&lt; value &lt;&lt; endl;
}

void evaluate(const std::string &amp;value) {
    cout &lt;&lt; &quot;Evaluating a string &quot; &lt;&lt; value &lt;&lt; endl;
}

int main() {
    evaluate(&quot;Hello world&quot;);
    return 0;
}
</code></pre>
<p>It may surprise you to know that the bool version is called and the compiler doesn't even complain about it either:</p>
<pre><code>Evaluating a bool 1
</code></pre>
<p>This is an example of bad type inference. A string literal (a char *) should be turned into a std::string (a C++ string has a constructor that takes char *) but the compiler chose to treat it as a bool instead.</p>
<p>On other occasions the compiler might spot ambiguity and complain but the blurred lines between types in C++ combined with overloading lead to errors:
Here is another example where the compiler is a little more useful by generating an error, but in doing so it demonstrates the limits of overloading</p>
<pre><code class="language-c++">bool evaluate(bool value);
bool evaluate(double value);
</code></pre>
<p>These overloaded methods should be distinct but they're not distinct enough as far as the compiler is concerned.</p>
<p>In summary, blurred and confusing rules about types in C++ can cause unexpected errors that can propagate to runtime.</p>
<h2 id="how-rust-helps-7"><a class="header" href="#how-rust-helps-7">How Rust helps</a></h2>
<p>In Rust the functions cannot be overloaded in this manner.</p>
<p>Rust is also more strict about type coercion - if you have a bool you cannot pass it to a function that takes an integer.</p>
<p>Nor can you pass an integer of one size to a function taking an integer of another size.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_i32(value: i32) {
   println!(&quot;Your value is {}&quot;, value);
}
let value = 20i16; // 16-bit int
print_i32(value);
<span class="boring">}
</span></code></pre></pre>
<p>This will yield an error:</p>
<pre><code>error[E0308]: mismatched types
  |
7 | print_i32(value);
  |           ^^^^^ expected i32, found i16
</code></pre>
<p>You must use an explicit numeric cast to turn the value into the type the function expects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_i32(value as i32);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explicit--implicit-class-constructors"><a class="header" href="#explicit--implicit-class-constructors">Explicit / Implicit Class Constructors</a></h1>
<p>It's not just overloading that can be a mess. C++ has a bunch of rules about implicit / explicit type conversion for single argument constructors.</p>
<p>For example:</p>
<pre><code class="language-c++">class MagicNumber {
public:
    MagicNumber(int value) {}
};

void magic(const MagicNumber &amp;m) {
  //...
}

int main() {
    //...
    magic(2016);
    return 0;
}
</code></pre>
<p>The function <code>magic()</code> takes a <code>const MagicNumber &amp;</code> yet we called it with <code>2016</code> and it still compiled.
How did it do that? Well our <code>MagicNumber</code> class has a constructor that takes an <code>int</code> so the compiler 
implicitly called that constructor and used the <code>MagicNumber</code> it yielded.</p>
<p>If we didn't want the implicit conversion (e.g. maybe it's horribly expensive to do this without knowing), 
then we'd have to tack an <code>explicit</code> keyword to the constructor to negate the behaviour.</p>
<pre><code class="language-c++">explicit MagicNumber(int value) {}
</code></pre>
<p>It demonstrates an instance where the default behavior is probably wrong. The default <em>should</em> be <code>explicit</code> 
and if programmers want implicit they should be required to say it.</p>
<p>C++11 adds to the confusion by allowing classes to declare deleted constructors which are basically hints to the compiler to say,
&quot;if you see something resembling this, then generate a compiler error&quot;.</p>
<p>For example, perhaps we only want implicit <code>int</code> constructors to match but we want to stop somebody passing in
a <code>double</code>. In that case we can make a constructor for <code>double</code> and then delete it.</p>
<pre><code class="language-c++">class MagicNumber {
public:
    MagicNumber(int value) {}
    MagicNumber(double value) = delete;
};

void magic(const MagicNumber &amp;m) {
  //...
}

//...
magic(2016);   // OK
magic(2016.0); // error: use of deleted function 'MagicNumber::MagicNumber(double)'
</code></pre>
<h2 id="how-rust-helps-8"><a class="header" href="#how-rust-helps-8">How Rust helps</a></h2>
<p>Rust does not have constructors and so there is no implicit conversion during construction. And since there is no
implicit conversion there is no reason to have C++11 style function delete operators either. </p>
<p>This might seem counter intuitive and a bit painful, but we've just seen the problems they cause in C++.</p>
<p>But what does Rust let you do instead then? The answer in Rust is that a &quot;constructor&quot; is just any old function
that yields an instance of your struct. By convention you will normally see a <code>new()</code> function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MagicNumber { /* ... */ }

impl MagicNumber {
  pub fn new(value: i32) -&gt; MagicNumber { /* ... */ }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can write as many explicit &quot;constructor&quot; functions but since Rust doesn't do operator overloading they must be named
explicitly, e.g. perhaps we have a <code>new(i32)</code>, <code>new_double(f64)</code> etc.</p>
<h3 id="using-traits-to-simplify-new"><a class="header" href="#using-traits-to-simplify-new">Using traits to simplify new()</a></h3>
<p>This can get clumsy so we can use generic patterns to simplify our code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MagicNumber {
  fn new&lt;T&gt;(value: T) -&gt; MagicNumber where T: Into&lt;MagicNumber&gt; {
    value.into()
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>We have said here that the <code>new()</code> function takes as its argument anything that type <code>T</code> which implements the trait <code>Into&lt;MagicNumber&gt;</code>. Then our
implementation just calls <code>into()</code>, expecting the compiler to invoke the <code>T:Into&lt;MagicNumber&gt;::into()</code> to yield a <code>MagicNumber</code>.</p>
<p>So we could implement it for <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Into&lt;MagicNumber&gt; for i32 {
   fn into(self) {
     MagicNumber { /* ... */ }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now our client code can just call <code>new</code> and providing it provides a type which implements that trait our constructor will work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let magic = MagicNumber::new(2016);
   // But this won't work because f64 doesn't implement Into&lt;MagicNumber&gt; trait
   let magic = MagicNumber::new(2016.0); 
<span class="boring">}
</span></code></pre></pre>
<h3 id="default-constructor"><a class="header" href="#default-constructor">Default constructor</a></h3>
<p>Sometimes we need a default constructor, i.e. we need to make instance of a struct in its default state. In C++ we'd have a constructor that takes no arguments. As
there are no constructors in Rust, we could just write a function that takes no arguments and yields the struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
  x: f64,
  y: f64
}

impl Point {
  fn new() -&gt; Point { x: 0.0, y: 0.0 }
}
<span class="boring">}
</span></code></pre></pre>
<p>So our <code>new()</code> just spits out a <code>Point</code> with default values.</p>
<p>But Rust offers a better way to do the same. Structs may implement the <code>Default</code> trait which has a single function that yields a default instance of that type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for Point {
  fn default() -&gt; Point { x: 0.0, y: 0.0 }
}

//...
let pt1 = Point::default();
// Or
let pt2: Point = Default::default();
<span class="boring">}
</span></code></pre></pre>
<p>But <code>Default</code> is implemented on all the primitives including <code>f64</code>. So we could have also initialised <code>x</code> (and similarly <code>y</code>) by saying <code>x: Default::default()</code>.</p>
<p>And since all the members of the struct implement <code>Default</code>, Rust also lets us just derive it for the entire struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Point {
  x: f64,
  y: f64
}

//...
let pt1 = Point::default();
let pt2: Point = Default::default();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poor-lifetime-enforcement"><a class="header" href="#poor-lifetime-enforcement">Poor Lifetime Enforcement</a></h1>
<p>A function like is completely legal and dangerous:</p>
<pre><code class="language-c++">std::string &amp;getValue() {
  std::string value(&quot;Hello world&quot;);
  return value;
}
</code></pre>
<p>This function returns a reference to a temporary variable. Whoever calls it will get a reference to garbage on the stack. Even if it appears to work (e.g. if we called the reference immediately) it is only through luck that it does.</p>
<p>Our compiler will probably issue a warning for this trivial example but it won't stop us from compiling it.</p>
<h2 id="how-rust-helps-9"><a class="header" href="#how-rust-helps-9">How Rust helps</a></h2>
<p>Rust tracks the lifetime of all objects and knows when their lifetime begins and ends. It tracks references to the object, knows when it is being borrowed (being passed to a function / scope).</p>
<p>It generate a compiler error if it detects any violations of its lifetime / borrowing rules. So the above code would fail to compile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-allocation-1"><a class="header" href="#memory-allocation-1">Memory Allocation</a></h1>
<p>Allocated memory is memory that is requested from a portion of memory called a heap, used for some purpose and returned to the free space when it is no longer required.</p>
<p>In C memory is allocated and freed through a relatively simple API:</p>
<ul>
<li><code>malloc</code> and <code>calloc</code> allocate memory and <code>free</code> destroys it.</li>
</ul>
<p>However C++ also needs allocates that call the appropriate constructors and destructors so in addition to C's memory allocation functions, there are keywords for allocation / free.</p>
<ul>
<li><code>new</code> / <code>delete</code> for C++ class instances</li>
<li><code>new[]</code> and <code>delete[]</code> for arrays of classes</li>
<li>The above but through scoped / shared pointer classes that take ownership of the pointer and free it when appropriate.</li>
</ul>
<p>If we fail to free / delete memory that we've allocated, the program will leak memory. If we free / delete memory we've already deallocated, the program may crash. If we free a C++ class with a C <code>free()</code> the program may leak memory because any member variables will not be destroyed properly. If we fail to call the correct constructor and destructor pair the program may leak / crash.</p>
<p>A cottage industry of tools has sprung up just to try and debug issues with memory leaks, crashes and so forth. Tools like Valgrind etc. specialise in trying to figure out who allocated something without freeing it.</p>
<p>For example, what's wrong with this?</p>
<pre><code class="language-c++">std::string *strings = new std::string[100];
//...
delete strings;
</code></pre>
<p>Oops we allocated an array of strings with <code>new[]</code> but called <code>delete</code> instead of <code>delete[]</code>. So instead of deleting an array of strings we called delete on the first member. 99 of those string's destructors will never be called.
We should have written:</p>
<pre><code class="language-c++">delete []strings;
</code></pre>
<p>But the compiler doesn't care and so we have created a potentially hard-to-find bug.</p>
<p>Some of the problems with memory allocation can be mitigated by wrapping pointers with scoped or shared pointer classes. But there are even problems which can prevent them from working.</p>
<p>It's not a good idea to allow memory allocation to cross a library boundary. So many libraries provide new / free functions through their API. Issues about balancing calls apply to them too.</p>
<h2 id="how-rust-helps-10"><a class="header" href="#how-rust-helps-10">How Rust helps</a></h2>
<p>During normal safe programming Rust has no explicit memory allocation or deallocation. We simply declare an object and it continues to exist until its lifetime goes out of scope (i.e. nothing refers to it any more). </p>
<p>This is NOT garbage collection. The compiler tracks the lifetime of the object and generates code to automatically delete it at the point it is no longer used. The compiler also knows if we enclose an object's declaration inside a cell, box, rc or similar construct that the object should be allocated on the heap and otherwise it should go on the stack.</p>
<p>Allocation / deallocation is only available in unsafe programming. We would not only ordinarily do this except when we are interacting with an external library or function call and explicitly tag the section as unsafe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-pointers"><a class="header" href="#null-pointers">Null Pointers</a></h1>
<p>The need to test a pointer for NULL, or blindly call a pointer that might be NULL has caused so many errors that it has even been called the <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">billion dollar mistake</a></p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-destructors"><a class="header" href="#virtual-destructors">Virtual Destructors</a></h1>
<p>C++ allows classes to inherit from other classes.</p>
<p>In some cases, such as this example, this can lead to memory leaks:</p>
<pre><code class="language-c++">class ABase {
public:
  ~ABase() {}
};

class A : public ABase {
  std::string *value_;
public:
  A() : value_(new std::string) {}
  ~A() { delete value_; }
};

void do_something() {
  ABase *instance = new A();
  //...
  delete instance;
}
</code></pre>
<p>So here we allocate a pointer to A, assign it to &quot;instance&quot; which is of type <code>ABase</code>, do something with it and finally delete it. It looks fine but we just leaked memory! When we called &quot;delete instance&quot; the code invoked the destructor <code>~ABase()</code> and NOT the destructor <code>~A()</code> . And <code>value_</code> was not deleted and the memory leaked. Even if we'd used a scoped pointer to wrap <code>value_</code> it would still have leaked.</p>
<p>The code should have said</p>
<pre><code class="language-c++">class ABase {
public:
  virtual ~ABase() {}
};
</code></pre>
<p>The compiler didn't care our code was in error. It just allowed us to leak for the sake of a missing keyword.</p>
<h2 id="how-rust-helps-11"><a class="header" href="#how-rust-helps-11">How Rust helps</a></h2>
<p>Rust also does not use inheritance so problems like ABase above cannot exist. In Rust <code>ABase</code> would be declared as a trait that A implements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ABase {
  //...
}

struct A {
  value: String,
}

impl ABase for A {
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust also allows our struct to implement another trait called <code>Drop</code> which is equivalent to a C++ destructor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for A {
  fn drop(&amp;mut self) {
    println!(&quot;A has been dropped!&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>It allows our code to do something during destruction such as to free an open resource, log a message or whatever.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling--safety"><a class="header" href="#exception-handling--safety">Exception Handling / Safety</a></h1>
<p>There are no hard and fast rules for when a function in C++ should throw an exception and when it should return a code. So one codebase may have a tendency to throw lots of exceptions while another might throw none at all.</p>
<p>Therefore, the question of when it is right to throw an exception (or not) is often debated. The general rule of thumb is to throw exceptions for truly exceptional
circumstances outside of the program's ability to control, e.g. out of disk space.</p>
<p>As we'll see below, there are caveats about where and how exceptions should thrown.</p>
<p>Aside from that, code may or may not be exception safe. That is, it may or may not free up its resources if it suffers an exception. Articles have been
written to describe the levels of guarantees that code can aim for with <a href="http://www.boost.org/community/exception_safety.html">exception safety</a>.</p>
<h2 id="constructors-1"><a class="header" href="#constructors-1">Constructors</a></h2>
<p>You may also be advised to throw exceptions in constructors because there is no easy way to signal the object is an error otherwise
except to set the new object into some kind of zombie / dead state via a flag that has to be tested.</p>
<pre><code class="language-c++">DatabaseConn::DatabaseConn() {
  db_ = connect();
  if (db_ == NULL) {
    throw string(&quot;The database connection is null&quot;);
  }
}

// These both recover their memory
DatabaseConn db1;
DatabaseConn *db2 = new DatabaseConn();
</code></pre>
<p>But if DatabaseConn() had allocated some memory before throwing an exception, this would NOT be recovered and so ~DatabaseConn would have to clean it up.</p>
<pre><code class="language-c++">DatabaseConn::DatabaseConn() {
  buffer_ = new char[100];
  // ... exception throwing code
}

DatabaseConn::~DatabaseConn() {
  if (buffer_) {
    delete[] buffer_;
  }
}
</code></pre>
<p>But if we waited until after the exception throwing to allocate memory then maybe buffer_ is not set to NULL, so we'd have to ensure we initialised it to NULL.</p>
<pre><code class="language-c++">DatabaseConn::DatabaseConn() : buffer_(NULL) {
  // ... exception throwing code
  buffer_ = new char[100];
}
</code></pre>
<h2 id="destructors-1"><a class="header" href="#destructors-1">Destructors</a></h2>
<p>But you will be advised NOT to throw exceptions in destructors because throwing an exception during a stack unwind from handling another exception is fatal.</p>
<pre><code class="language-c++">BadNews::~BadNews() {
    if (ptr == NULL) {
      throw string(&quot;This is a bad idea&quot;);
   }
}
</code></pre>
<h2 id="how-rust-helps-12"><a class="header" href="#how-rust-helps-12">How Rust helps</a></h2>
<p>Rust doesn't have exceptions so issues surrounding exceptions cannot happen. The recommended way of dealing with errors is to use the <code>Option</code> and <code>Result</code> types to formally pass errors up through your call chain.</p>
<p>The nuclear option for truly exceptional situations is the <code>panic</code>. This is a little like an uncaught exception in that it will cause the entire thread to unwind. If the main thread panics then the process terminates.</p>
<p>A <code>panic!()</code> can be caught in some situations and recovered from in some scenarios but it should still be thought of as the nuclear option.</p>
<p>Lacking exceptions might seem a bad idea but C++ demonstrates that they come with a whole raft of considerations of their own.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates-vs-generics"><a class="header" href="#templates-vs-generics">Templates vs Generics</a></h1>
<h2 id="whats-a-template"><a class="header" href="#whats-a-template">What's a template?</a></h2>
<p>C++ provides a way of substituting types and values into inline classes and functions called templates. Think of it as a sophisicated substitution macro - you specify a type T in the template and this can substitute for a type <code>int</code> or something else at compile time. During compilation you'll be told if there are any errors with the type you supply. This is a very powerful feature since it allows a class to be reused for many different types.</p>
<p>Templates are used extensively in the C++ library, Boost and in other places. Collections, strings, algorithms and various other piece of code use templates in one form or another.</p>
<p>However, templates only expand into code when something actually calls the inline function. Then, if the template calls other templates, the inline code is expanded again and again until there is a large body of code which can be compiled. A small error in our code can propogate into an enormous wall of noise in the middle of some expanded template.</p>
<p>For example a vector takes a type it holds as a template parameter. So we can create a vector of PatientRecords.</p>
<pre><code class="language-c++">class PatientRecord {
  std::string name_;

  PatientRecord() {}
  PatientRecord operator= (const PatientRecord &amp;other) { return *this; }

public:
  PatientRecord(const std::string &amp;name) : name_(name) {
  }
};
...
std::vector&lt;PatientRecord&gt; records;
</code></pre>
<p>So far so good. So let's add a record:</p>
<pre><code class="language-c++">records.push_back(PatientRecord(&quot;John Doe&quot;));
</code></pre>
<p>That works too! Now let's try to erase the record we just added:</p>
<pre><code class="language-c++">records.erase(records.begin());
</code></pre>
<p>Boom!</p>
<pre><code>c:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h: In instantiation of 'static _OI std::__copy_move&lt;true, false, std::random_access_iterator_tag&gt;::__copy_m(_II, _II, _OI) [with _II = PatientRecord*; _OI = PatientRecord*]':
c:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h:396:70:   required from '_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = true; _II = PatientRecord*; _OI = PatientRecord*]'
c:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h:434:38:   required from '_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = true; _II = __gnu_cxx::__normal_iterator&lt;PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;; _OI = __gnu_cxx::__normal_iterator&lt;PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;]'
c:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h:498:47:   required from '_OI std::move(_II, _II, _OI) [with _II = __gnu_cxx::__normal_iterator&lt;PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;; _OI = __gnu_cxx::__normal_iterator&lt;PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;]'
c:/mingw/i686-w64-mingw32/include/c++/bits/vector.tcc:145:2:   required from 'std::vector&lt;_Tp, _Alloc&gt;::iterator std::vector&lt;_Tp, _Alloc&gt;::_M_erase(std::vector&lt;_Tp, _Alloc&gt;::iterator) [with _Tp = PatientRecord; _Alloc = std::allocator&lt;PatientRecord&gt;; std::vector&lt;_Tp, _Alloc&gt;::iterator = __gnu_cxx::__normal_iterator&lt;PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;; typename std::_Vector_base&lt;_Tp, _Alloc&gt;::pointer = PatientRecord*]'
c:/mingw/i686-w64-mingw32/include/c++/bits/stl_vector.h:1147:58:   required from 'std::vector&lt;_Tp, _Alloc&gt;::iterator std::vector&lt;_Tp, _Alloc&gt;::erase(std::vector&lt;_Tp, _Alloc&gt;::const_iterator) [with _Tp = PatientRecord; _Alloc = std::allocator&lt;PatientRecord&gt;; std::vector&lt;_Tp, _Alloc&gt;::iterator = __gnu_cxx::__normal_iterator&lt;PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;; typename std::_Vector_base&lt;_Tp, _Alloc&gt;::pointer = PatientRecord*; std::vector&lt;_Tp, _Alloc&gt;::const_iterator = __gnu_cxx::__normal_iterator&lt;const PatientRecord*, std::vector&lt;PatientRecord&gt; &gt;; typename __gnu_cxx::__alloc_traits&lt;typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type&gt;::const_pointer = const PatientRecord*]'
..\vectest\main.cpp:22:34:   required from here
..\vectest\main.cpp:8:19: error: 'PatientRecord PatientRecord::operator=(const PatientRecord&amp;)' is private
     PatientRecord operator= (const PatientRecord &amp;other) { return *this; }
</code></pre>
<p>If you wade through that noise to the bottom we can see the erase() function wanted to call the assignment operator on PatientRecord, but couldn't because it was private.</p>
<p>But why did vector allow us to declare a vector with a class which didn't meet its requirements?</p>
<p>We were able to declare the vector, use the std::vector::push_back() function but when we called std::vector::erase() the compiler discovered some deeply nested error and threw these errors back at us.</p>
<p>The reason is that C++ only generates code for templates when it is called. So the declaration was not in violation, the push_back() was not in violation but the erase was.</p>
<h2 id="how-rust-helps-13"><a class="header" href="#how-rust-helps-13">How Rust helps</a></h2>
<p>Rust has a concept similar to templates called generics. A generics is a struct or trait that takes type parameters just like a template.</p>
<p>However but the type can be enforced by saying the traits that it must implement. In addition any errors are meaningful.</p>
<p>Say we want to write a generic function that clones the input value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn clone_something&lt;T&gt;(value: T) -&gt; T {
  value.clone()
}
<span class="boring">}
</span></code></pre></pre>
<p>We haven't even called the function yet, merely defined it. When we compile this, we'll instantly get an error in Rust.</p>
<p>error: no method named <code>clone</code> found for type <code>T</code> in the current scope</p>
<pre><code>  |
4 |   value.clone();
  |         ^^^^^
  |
  = help: items from traits can only be used if the trait is implemented and in scope; the following trait defines an item `clone`, perhaps you need to implement it:
  = help: candidate #1: `std::clone::Clone`
</code></pre>
<p>Rust is saying we never said what T was and because some-random-type has no method called clone() we got an error.
So we'll modify the function to add a trait bound to T. This binding says T must implement Clone:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn clone_something&lt;T: Clone&gt;(value: T) -&gt; T {
  value.clone();
}
<span class="boring">}
</span></code></pre></pre>
<p>Now the compiler knows T must have implement Clone it is able to resolve clone() and be happy.
Next we actually call it to see what happens:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WhatHappensToMe;
let x = clone_something(10);
let y = clone_something(WhatHappensToMe{});
<span class="boring">}
</span></code></pre></pre>
<p>We can clone the integer 10 because integers implement the Clone trait, but our empty struct WhatHappensToMe does not implement Clone trait. So when we compile it we get an error.</p>
<pre><code>error[E0277]: the trait bound `main::WhatHappensToMe: std::clone::Clone` is not satisfied
  |
8 | let y = clone_something(WhatHappensToMe{});
  |         ^^^^^^^^^^^^^^^
  |
  = note: required by `main::clone_something`
</code></pre>
<p>In summary, Rust improves on templates by TODO</p>
<p>Compiling generic functions / structs even when they are unused and offer meaningful errors immediately.</p>
<p>Allow us to bind traits to generic types to constrain what we can pass into them.</p>
<p>Offer meaningful errors if we violate the requirements of the trait bounds</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h1>
<p>C++ allows code to inherit from multiple classes and they in turn could inherit from other classes. This gives rise to the dreaded <em>diamond pattern</em>.</p>
<p>e.g. D inherits from B and C but B and C both inherit from A. So does D have two instances of A or one?</p>
<p>This can cause compiler errors which are only partially solved by using something called &quot;virtual inheritance&quot; to convince the compiler to share A between B and C.</p>
<p>i.e if we knew B and C could potentially be multiply inherited we might declare them with a virtual keyword in their inheritance:</p>
<pre><code class="language-c++">class B : public virtual A {
//...
};
class C: public virtual A {
};
class D: public B, public C {
//...
};
</code></pre>
<p>When D inherits from B and C, both share the same instance of A. But that assumes the authors of A, B and C were aware of this problem arising and coded themselves with the assumption that A could be shared.</p>
<p>The more usual normal solution for diamond patterns is &quot;don't do it&quot;. i.e use composition or something to avoid the problem.</p>
<h2 id="how-rust-helps-14"><a class="header" href="#how-rust-helps-14">How Rust helps</a></h2>
<p>Rust also does not use class inheritance so problems like diamond patterns cannot exist.</p>
<p>However traits in Rust can inherit from other traits, so potentially it could have diamond-like issues. But to ensure it doesn't, the base trait is implemented separately from any traits that inherit from it.</p>
<p>So if struct D implements traits B &amp; C and they inherit from A, then A, B and C must have impl blocks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A {
//...
}

trait B : A {
//...
}

trait C : A {
//...
}

struct D;

impl A for D {
//...
}

impl B for D {
//...
}

impl C for D {
//...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linker-errors"><a class="header" href="#linker-errors">Linker Errors</a></h1>
<p>C and C++ requires you supply a list of all the .obj files that form part of your library or executable.</p>
<p>If you omit a file by accident you will get undefined or missing references. Maintaining this list of files is an additional burden of development, ensuring to update your makefile or solution every time you add a file to your project.</p>
<h2 id="how-rust-helps-15"><a class="header" href="#how-rust-helps-15">How Rust Helps</a></h2>
<p>Rust includes everything in your library / executable that is directly or indirectly referenced by mod commands, starting from your toplevel lib.rs or main.rs and working all the way down.</p>
<p>Providing you reference a module, it will be automatically built and linked into your binary.</p>
<p>If you use the <code>cargo</code> command, then the above also applies for external crates that you link with. The cargo command will
also check for version conflicts between external libraries. If you find your cargo generating errors about compatibility
conflicts between crates you may be able to resolve them by updating the Cargo.lock file like so:</p>
<pre><code>cargo update
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-rust"><a class="header" href="#debugging-rust">Debugging Rust</a></h1>
<p>Rust compiles into machine code the same as C and benefits from sharing the same ABI and compiler backend formats as C/C++.</p>
<p>So you can debug Rust in the same way as C/C++. If you built your Rust executable in a gcc compatible binary format you can just invoke gdb on it:</p>
<pre><code>gdb my_executable
</code></pre>
<p>Rust comes with a gdb wrapper script called <code>rust-gdb</code> that loads macros which perform syntax highlighting.</p>
<h2 id="enabling-backtrace"><a class="header" href="#enabling-backtrace">Enabling backtrace</a></h2>
<p>If your code is crashing because of a panic!() you can get a backtrace on the console by setting the <code>RUST_BACKTRACE</code> environment variable.</p>
<pre><code># Windows
set RUST_BACKTRACE=1
# Unix/Linux
export RUST_BACKTRACE=1
</code></pre>
<h2 id="find-out-your-target-binary-format"><a class="header" href="#find-out-your-target-binary-format">Find out your target binary format</a></h2>
<p>If you are in doubt what you are targeting, you may use <code>rustup</code> to show you.</p>
<pre><code>c:\dev\visu&gt;rustup show
Default host: x86_64-pc-windows-msvc

stable-x86_64-pc-windows-msvc (default)
rustc 1.13.0 (2c6933acc 2016-11-07)
</code></pre>
<p>Or perhaps:</p>
<pre><code>[foo@localhost ~]$ rustup show
Default host: x86_64-unknown-linux-gnu

stable-x86_64-unknown-linux-gnu (default)
rustc 1.13.0 (2c6933acc 2016-11-07)
</code></pre>
<p>The information will tell you which debugger you can use to debug your code.</p>
<h3 id="microsoft-visual-studio"><a class="header" href="#microsoft-visual-studio">Microsoft Visual Studio</a></h3>
<p>If you have the MSVC toolchain (32 or 64-bit) or the LLVM backend will generate a .pdb file and binaries will be compatible with the standard MSVC runtime.</p>
<p>To debug your code:</p>
<ol>
<li>Open Visual Studio</li>
<li>Choose File | Open | Project/Solution...</li>
<li>Select the compiled executable</li>
<li>Open a source file to debug and set a breakpoint</li>
<li>Click the &quot;Start&quot; button</li>
</ol>
<h3 id="gdb-1"><a class="header" href="#gdb-1">GDB</a></h3>
<p>GDB can be invoked directly from the command line or through a plugin / IDE. From the command line it's a</p>
<p>TODO</p>
<h3 id="lldb"><a class="header" href="#lldb">LLDB</a></h3>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>The memory model of Rust is quite close to C and C++. Structures that you declare in Rust reside on the stack or they reside in the heap.</p>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<p>The stack is a memory reserved by the operating system for each thread in your program. Stack is reserved for local variables based upon their predetermined size by moving a stack pointer register forward by that amount. When the local variables go out of scope, the stack pointer reduces by the same amount.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stack allocated
double pi = 3.141592735;
{
  // Stack pointer moves as values goes in and out of scope
  int values[20] = { 0, 1, 2, 3, ... , 19, 20 };
}
<span class="boring">}
</span></code></pre></pre>
<p>In C-style languages it is normal for the stack in each thread to be a single contiguous slab of memory that represents the &quot;worst case&quot; scenario for your program i.e. you will never need any more stack than the thread allocated at start. If you do exceed the stack, then you cause a stack overflow.</p>
<p>Some languages support the concept of split or segmented stack. In this case, the stack is a series of &quot;stacklets&quot; joined together by a linked list. When the stack is insufficient for the next call, it allocates another stacklet.</p>
<p>The gcc can support a segmented stack, but it greatly complicates stack unwinding when an exception is thrown and also when calls are made across linker boundaries, e.g. between a segmented-stack aware process and a non segmented stack dynamic library.</p>
<h2 id="stack-overflows"><a class="header" href="#stack-overflows">Stack Overflows</a></h2>
<p>The main worry from using the stack is the possibility of a stack overflow, i.e the stack pointer moves out of the memory reserved for the stack and starts trampling on other memory.</p>
<p>This can occur in two common ways in isolation or combination:</p>
<ul>
<li>Deeply nested function calls, e.g. a recursive function that traverses a binary tree, or a recursive function that never stops</li>
<li>Exhausting stack by using excessive and/or large local variables in functions, e.g. lots of 64KB byte arrays.</li>
</ul>
<h3 id="c-11"><a class="header" href="#c-11">C++</a></h3>
<p>Some C++ compilers won't catch an overflow at all. They have no guard page and thus allow the stack pointer to just grow whereever memory takes it until the program is destabilized and crashes.</p>
<p>The gcc compiler has support segmented stacks but as described earlier not without issue.</p>
<p>The MSVC compiler adds a guard page and stack pointer checks when when the stack pointer could advance more than a page in a single jump and potentially miss the guard page.</p>
<h3 id="rust-15"><a class="header" href="#rust-15">Rust</a></h3>
<p>Rust used to support a segmented stack as a means of detecting memory violation but since 1.4 has replaced it with a guard page at the end of the stack space. If the guard page is touched by a memory write, it will generate a segmentation fault that halts the thread. Guard pages open up a small risk that the stack could grow well in excess of the guard and it might take some time for a write to the guard to generate a fault.</p>
<p>Rust aspires to support stack probe code generation on all platforms at which point it is likely to use that in addition to a guard page. A stack probe is additional generated code on functions that use more than a page of space for local variables to test if they exceed the stack.</p>
<p>Rust reduces the risk stack overflows in some indirect ways. It's easy in C++ through inheritance or by calling a polymorphic method inadvertently set off a recursive loop</p>
<h2 id="heap"><a class="header" href="#heap">Heap</a></h2>
<p>Heap is a memory that the language runtime requests from the operating system and makes available to your code through memory allocation calls</p>
<p>C++</p>
<pre><code class="language-c++">char * v = (char *) malloc(128);
memset(v, 0, 128);
strcpy(v, &quot;Hello world&quot;);
//...
free(string);

double *values = new double[10];
for (int i = 0; i &lt; 10; i++) {
  values[i] = double(i);
}
delete []values;
</code></pre>
<p>Allocation simply means a portion of the heap is marked as in-use and the code is provided with a pointer to the reserved area to do what it likes with. Free causes the portion to be returned to its free state, coalescing with any free areas that it resides next to in memory.</p>
<p>A heap can grow and code might create multiple heaps and might even be compelled to in order control problems such as heap fragmentation.</p>
<h3 id="rust-16"><a class="header" href="#rust-16">Rust</a></h3>
<p>To allocate memory on the heap in Rust you declare data inside of a a box. For example to create a 1k block of bytes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Box&lt;[u8]&gt; = Box::new([0; 1024]);
<span class="boring">}
</span></code></pre></pre>
<p>Many structs in std:: and elsewhere will have a stack based portion and also use use heap internally to hold their buffers.</p>
<h2 id="stack-unwinding"><a class="header" href="#stack-unwinding">Stack unwinding</a></h2>
<h2 id="heap-fragmentation"><a class="header" href="#heap-fragmentation">Heap fragmentation</a></h2>
<p>Heap fragmentation happens when contiguous space in the heap is limited by the pattern of memory allocations that it already contains. When this happens a memory allocation can fail and the heap must be grown to make it succeed. In systems which do not have virtual memory / paging, memory exhaustion caused by fragmentation can cause the program or even the operating system to fail completely.</p>
<p>The easiest way to see fragmentation is with a simple example. We'll pretend there is no housekeeping structures, guard blocks or other things to get in the way. Imagine a 10 byte heap, where every byte is initially free.</p>
<p>Now allocate 5 bytes for object of type A. The heap reserves 5 bytes and marks them used.</p>
<p><img src="12_memory_management//assets/aaaaa-----.png" alt="" /></p>
<p>Now allocate 1 byte for object of type B. This is also marked used.</p>
<p><img src="12_memory_management//assets/aaaaaab.png" alt="" /></p>
<p>Now free object A. The the portion of heap is marked unused. Now we have a block of 5 bytes free and a block with 4 bytes free.</p>
<p><img src="12_memory_management//assets/-----b----.png" alt="" /></p>
<p>Now allocate 2 bytes for object of type C. Now we have a block of 3 bytes free and a block with 4 bytes free.</p>
<p><img src="12_memory_management//assets/cc---b----.png" alt="" /></p>
<p>Now allocate 5 slots for object of type A - Oops we can't! The heap has 7 bytes free but they are not contiguous. At this point the runtime would be forced to grow the heap, i.e. ask the operating system for another chunk of memory at which point it can allocate 5 bytes for A.</p>
<p><img src="12_memory_management//assets/cc---baaaaa---.png" alt="" /></p>
<p>The above assumes the heap is a contiguous, or that memory paging makes it seem so. On some systems, it might be that the heap is a linked list of chunks, in which case the allocated space for A would have to reside be in a single chunk, the newly allocated portion above.</p>
<p>This is also an exagerated example, but it demonstrates how heap can have space, but not enough to fufilly allocations without growing.</p>
<p>Software running in embedded devices are particularly vulnerable to fragmentation because they do not have virtual memory, have low physical memory and normally have to run for days, weeks or years at a time.</p>
<p>One major problem for C++ is that heap fragmentation is almost impossible to avoid. The standard template library allocates memory for virtually all string and collection work, and if a string / collection grows then it may have to reallocate more memory.</p>
<p>The only way to mitigate the issue is to choose the best collection, and to reserve capacity wherever possible.</p>
<pre><code class="language-c++">std::vector&lt;double&gt; values;
values.reserve(10);
for (int i = 0; i &lt; 10; i++) {
  values.push_back(double(i));
}
</code></pre>
<p>Rust also has this issue and strings / collections have methods to reserve capacity. But as a consequence of its design it prefers the stack over the heap. Unless you explicitly allocate memory by putting it into a Box, Cell or RefCell you do not allocate it on the heap.</p>
<h2 id="raii"><a class="header" href="#raii">RAII</a></h2>
<p>RAII stands for Resource Acquisiton Is Initalization. It's a programming pattern that ties access to some resource the object's lifetime</p>
<p>C++ classes allow a pattern called RAII (). A class constructor acquires some resource, the destructor releases that resource. As soon as the class goes out of scope, the resource is released.</p>
<p>**TODO **C++ example</p>
<p>Rust is inherently RAII and enforces it through lifetimes. When an object goes out of scope, the thing it holds is released. Rust also allows the programmer to explicitly drop a struct earlier than its natural lifetime if there is a reason to.</p>
<p>RAII is most commonly seen for heap allocated memory but it can apply to files, system handles etc.</p>
<p>**TODO **Rust example</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rusts-standard-library"><a class="header" href="#rusts-standard-library">Rust's standard library</a></h1>
<p>The core functionality in Rust is provided by a module called <code>std</code>. This is the standard runtime library.</p>
<p>As with its C++ namesake, everything can be referenced through a <code>std::</code> namespace prefix or via a <code>use std::{foo}</code> import.</p>
<p>The most commonly used parts of <code>std</code> are implicitly brought in as if you had typed this at the top of your code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate std;
use std::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://doc.rust-lang.org/beta/std/prelude/"><code>std::prelude</code></a> contains the most commonly used parts of std that you can just implicitly reference. For example:</p>
<ul>
<li><code>String</code> and <code>ToString</code> trait</li>
<li>Iterators traits of various kinds - <code>Iterator</code>, <code>IntoIterator</code> etc.</li>
<li><code>Result&lt;&gt;</code> and <code>Option&lt;&gt;</code> enums</li>
<li>Conversion traits <code>AsRef</code>, <code>AsMut</code>, <code>Into</code>, <code>From</code></li>
<li><code>Vec</code> heap allocated vector</li>
<li>Common traits such as <code>Drop</code>, <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>, <code>Box</code>, <code>Clone</code>, <code>Copy</code>, <code>Send</code>, <code>Sized</code>, <code>Sync</code>, <code>PartialEq</code>, <code>PartialOrd</code> etc.</li>
<li>Macros such as <code>println!</code>, <code>format!</code>, <code>assert!</code> etc.</li>
</ul>
<p>There are various sub-modules under std that concern themselves with aspects of development. Here are just some of them:</p>
<ol>
<li>clone â€“ the <code>Clone</code> trait</li>
<li>cmp â€“ <code>Eq</code>, <code>Ord</code>, <code>PartialEq</code>, <code>PartialOrd</code> traits. These traits are used for equality and ordering functionality.</li>
<li>collections - contains the standard collection types for sequences, maps, sets, and miscellaneous. e.g. <code>Vec</code> and <code>HashMap</code> are members of this module.</li>
<li>env â€“ environmental helpers - command line arguments, status codes, environment variables, temporary folder</li>
<li>fmt â€“ utilities for formatting and printing strings</li>
<li>fs - filesystem manipulation</li>
<li>io â€“ Read and Write traits that are implemented by streams / buffers in file system and networking, stdio functionality</li>
<li>mem â€“ memory primitives</li>
<li>net â€“ networking</li>
<li>path â€“ path manipulation</li>
<li>process â€“ spawn, fork, exec etc.</li>
</ol>
<p>Anything not brought in by <code>std::prelude</code> can be pulled in through a <code>use</code> statement:</p>
<pre><code>use std::collections::BTreeMap;
</code></pre>
<h2 id="c--c-lib-to-rust-lib-cross-reference"><a class="header" href="#c--c-lib-to-rust-lib-cross-reference">C / C++ lib to Rust lib cross reference</a></h2>
<p>TODO</p>
<p>Note that Rust's std namespace contains a lot of stuff not in the standard C or C++ libraries and a lot of things are not directly analogous.
For example the standard C / C++ library have very little to say about sockets, or path manipulation, or atomically incrementing numbers, or creating threads.</p>
<div class="table-wrapper"><table><thead><tr><th>C</th><th>C++</th><th>Rust</th></tr></thead><tbody>
<tr><td>T [S], e.g. char foo[20]</td><td>std::array (C++11)</td><td>[T; S], e.g. let foo: [u8; 20] = [0; 20]</td></tr>
<tr><td>char * or char[] with functions such as strcmp, strcpy, strstr, strdup etc. Plus wide equivalents to these.</td><td>std::string, std::wstring, std::u16string (C++11), std::u32string (C++11)</td><td>&amp;str or String as appropriate</td></tr>
</tbody></table>
</div>
<ul>
<li>| std::vector | std::vec::Vec or std::collections::VecDeque</li>
<li>| std::list | std::collections::LinkedList</li>
<li>| std::set | std::collections::HashSet, std::collections::BTreeSet</li>
<li>| std::map | std::collections::HashMap, std::collections::BTreeMap
fopen, fclose, fread / fwrite, fseek etc. | std::ofstream, std::ifstream, std::fstream | TODO
Math functions such as cos, sin, tan, acos, asin, atan, pow, abs, log, log10, floor, ceil are defined in &lt;math.h&gt; | - | Math functions are direction accessible from f64. f32 types., e.g. 1.0f64.cos().</li>
</ul>
<p>Note that because due to the decimal point being used on a float, you have to prefix f32 or f64 to literals when you call them so the compiler can figure out what you're doing.</p>
<h2 id="standard-traits"><a class="header" href="#standard-traits">Standard Traits</a></h2>
<p>Commonly used traits are defined in <code>std</code> and in some cases can be derived automatically via compiler directives.</p>
<p>In others they cause the compiler to generate additional code for you such as the <code>Drop</code> trait (described in class destructor section)</p>
<h3 id="drop"><a class="header" href="#drop">Drop</a></h3>
<p>The <code>Drop</code> trait allows you do something when an object is dropped, such as add additional logging or whatever.</p>
<h3 id="copy"><a class="header" href="#copy">Copy</a></h3>
<p>A struct implementing a Copy trait can be copied through assignment, i.e. if you assign a to b then a and b now how copies of the object, independent of each other.
The Copy trait really only useful when you have small amounts of data that represent a type or value of some kind.
TODO copy example, e.g. <code>struct PlayingCard { suit: Suit, rank: Rank }</code>
If you find yourself with a type that is larger, or contains heap allocated memory then you should use clone.</p>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<p>A struct implementing the Clone trait has a .clone() method. Unlike Copy you must explicitly .clone() the instance to create another.
TODO clone example</p>
<h3 id="eq-partialeq"><a class="header" href="#eq-partialeq">Eq, PartialEq</a></h3>
<p>TODO equality</p>
<h3 id="ord-partialord"><a class="header" href="#ord-partialord">Ord, PartialOrd</a></h3>
<p>TODO ordering</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-cookbook"><a class="header" href="#rust-cookbook">Rust Cookbook</a></h1>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<h3 id="convert-a-number-to-a-string"><a class="header" href="#convert-a-number-to-a-string">Convert a number to a string</a></h3>
<p>Let's say you have an integer you want to turn into a string.</p>
<p>In C++ you might do one of the following:</p>
<pre><code class="language-c++">const int value = 17;
std::string value_as_string;

// Nonstandard C itoa() (also not thread safe)
value_as_string = itoa(value);

// OR _itoa()
char buffer[16];
_itoa(value, buffer, 10);

// OR
sprintf(buffer, &quot;%d&quot;, value);

// OR
stringstream ss;
ss &lt;&lt; value;
value_as_string = ss.str();

// OR (boost)
value_as_string = boost::lexical_cast&lt;std::string&gt;(ivalue);
</code></pre>
<p>All of these have issues. Some are extensions to the standard, others may not be thread safe, some may break if <code>value</code> was changed to another type, e.g. <code>long long</code>.</p>
<p>Rust makes it far easier because numeric primitives implement a trait called ToString. The ToString trait has a to_string() function. So to convert the number to string is as simple as this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 17u32;
let value_as_string = value.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>The same is true for a floating point number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 100.00345f32;
let value_as_string = value.to_string();
<span class="boring">}
</span></code></pre></pre>
<h3 id="convert-a-number-to-a-string-with-precision--padding"><a class="header" href="#convert-a-number-to-a-string-with-precision--padding">Convert a number to a string with precision / padding</a></h3>
<p>In C you would add precision of padding using printf operations:</p>
<pre><code class="language-c++">double value = 1234.66667;
char result[32];
sprintf(result, &quot;%08.2d&quot;, value);
</code></pre>
<p>In C++ you could use the C way (and to be honest it's easier than what is written below), or you can set padding and precision through an ostream:</p>
<pre><code class="language-c++">// TODO validate
double value = 1234.66667;
ostringstream ss;
ss &lt;&lt; setfill('0') &lt;&lt; setw(8) &lt;&lt; setprecision(2) &lt;&lt; value;
</code></pre>
<p>In Rust you can use format!() [https://doc.rust-lang.org/std/fmt/] for this purpose and it is similar to printf / sprintf:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 1234.66667;
let value_as_string = format!(&quot;{:08.2}&quot;, value);
println!(&quot;value = {}&quot;, value_as_string);
<span class="boring">}
</span></code></pre></pre>
<p>Output</p>
<pre><code>value = 01234.67
</code></pre>
<h3 id="convert-a-number-to-a-localized-string"><a class="header" href="#convert-a-number-to-a-localized-string">Convert a number to a localized string</a></h3>
<p>Some locales will use dots or commas for separators. Some languages will use dots or commas for the decimal place. In order to format these strings we need to make use of the locale.</p>
<p>TODO</p>
<h3 id="convert-a-string-to-a-number"><a class="header" href="#convert-a-string-to-a-number">Convert a string to a number</a></h3>
<p>In C / C++ a number might be converted from a string to a number in a number of ways</p>
<pre><code class="language-c++">
int value = atoi(value_as_str);

</code></pre>
<p>TODO</p>
<p>In Rust we have a &amp;str containing a number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value_as_str = &quot;12345&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Any type that implements a trait called FromStr can take its type from a string. All the standard primitive types implement FromStr so we can simply say this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value_as_str = &quot;12345&quot;;
let value = i32::from_str(value_as_str).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Note the unwrap() at the end - the FromStr::from_str() returns the value inside a Result&lt;value, error&gt;, to allow for the possibility that the string cannot be parsed. Production code should test for errors before calling unwrap() or it will panic.</p>
<p>Another way to get the string is to call parse() on the &amp;str or String itself. In this case, you use a slightly odd looking syntax nicknamed 'turbofish' which looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;
let value_as_str = &quot;12345&quot;;
let value = value_as_str.parse::&lt;i32&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The string's implementation of parse() is a generic that works with any type implementing <code>FromStr</code>. So calling <code>parse::&lt;i32&gt;</code> is equivalent to calling <code>i32::from_str()</code>.</p>
<p>Note one immediate advantage of Rust is it uses string slices. That means you could have a long string with many numbers separated by delimiters and parse numbers straight out of the middle of it without constructing intermediate copies.</p>
<h3 id="converting-between-numeric-types"><a class="header" href="#converting-between-numeric-types">Converting between numeric types</a></h3>
<p>Converting between numeric types is as easy as using the &quot;as&quot; keyword.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = 1234.42f32;
let i = f as i32;
println!(&quot;Value = {}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<p>The result in i is the integer part of f.</p>
<pre><code>Value = 1234
</code></pre>
<h2 id="strings-1"><a class="header" href="#strings-1">Strings</a></h2>
<p>Rust comes with some very powerful functions that are attached to every &amp;str and String type. These mostly correspond to what you may be used to on the std::string class and in boost string algorithms.</p>
<p>Most find / match / trim / split string operations in Rust are efficient because they neither modify the existing string, nor return a duplicate to you. Instead they return slices, i.e. a pointer and a length into your existing string to denote the range that is the result.</p>
<p>It is only operations that modify the string contents themselves such as creating upper or lowercase versions that will return a new copy of a string.</p>
<h3 id="trimming-a-string"><a class="header" href="#trimming-a-string">Trimming a string</a></h3>
<p>Spaces, tabs and other Unicode characters defined as whitespace can be trimmed from a string.</p>
<p>All strings have access to the following functions</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trim(&amp;self) -&gt; &amp;str
fn trim_left(&amp;self) -&gt; &amp;str
fn trim_right(&amp;self) -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<p>Note the signatures of these functions - they are not mutable. The functions return a slice of the string that excludes the leading and / or trailing whitespace removed. In other words it is not duplicating the string, nor is it modifying the existing string. Instead it is just telling you what the trimmed range is within the &amp;str you're already looking at.</p>
<p>So</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let untrimmed_str = &quot; this is test with whitespace    \t&quot;;
let trimmed_str = untrimmed_str.trim();
println!(&quot;Trimmed str = \&quot;{}\&quot;&quot;, trimmed_str);
<span class="boring">}
</span></code></pre></pre>
<p>Yields:</p>
<pre><code>Trimmed str = &quot;this is test with whitespace&quot;
</code></pre>
<p>Also be aware that trim_left() and and trim_right() above are affected by the directionality of the string.</p>
<p>Most strings read from left-to-right, but strings in Arabic or Hebrew are read right-to-left and will start with a control character that sets their base direction right-to-left. If that character is present, trim_left() actually trims from the right and trim_right() trims from the left.</p>
<h3 id="get-the-length-of-a-string"><a class="header" href="#get-the-length-of-a-string">Get the length of a string</a></h3>
<p>Every &amp;str and String has a len() function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = &quot;All good things come to those who wait&quot;;
println!(&quot;Length = {}&quot;, message.len());
<span class="boring">}
</span></code></pre></pre>
<p>Note that len() is the length in bytes. If you want the number of characters you need to call message.chars().count(), e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = &quot;æ–‡å­—åˆ—ã®é•·ã•&quot;;
assert_eq!(message.chars().count(), 6);
<span class="boring">}
</span></code></pre></pre>
<h3 id="splitting-a-string"><a class="header" href="#splitting-a-string">Splitting a string</a></h3>
<p>String slices and String have a variety of <code>split</code> methods that return an iterable collection of slices on a string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let input = &quot;20,30,400,100,21,-1&quot;;
let values : Vec&lt;&amp;str&gt; = input.split(&quot;,&quot;).collect();
for (i, s) in values.iter().enumerate() {
    println!(&quot;Value {} = {}&quot;, i, s);
}
<span class="boring">}
</span></code></pre></pre>
<p>The standard <code>split()</code> takes a string pattern for the delimiter and returns a <code>std::str::Split</code> struct that is an double-ended iterator representation of the matching result. We could call the iterator directly if we so wished but the <code>collect()</code> method above puts the values of the iterator into a <code>Vec&lt;&amp;str&gt;</code>.</p>
<pre><code>Value 0 = 20
Value 1 = 30
Value 2 = 400
Value 3 = 100
Value 4 = 21
Value 5 = -1
</code></pre>
<p>A string can also be split on an index, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (left, right) = &quot;No Mister Bond I expect you to die&quot;.split_at(14);
println!(&quot;Left = {}&quot;, left);
println!(&quot;Right = {}&quot;, right);
<span class="boring">}
</span></code></pre></pre>
<p>Note that index is the <em>byte index</em>! The function will panic if the index is in the centre of a UTF-8 codepoint.</p>
<p>Another useful function is <code>split_whitespace</code> that splits on tabs, spaces, newlines and other Unicode whitespace. Any amount of whitespace is treated as a single delimiter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Split whitespace
for s in &quot; All good   \n\n\tthings  to those who    wait&quot;.split_whitespace() {
    println!(&quot;Part - {}&quot;, s);
}
<span class="boring">}
</span></code></pre></pre>
<p>Yields the output.</p>
<pre><code>Part - All
Part - good
Part - things
Part - to
Part - those
Part - who
Part - wait
</code></pre>
<h3 id="tokenizing-a-string"><a class="header" href="#tokenizing-a-string">Tokenizing a string</a></h3>
<p>TODO</p>
<h3 id="joining-strings-together"><a class="header" href="#joining-strings-together">Joining strings together</a></h3>
<p>TODO</p>
<h3 id="getting-a-substring"><a class="header" href="#getting-a-substring">Getting a substring</a></h3>
<p>TODO</p>
<h3 id="converting-a-string-between-upper-and-lower-case"><a class="header" href="#converting-a-string-between-upper-and-lower-case">Converting a string between upper and lower case</a></h3>
<p>Strings have these functions for converting between upper and lower case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_lowercase(&amp;self) -&gt; String
fn to_uppercase(&amp;self) -&gt; String
<span class="boring">}
</span></code></pre></pre>
<p>These functions will return a new String that contains the upper or lower case version of the input. Upper and lower case are defined by Unicode rules. Languages that have no upper or lowercase strings may return the same characters.</p>
<h3 id="doing-a-case-insensitive-compare"><a class="header" href="#doing-a-case-insensitive-compare">Doing a case insensitive compare</a></h3>
<p>TODO</p>
<h3 id="using-regular-expression-matches"><a class="header" href="#using-regular-expression-matches">Using regular expression matches</a></h3>
<p>TODO</p>
<h2 id="date-and-time"><a class="header" href="#date-and-time">Date and Time</a></h2>
<h3 id="get-the-current-date-and-time"><a class="header" href="#get-the-current-date-and-time">Get the current date and time</a></h3>
<p>TODO time_rs</p>
<h3 id="utc"><a class="header" href="#utc">UTC</a></h3>
<p>TODO explain what UTC is and why maintaining time in UTC is vital Epochs etc.
TODO preamble about what an epoch is, the Unix epoch and other epochs</p>
<h3 id="setting-a-timer"><a class="header" href="#setting-a-timer">Setting a timer</a></h3>
<p>TODO setting a timer</p>
<h3 id="system-time-vs-utc"><a class="header" href="#system-time-vs-utc">System time vs UTC</a></h3>
<p>TODO the reason timers might be set in system uptime vs timers being set in UTC. Answer because users and NTP can change the UTC time wherease system time is relative to bootup. So setting a timer to run 10s from now will always work against system time where setting a timer to run 10s from now in UTC could fail if the OS sets time back by an hour.</p>
<h3 id="formatting-a-date-as-a-string"><a class="header" href="#formatting-a-date-as-a-string">Formatting a date as a string</a></h3>
<p>TODO standard date formatting UTC
TODO example</p>
<h3 id="parsing-a-date-from-a-string"><a class="header" href="#parsing-a-date-from-a-string">Parsing a date from a string</a></h3>
<p>TODO parsing a date from a string's
TODO example</p>
<h3 id="performing-date--time-arithmetic"><a class="header" href="#performing-date--time-arithmetic">Performing date / time arithmetic</a></h3>
<h2 id="collections-1"><a class="header" href="#collections-1">Collections</a></h2>
<h3 id="creating-a-static-array"><a class="header" href="#creating-a-static-array">Creating a static array</a></h3>
<p>An array primitive consists of a type and a length. e.g. a 16 kilobyte array of bytes can be created and zeroed like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let values: [u8; 16384] = [0; 16384];
<span class="boring">}
</span></code></pre></pre>
<p>The variable specifies the type and length and the assignment operator assigns 0 to every element.</p>
<p>The type, length and values can be initialized implicitly in-place like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_array = [ &quot;Cat&quot;, &quot;Dog&quot;, &quot;Fish&quot;, &quot;Donkey&quot;, &quot;Albatross&quot; ];
println!(&quot;{:?}&quot;, my_array);
<span class="boring">}
</span></code></pre></pre>
<p>This is an array of 5 &amp;str values. The compiler will complain if we try to mix types in the array.
We could also declare the array and manipulate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_array: [&amp;'static str; 5] = [&quot;&quot;; 5];
// Set some values
my_array[0] = &quot;Cat&quot;;
my_array[1] = &quot;Dog&quot;;
my_array[2] = &quot;Fish&quot;;
my_array[3] = &quot;Donkey&quot;;
my_array[4] = &quot;Albatross&quot;;
println!(&quot;{:?}&quot;, my_array);
<span class="boring">}
</span></code></pre></pre>
<p>Note in this case we declared the array, each element received an empty value. Then our code programmatically set the new element value.
The latter form would obviously be useful for arrays that change. The latter would be useful for arrays which do not.</p>
<h3 id="creating-a-dynamic-vector"><a class="header" href="#creating-a-dynamic-vector">Creating a dynamic vector</a></h3>
<p>A vector is a linear array of values. Unlike an array which has a fixed length, a vector can grow or shrink over time.</p>
<p>A vector can be created using the vec! macro like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_vector = vec![1984, 1985, 1988, 1995, 2001];
<span class="boring">}
</span></code></pre></pre>
<p>This creates a mutable Vec and prepopulates it with 5 values. Note how the vec! macro can use square brackets for its arguments. We could have used round brackets and it would have meant the same.</p>
<p>A new Vec can also be made using Vec::new() or Vec::with_capacity(size)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_array = Vec::new();
my_array.push(&quot;Hello&quot;);
let my_presized_array = Vec::with_capacity(100);
<span class="boring">}
</span></code></pre></pre>
<p>It is strongly recommended you use Vec::with_capacity() to create a vector with enough capacity for maximum number of elements you expect the vector to contain. It prevents the runtime from having to reallocate and copy data if you keep exceeding the existing capacity. It also significantly reduces heap fragmentation.</p>
<h3 id="removing-values-from-a-vector"><a class="header" href="#removing-values-from-a-vector">Removing values from a vector</a></h3>
<p>Sometimes you want to strip out values from a list which match some predicate. In which case there is a handy function for that purpose.
TODO <code>.retain</code></p>
<h3 id="sorting-a-vector"><a class="header" href="#sorting-a-vector">Sorting a vector</a></h3>
<p>A vector can be sorted by the natural sort order of the elements it contains:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values = vec![ 99, -1, 3, 555, 76];
values.sort();
println!(&quot;Values = {:?}&quot;, values);
<span class="boring">}
</span></code></pre></pre>
<p>Sorting is done using the Ord trait and calling Ord::cmp() on the elements to compare them to each other.</p>
<p>Comparison can also be done through a closure and Vec::sort_by()</p>
<p>TODO <code>.sort_by</code>
TODO <code>.sort_by_key</code></p>
<h3 id="stripping-out-duplicates-from-a-vector"><a class="header" href="#stripping-out-duplicates-from-a-vector">Stripping out duplicates from a vector</a></h3>
<p>Assuming your vec is sorted, you can strip out consecutive duplicate entries using dedup().
This function won't work and the result will be undefined if your vector is not sorted.
TODO .dedup</p>
<h3 id="creating-a-linked-list"><a class="header" href="#creating-a-linked-list">Creating a linked list</a></h3>
<p>A linked list is more suitable than a vector when items are likely to be inserted or removed from either end or from points within the list.</p>
<p><code>std::collections::LinkedList</code></p>
<h3 id="creating-a-hash-set"><a class="header" href="#creating-a-hash-set">Creating a hash set</a></h3>
<p>A hash set is a unique collection of objects. It is particularly useful for removing duplicates that might occur in the input.
<code>std::collections::HashSet</code></p>
<h3 id="creating-a-hash-map"><a class="header" href="#creating-a-hash-map">Creating a hash map</a></h3>
<p>A hash map consists of a key and a value. It is used for look up operations
<code>std::collections::HashMap</code></p>
<h3 id="iterating-collections"><a class="header" href="#iterating-collections">Iterating collections</a></h3>
<p>TODO</p>
<h3 id="iterator-adaptors"><a class="header" href="#iterator-adaptors">Iterator adaptors</a></h3>
<p>TODO</p>
<p>An adaptor turns the iterator into a new value</p>
<p><code>.enum</code>
<code>.map(X)</code>
<code>.take(N)</code>
<code>.filter(X)</code></p>
<h3 id="consuming-iterators"><a class="header" href="#consuming-iterators">Consuming iterators</a></h3>
<p>A consumer is a convenience way of iterating a collection and producing a value or a set of values from the result.</p>
<p><code>.collect()</code></p>
<p><code>.find()</code> will return the first matching element that matches the closure predicate. TODO</p>
<p><code>.fold()</code> is a way of doing calculations on the collection. It takes a base value, and then calls a closure to accumulate the value upon the result of the last value. TODO
Processing collections</p>
<h2 id="localization"><a class="header" href="#localization">Localization</a></h2>
<h3 id="unicode-considerations"><a class="header" href="#unicode-considerations">Unicode considerations</a></h3>
<p>TODO</p>
<h3 id="externalizing-strings"><a class="header" href="#externalizing-strings">Externalizing strings</a></h3>
<p>TODO</p>
<h3 id="building-strings-from-parameters"><a class="header" href="#building-strings-from-parameters">Building strings from parameters</a></h3>
<p>TODO</p>
<h3 id="creating-a-localization-file"><a class="header" href="#creating-a-localization-file">Creating a localization file</a></h3>
<p>TODO</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<h2 id="files-and-streams"><a class="header" href="#files-and-streams">Files and streams</a></h2>
<p>Rust comes with two standard modules:</p>
<ul>
<li>std::io contains various stream related traits and other functionality.</li>
<li>std::fs contains filesystem related functionality including the implementation of IO traits to work with files.</li>
</ul>
<h3 id="creating-a-directory"><a class="header" href="#creating-a-directory">Creating a directory</a></h3>
<p>A directory can be created with <code>std::fs::DirBuilder</code>, e.g.</p>
<pre><code>let result = DirBuilder::new().recursive(true).create(&quot;/tmp/work_dir&quot;);
</code></pre>
<h3 id="file-paths"><a class="header" href="#file-paths">File paths</a></h3>
<p>Windows and Unix systems have different notation for path separators and a number of other differences. e.g. Windows has drive letters, long paths, and network paths called UNCs.</p>
<p>Rust provides a PathBuf struct for manipulating paths and a Path which acts like a slice and can be the full path or just a portion of one.</p>
<p>TODO simple example of a path being created</p>
<p>TODO simple example of a Path slice in actively</p>
<p>TODO simple example of relative path made absolute</p>
<p>Windows has a bunch of path prefixes so std::path::Prefix provides a way to accessing those.</p>
<p>TODO example of a path being made from a drive letter and path</p>
<h3 id="opening-a-file"><a class="header" href="#opening-a-file">Opening a file</a></h3>
<p>A <code>File</code> is a reference to an open file on the filesystem. When the struct goes out of scope the file is closed. There are static functions for creating or opening a file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::prelude::*;
use std::fs::File;

let mut f = try!(File::open(&quot;myfile.txt&quot;));
TODO
<span class="boring">}
</span></code></pre></pre>
<p>Note that File::open() opens a file read-only by default. To open a file read-write, there is an OpenOptions struct that has methods to set the behaviour of the open file - read, write, create, append and truncate.</p>
<p>e.g. to open a file with read/write access, creating it if it does not already exist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::OpenOptions;

let file = OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(&quot;myfile.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="writing-to-a-file"><a class="header" href="#writing-to-a-file">Writing to a file</a></h3>
<p>TODO simple example of opening file to write</p>
<h3 id="reading-lines-from-a-file"><a class="header" href="#reading-lines-from-a-file">Reading lines from a file</a></h3>
<p>TODO simple example of opening file text mode, printing contents</p>
<h2 id="threading"><a class="header" href="#threading">Threading</a></h2>
<p>Rust actively enforces thread safety in your code. If you attempt to pass around data which is not marked thread safe (i.e. implements the Sync trait), you will get a compile error. If you use code which is implicitly not thread safe such as Rc&lt;&gt; you will get a compile error.</p>
<p>This enforcement means that Rust protects against data race conditions, however be aware it cannot protect against other forms of race conditions or deadlocks, e.g. thread 1 waits for resource B (held by thread 2) while thread 2 waits for resource A (held by thread 1).</p>
<h3 id="creating-a-thread"><a class="header" href="#creating-a-thread">Creating a thread</a></h3>
<p>Creating a thread is simple with a closure.</p>
<p>TODO</p>
<h3 id="waiting-for-a-thread-to-complete"><a class="header" href="#waiting-for-a-thread-to-complete">Waiting for a thread to complete</a></h3>
<p>TODO</p>
<h3 id="using-atomic-reference-counting"><a class="header" href="#using-atomic-reference-counting">Using atomic reference counting</a></h3>
<p>Rust provides two reference counting types. Type Rc&lt;&gt; is for code residing on the same thread and so the reference counting is not atomic. Type Arc&lt;&gt; is for code that runs on different threads and the reference counting is atomic.</p>
<p>An Arc&lt;&gt; can only hold a Sync derived object. Whenever you clone an Arc&lt;&gt; or its lifetime ends, the counter is atomically incremented or decremented. The last decrement to zero causes the object to be deleted.</p>
<p>TODO example</p>
<h3 id="locking-a-shared-resource"><a class="header" href="#locking-a-shared-resource">Locking a shared resource</a></h3>
<p>Message passing is a preferable way to prevent threads from sharing state but its not always possible.</p>
<p>Therefore Rust allows you to create a mutex and lock access to shared data. The guard that locks / unlocks the mutex protects the data and when the guard goes out of scope, the data is returned.</p>
<p>This style of guard is called TODO</p>
<h3 id="data-race-protection"><a class="header" href="#data-race-protection">Data race protection</a></h3>
<p>Rust can guarantee that protection from data races, i.e. more than one thread accessing / writing to the same data at the same time.</p>
<p>However even Rust cannot protect against the more general problem of race conditions. e.g. if two threads lock each other's data, then the code will deadlock. This is a problem that no language can solve.</p>
<h3 id="waiting-for-multiple-threads-to-finish"><a class="header" href="#waiting-for-multiple-threads-to-finish">Waiting for multiple threads to finish</a></h3>
<p>TODO</p>
<h3 id="sending-data-to-a-thread"><a class="header" href="#sending-data-to-a-thread">Sending data to a thread</a></h3>
<p>Any struct that implements the Send trait is treated safe to send to another thread. Of course that applies to</p>
<h3 id="receiving-data-from-a-thread"><a class="header" href="#receiving-data-from-a-thread">Receiving data from a thread</a></h3>
<p>A thread can receive messages and block until it receives one. Thus it is easy to create a worker thread of some kind.</p>
<p>TODO</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="connecting-to-a-server"><a class="header" href="#connecting-to-a-server">Connecting to a server</a></h3>
<p>TODO</p>
<p>###Listening to a socket</p>
<p>TODO</p>
<h2 id="interacting-with-c"><a class="header" href="#interacting-with-c">Interacting with C</a></h2>
<h3 id="using-libc-functions-and-types"><a class="header" href="#using-libc-functions-and-types">Using libc functions and types</a></h3>
<h3 id="calling-a-c-library"><a class="header" href="#calling-a-c-library">Calling a C library</a></h3>
<h3 id="generating-a-dynamic-library"><a class="header" href="#generating-a-dynamic-library">Generating a dynamic library</a></h3>
<h3 id="calling-win32-functions"><a class="header" href="#calling-win32-functions">Calling Win32 functions</a></h3>
<h2 id="common-design-patterns"><a class="header" href="#common-design-patterns">Common design patterns</a></h2>
<h3 id="singleton"><a class="header" href="#singleton">Singleton</a></h3>
<p>A singleton has one instance ever in your application.
TODO</p>
<h3 id="factory"><a class="header" href="#factory">Factory</a></h3>
<p>TODO</p>
<h3 id="observer"><a class="header" href="#observer">Observer</a></h3>
<p>TODO</p>
<h3 id="facade"><a class="header" href="#facade">Facade</a></h3>
<p>TODO</p>
<h3 id="flyweight"><a class="header" href="#flyweight">Flyweight</a></h3>
<p>TODO</p>
<h3 id="adapter"><a class="header" href="#adapter">Adapter</a></h3>
<p>An adapter is where we present a different interface to a client calling the adapter than the interface the code is implemented in. This might be done to make some legacy code conform to a new interface, or to manage / hide complexity which might leak out into the client.</p>
<p>As Rust is a relatively new language you are most likely to use an adapter pattern to wrap some existing code in C. A common use for the adapter in C++ is to wrap up a C library in RAII classes or similar.</p>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
