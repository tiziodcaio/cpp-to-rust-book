<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Structs - A Guide to Porting C/C++ to Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book that explains how to port code from C++ to Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="../foreword.html"><strong aria-hidden="true">3.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="../credits.html"><strong aria-hidden="true">4.</strong> Credits</a></li><li class="chapter-item expanded "><a href="../notation.html"><strong aria-hidden="true">5.</strong> Notation used through this book</a></li><li class="chapter-item expanded "><a href="../01_setting_up_rust/index.html"><strong aria-hidden="true">6.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="../02_c_and_cpp_background/index.html"><strong aria-hidden="true">7.</strong> C and C++ Background</a></li><li class="chapter-item expanded "><a href="../03_rust_background/index.html"><strong aria-hidden="true">8.</strong> Rust Background</a></li><li class="chapter-item expanded "><a href="../04_start_simple/index.html"><strong aria-hidden="true">9.</strong> Let's Start Simple</a></li><li class="chapter-item expanded "><a href="../05_compiling_and_linking/index.html"><strong aria-hidden="true">10.</strong> Compiling and Linking in More Detail</a></li><li class="chapter-item expanded "><a href="../06_source_layout/index.html"><strong aria-hidden="true">11.</strong> Source Layout and Other General Points</a></li><li class="chapter-item expanded "><a href="../07_namespacing_with_modules/index.html"><strong aria-hidden="true">12.</strong> Namespacing With Modules</a></li><li class="chapter-item expanded "><a href="../08_porting_code/index.html"><strong aria-hidden="true">13.</strong> Porting Code</a></li><li class="chapter-item expanded "><a href="../09_features_compared/index.html"><strong aria-hidden="true">14.</strong> Features of Rust compared with C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_features_compared/types.html"><strong aria-hidden="true">14.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="../09_features_compared/strings.html"><strong aria-hidden="true">14.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../09_features_compared/variables.html"><strong aria-hidden="true">14.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../09_features_compared/literals.html"><strong aria-hidden="true">14.4.</strong> Literals</a></li><li class="chapter-item expanded "><a href="../09_features_compared/collections.html"><strong aria-hidden="true">14.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../09_features_compared/structs.html" class="active"><strong aria-hidden="true">14.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../09_features_compared/comments.html"><strong aria-hidden="true">14.7.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../09_features_compared/references_and_borrowing.html"><strong aria-hidden="true">14.8.</strong> Lifetimes, References and Borrowing</a></li><li class="chapter-item expanded "><a href="../09_features_compared/expressions.html"><strong aria-hidden="true">14.9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/conditions.html"><strong aria-hidden="true">14.10.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/match.html"><strong aria-hidden="true">14.11.</strong> Switch / Match</a></li><li class="chapter-item expanded "><a href="../09_features_compared/casting.html"><strong aria-hidden="true">14.12.</strong> Casting</a></li><li class="chapter-item expanded "><a href="../09_features_compared/enums.html"><strong aria-hidden="true">14.13.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../09_features_compared/loops.html"><strong aria-hidden="true">14.14.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../09_features_compared/functions.html"><strong aria-hidden="true">14.15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/polymorphism.html"><strong aria-hidden="true">14.16.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../09_features_compared/error_handling.html"><strong aria-hidden="true">14.17.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../09_features_compared/closures.html"><strong aria-hidden="true">14.18.</strong> Lambda Expressions / Closures</a></li><li class="chapter-item expanded "><a href="../09_features_compared/generics.html"><strong aria-hidden="true">14.19.</strong> Templates / Generics</a></li><li class="chapter-item expanded "><a href="../09_features_compared/attributes.html"><strong aria-hidden="true">14.20.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="../09_features_compared/multthreading.html"><strong aria-hidden="true">14.21.</strong> Multi-threading</a></li><li class="chapter-item expanded "><a href="../09_features_compared/lint.html"><strong aria-hidden="true">14.22.</strong> Lint</a></li><li class="chapter-item expanded "><a href="../09_features_compared/macros.html"><strong aria-hidden="true">14.23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../09_features_compared/memory_allocation.html"><strong aria-hidden="true">14.24.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../09_features_compared/ffi.html"><strong aria-hidden="true">14.25.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/index.html"><strong aria-hidden="true">15.</strong> Porting from C/C++ to Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_porting_from_cpp/copy_constructors.html"><strong aria-hidden="true">15.1.</strong> Copy Constructor / Assignment Operators</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/missing_braces.html"><strong aria-hidden="true">15.2.</strong> Missing Braces in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/assignments_in_conditionals.html"><strong aria-hidden="true">15.3.</strong> Assignment in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_member_initialisation.html"><strong aria-hidden="true">15.4.</strong> Class Member Initialisation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/splitting_code_between_headers_and_sources.html"><strong aria-hidden="true">15.5.</strong> Headers and Sources</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/forward_declarations.html"><strong aria-hidden="true">15.6.</strong> Forward Declarations</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/namespace_collisions.html"><strong aria-hidden="true">15.7.</strong> Namespace Collisions</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/macros.html"><strong aria-hidden="true">15.8.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/type_mismatching.html"><strong aria-hidden="true">15.9.</strong> Type Mismatching</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_constructors.html"><strong aria-hidden="true">15.10.</strong> Explicit / Implicit Class Constructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/poor_lifetime_enforcement.html"><strong aria-hidden="true">15.11.</strong> Poor Lifetime Enforcement</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/memory_allocation.html"><strong aria-hidden="true">15.12.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/null_pointers.html"><strong aria-hidden="true">15.13.</strong> Null Pointers</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/virtual_destructors.html"><strong aria-hidden="true">15.14.</strong> Virtual Destructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/exceptions.html"><strong aria-hidden="true">15.15.</strong> Exception Handling / Safety</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/templates.html"><strong aria-hidden="true">15.16.</strong> Templates vs Generics</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/multiple_inheritance.html"><strong aria-hidden="true">15.17.</strong> Multiple Inheritance</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/linker.html"><strong aria-hidden="true">15.18.</strong> Linker Errors</a></li></ol></li><li class="chapter-item expanded "><a href="../11_debugging_rust/index.html"><strong aria-hidden="true">16.</strong> Debugging Rust</a></li><li class="chapter-item expanded "><a href="../12_memory_management/index.html"><strong aria-hidden="true">17.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../13_std_library/index.html"><strong aria-hidden="true">18.</strong> Rust's std:: library</a></li><li class="chapter-item expanded "><a href="../14_rust_cookbook/index.html"><strong aria-hidden="true">19.</strong> Rust Cookbook</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Porting C/C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<h2 id="c"><a class="header" href="#c">C++</a></h2>
<p>A <code>class</code> and a <code>struct</code> in C++ are largely the same thing from an implementation standpoint. They both hold fields and they both can have methods attached to the class (<code>static</code>) or instance level. </p>
<pre><code class="language-c++">class Foo {
public:
   // Methods and members here are publicly visible
   double calculateResult();
protected:
   // Elements here are only visible to ourselves and subclasses
   virtual double doOperation(double lhs, double rhs);
private:
   // Elements here are only visible to ourselves
   bool debug_;
};
</code></pre>
<p>The default access level is <code>public</code> for struct and <code>private</code> for class. Some rules about templates only apply to classes.</p>
<p>From a psychological perspect a <code>struct</code> tends to be used to hold public data that is largely static and/or passed around. A <code>class</code> tends to be something more self contained with methods that are called to access or manage private fields.</p>
<p>So these are equivalents:</p>
<pre><code class="language-c++">struct Foo { // as a struct
private:
};

class Foo { // As a class
};

// Or the other way around

struct Bar {
};

class Bar {
public:
};
</code></pre>
<p>Classes can also use an access specifier to inherit from a base class. So a class may specify <code>public</code>, <code>protected</code> or <code>private</code> when deriving from another class depending on whether it wants those methods to be visible to callers, or subclasses.</p>
<p>Classes and structs may have special constructor and destructor methods which are described in sections below.</p>
<pre><code class="language-c++">class Size {
public:
  Size(int width, int height);

  int width_;
  int height_;

  int area() const;
};
</code></pre>
<p>Then in the .cpp file you might implement the constructor and method:</p>
<pre><code class="language-C++">Size::Size(int width, int height) : width_(width), height_(height) {}

int Size::area() { return width_ * height_; }
</code></pre>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Rust only has structs. A <code>struct</code> consists of a definition which specifies the fields and their access level (public or not), and an <code>impl</code> section which contains the implementation of functions bound to the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Size {
  pub width: i32,
  pub height: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>An <code>impl</code> section follows containing the associated functions (<code>new</code>) and methods (<code>area</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Size {
  pub fn new(width: i32, height: i32) -&gt; Size {
    Size { width: width, height: height, }
  }

  pub fn area(&amp;self) -&gt; i32 {
    self.width * self.height
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>new()</code> function here is an associated function that returns a struct preinitialised with the arguments supplied. The <code>area()</code> method specifies a <code>&amp;self</code> argument and returns an area calculation. Any method (with <code>&amp;self</code>, or <code>&amp;mut self</code> as the first argument)  can be called from the variable bound to the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let size = Size::new(10, 20);
println!(&quot;Size = {}&quot;, size.area());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>self</code> keyword works in much the same way as C++ uses <code>this</code>, as a reference to the struct from which the function was invoked. If a function modifies the struct it must say <code>&amp;mut self</code>, which indicates the function modifies the struct.</p>
<p>There is no inheritance in Rust. Instead, a <code>struct</code> may implement zero or more traits. A trait describes some kind of behavior that can be associated with the struct and described further later on in this chapter.</p>
<p>The above impelementation can also be written with the following syntactic sugar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Size {
  pub width: i32,
  pub height: i32,
}


impl Size {
  pub fn new(width: i32, height: i32) -&gt; Self {
      Self {width, height}
  }

  pub fn area(&amp;self) -&gt; i32 {
      self.width * self.height
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note using <code>Self</code> as a type replacer and struct fields inference.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>In C++ all classes have implicit or explicit constructors. Either the compiler generates them or you do, or a mix of both.</p>
<p>An implicit default constructor, copy constructor and assignment operator will be created when a class does not define its own. We saw on page 73 why this could be really bad news.</p>
<p>What becomes obvious from reading there is a lot of noise and potential for error in C++. There would be even more if raw pointers were used instead of a <code>std::unique_ptr</code> here.</p>
<p>In Rust, things are simpler, and we'll see how it shakes out errors.</p>
<p>First off, let's declare our equivalent struct in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
  pub name: String,
  pub age: i32,
  pub credentials: Option&lt;Credentials&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Since credentials are optional, we wrap in an <code>Option</code> object, i.e. credentials might be None or it might be <code>Some(Credentials)</code>.
Any code anywhere in the system can instantiate a <code>Person</code> simply be declaring an instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let person = Person { name: String::from(&quot;Bob&quot;), age: 20, credentials: None }
<span class="boring">}
</span></code></pre></pre>
<p>In Rust you cannot create a struct without initialising all its members so we cannot have a situation where we don't know what is in each field - it MUST be set by our code.</p>
<p>But declaring the struct is a bit clumsy, especially if the struct is created in lots of places. So can write function that behaves like a constructor in C++.</p>
<p>Instead you implement a static method in the impl of the Struct which returns an initialised struct, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
  pub fn new(name: String, age: i32) -&gt; Person {
    Person { name: name.clone(), age: age, credentials: None }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that Rust does not support overloads. So if we had multiple &quot;constructor&quot; methods, they would each have to have unique names.</p>
<p>Finally what is we wanted to copy the <code>Person</code> struct?</p>
<p>By default Rust does not allow copying on user-defined structs. Assigning a variable to another variable moves ownership, it doesn't copy.</p>
<p>There are two ways to make a user-defined struct copyable</p>
<ol>
<li>implement the <code>Copy</code> trait which means assignment is implicit, but is what we want? Do we really want to make copies of a struct by accident?</li>
<li>implement <code>Clone</code> instead to add a <code>clone()</code> method and require an explicit call to <code>clone()</code> order to duplicate the struct a copy.</li>
</ol>
<p>But the compiler can derive clone() providing all the members of the struct implement the Clone trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Person {
  pub name: String,
  pub age: i32,
  pub credentials: Option&lt;Credentials&gt;, // Credentials must implement Clone
}

impl Person {
  pub fn new(name: String, age: String) -&gt; Person {
    Person { name: name.clone(), age: age, credentials: None }
  }
}

//...

let p = Person::new(String::from(&quot;Michael&quot;), 20);
let p2 = p.clone();
<span class="boring">}
</span></code></pre></pre>
<p>What we can see is that Rust's construction and <code>clone()</code> behavior is basically declarative.
We saw how C++ has all kinds of rules and nuances to construction, copy construction and assignment which make it complicated and prone to error.</p>
<h2 id="destructors"><a class="header" href="#destructors">Destructors</a></h2>
<p>A C++ destructor is a specialized method called when your object goes out of scope or is deleted.</p>
<pre><code class="language-c++">class MyClass {
public:
  MyClass() : someMember_(new Resource()) {}
  ~MyClass() {
     delete someMember_;
  }

private:
  Resource *someMember_;
}
</code></pre>
<p>In C++ you can declare a class destructor to be called when the object is about to be destroyed. You have to use a virtual destructor if your class inherits from another class in case a caller calls <code>delete</code> on the base class.</p>
<p>Since Rust does not do inheritance and does not have constructors, the manner in which you cleanup is different and simpler. Instead of a destructor you implement the <code>Drop</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for Shape {
    fn drop(&amp;mut self) {
        println!(&quot;Shape dropping!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The compiler recognizes this trait. If you implement this trait then the compiler knows to call your <code>drop()</code> function prior to destroying your struct. It’s that simple.</p>
<p>Occasionally there might be a reason to explicitly drop a struct before it goes out of scope. Perhaps the resources held by the variable should be freed as soon as possible to release a resource which is in contention. Whatever the reason, the answer is to call <code>drop</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  let some_object = SomeObject::new();
  //...
  // Ordinarily some_object might get destroyed later,
  // but this makes it explicitly happen here
  drop(some_object);
  //...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="access-specifier-rules"><a class="header" href="#access-specifier-rules">Access specifier rules</a></h2>
<p>A C++ class can hide or show methods and members to any other class, or to things that inherit from itself using the public, private and protected keywords:</p>
<ul>
<li><code>public</code> – can be seen by any code internal or external to the class</li>
<li><code>private</code> – can only be used by code internal to the class. Not even subclasses can access these members</li>
<li><code>protected</code> – can be used by code internal to the class and by subclasses.</li>
</ul>
<p>A class may designate another function or class as a friend which has access to the private and protected members of a class.</p>
<p>Rust makes things somewhat simpler.</p>
<p>If you want a struct to be visible outside your module you mark it <code>pub</code>. If you do not mark it <code>pub</code> then it is only visible within the module and submodules.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>If you want public access a member of a struct (including modifying it if its mutable), then mark it <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Person {
  pub age: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>If you want something to be able to call a function on your struct you mark it <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
  pub fn is_adult(&amp;self) -&gt; bool {
    self.age &gt;= 18
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions can be bound to a struct within an <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Shape {
  pub fn new(width: u32, height: u32) -&gt; Shape {
    Shape { width, height }
  }
  
  pub fn area(&amp;self) -&gt; i32 {
    self.width * self.height
  }

  pub fn set(&amp;mut self, width: i32, height: i32) {
    self.width = width;
    self.height = height;
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Functions that start with a <code>&amp;self</code> / <code>&amp;mut self</code> parameter are bound to instances.  Those without are bound to the type. So the <code>new()</code> function can be called as <code>Shape::new()</code>.</p>
<p>Where <code>&amp;self</code> is provided, the function is invoked on the instance. So for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shape = Shape::new(100, 100);
let area = shape.area();
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>&amp;mut self</code> is provided it signifies that the function mutates the struct.</p>
<p>Unlike C++, all access to the struct has to be qualified. In C++ you don't publishing_interval: Double, lifetime_count: UInt32, max_keep_alive_count: UInt32, max_notifications_per_publish: UInt32, priority: Bytehave to say <code>this-&gt;foo()</code> to call foo() from another member of the class. Rust requires code to say unambiguously <code>self.foo()</code>.</p>
<h2 id="static-functions"><a class="header" href="#static-functions">Static functions</a></h2>
<p>Static functions (&quot;associated functions&quot;) are merely functions in the <code>impl</code> block that do not have <code>&amp;self</code> or <code>&amp;mut self</code> as their first parameter, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Circle {
   fn pi() -&gt; f64 { std::f64::consts:PI }
}
//...
let pi = Circle::pi();
<span class="boring">}
</span></code></pre></pre>
<p>In other words they're not bound to an instance of a type, but to the type itself. For example, <code>Circle::pi()</code>.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>C++ allows one class to inherit from another. Generally this is a useful feature although it can get pretty complex if you implement multiple inheritance, particularly the dreaded diamond pattern.</p>
<p>As we’ve found out, Rust doesn’t have classes at all – they’re structs with bound functions.  So how do you inherit code? The answer is you don’t.</p>
<p>Instead your struct may implement traits which are a bit like partial classes.</p>
<p>A trait is declared like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HasCircumference {
  fn circumference(&amp;self) -&gt; f64;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the trait <code>HasCircumference</code> has a function called <code>circumference()</code> whose signature is defined but must be implemented.</p>
<p>A type can implement the trait by declaring and <code>impl</code> of it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl HasCircumference for Size {
  fn circumference(&amp;self) -&gt; f64 {
    2.0 * std::f64::consts::PI * self.radius
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>A trait may supply default function implementations. For example, a <code>HasDimensions</code> trait might implement <code>area()</code> to spare the implementor the bother of doing it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HasDimensions {
  fn width(&amp;self) -&gt; u32;
  fn height(&amp;self) -&gt; u32;

  fn area(&amp;self) -&gt; u32 {
    self.width() * self.height()
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>In C++ an object lives from the moment it is constructed to the moment it is destructed. </p>
<p>That lifetime is implicit if you declare the object on the stack. The object will be created / destroyed as it goes in and out of scope. It is also implicit if your object is a member of another object - the lifetime is within the containing object, and the declaration order of other members in the containing object.</p>
<p>However, if you allocate your object via <code>new</code> then it is up to you when to <code>delete</code>. If you <code>delete</code> too soon, or forget to <code>delete</code> then you may destabilize your program.  C++ encourages using smart pointers that manage the lifetime of your object, tying it to the implicit lifetime of the smart pointer itself - when the smart pointer is destroyed, it deletes the held pointer. A more sophisticated kind of smart pointer allows multiple instances of the same pointer to exist at once, and reference counting is used so that when the last smart pointer is destroyed, it destroyes the pointer.</p>
<p>Even so, C++ itself will not care if you initialized a class with a reference or pointer to something that no longer lives. If you do this, your program will crash.</p>
<p>Let's write an <code>Incrementor</code> class which increments an integer value and returns that value.</p>
<pre><code class="language-c++">class Incrementor {
public:
	Incrementor(int &amp;value) : value_(value) {}
	int increment() { return ++value_; }

private:
	int &amp;value_;
};
</code></pre>
<p>This seems fine, but what if we use it like this?</p>
<pre><code class="language-c++">Incrementor makeIncrementor() {
  // This is a bad idea
	int value = 5;
	return Incrementor(value);
}
</code></pre>
<p>This code passes a reference to an <code>int</code> into the class constructor and returns the <code>Incrementor</code> from the function itself. But when <code>increment()</code> is called the reference is dangling and anything can happen.</p>
<h2 id="rust-lifetimes"><a class="header" href="#rust-lifetimes">Rust lifetimes</a></h2>
<p>Rust <em>does</em> care about the lifetime of objects and tracks them to ensure that you cannot reference something that no longer exists. Most of the time this is automatic and self-evident from the error message you get if you try something bad. </p>
<p>The compiler also implements a <em>borrow checker</em> which tracks references to objects to ensure that:</p>
<ol>
<li>References are held no longer than the lifetime of the object they refer to.</li>
<li>Only a single mutable reference is possible at a time and not concurrently with immutable references. This is to prevent data races.</li>
</ol>
<p>The compiler will generate compile errors if it finds code in violation of its rules.</p>
<p>So let's write the equivalent of <code>Incrementor</code> above but in Rust. The Rust code will hold a reference to a integer <code>i32</code> and increment it from a bound function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Incrementor {
  value: &amp;mut i32
}

impl Incrementor {
  pub fn increment(&amp;mut self) -&gt; i32 {
    *self.value += 1;
    *self.value
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Seems fine, but the first error we get is:</p>
<pre><code>2 |   value: &amp;mut u32
  |          ^ expected lifetime parameter
</code></pre>
<p>We tried to create a struct that manages a reference, but the compiler doesn't know anything about this reference's lifetime and so it has generated a compile error.</p>
<p>To help the compiler overcome its problem, we will annotate our struct with a lifetime which we will call <code>'a</code>. The label is anything you like but typically it'll be a letter. </p>
<p>This lifetime label is a hint on our struct that says the reference we use inside the struct must have a lifetime of at least as much the struct itself - namely that <code>Incrementor&lt;'a&gt;</code> and <code>value: &amp;'a mut i32</code> share the same lifetime constraint and the compiler will enforce it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Incrementor&lt;'a&gt; {
  value: &amp;'a mut i32
}

impl &lt;'a&gt; Incrementor&lt;'a&gt; {
  pub fn increment(&amp;mut self) -&gt; i32 {
    *self.value += 1;
    *self.value
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>With the annotation in place, we can now use the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut value = 20;
let mut i = Incrementor { value: &amp;mut value };
println!(&quot;value = {}&quot;, i.increment());
<span class="boring">}
</span></code></pre></pre>
<p>Note that the annotation <code>'a</code> could be any label we like - <code>'increment</code> would work if we wanted, but obviously its more longwinded.</p>
<p>There is a special lifetime called <code>'static</code> that refers to things like static strings and functions which have a lifetime as long as the runtime and may therefore be assumed to always exist.</p>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime elision</a></h3>
<p>Rust allows reference lifetimes to be elided (a <a href="https://ericlippert.com/2013/01/24/five-dollar-words-for-programmers-elision/">fancy word</a> for omit) in most function signatures.</p>
<p>Basically, it assumes that when passing a reference into a function, that the lifetime of the reference is implicitly longer than the function itself so the need to annotate is not necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_person(name: &amp;str) -&gt; Option&lt;Person&gt;
// instead of
fn find_person&lt;'a&gt;(name: &amp;'a str) -&gt; Option&lt;Person&gt;
<span class="boring">}
</span></code></pre></pre>
<p>The rules for elision are described in the further reference link.</p>
<h3 id="further-reference"><a class="header" href="#further-reference">Further reference</a></h3>
<p>Lifetimes are a large subject and the documentation is <a href="https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../09_features_compared/collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../09_features_compared/comments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../09_features_compared/collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../09_features_compared/comments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
