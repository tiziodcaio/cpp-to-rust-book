<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Strings - A Guide to Porting C/C++ to Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book that explains how to port code from C++ to Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="../foreword.html"><strong aria-hidden="true">3.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="../credits.html"><strong aria-hidden="true">4.</strong> Credits</a></li><li class="chapter-item expanded "><a href="../notation.html"><strong aria-hidden="true">5.</strong> Notation used through this book</a></li><li class="chapter-item expanded "><a href="../01_setting_up_rust/index.html"><strong aria-hidden="true">6.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="../02_c_and_cpp_background/index.html"><strong aria-hidden="true">7.</strong> C and C++ Background</a></li><li class="chapter-item expanded "><a href="../03_rust_background/index.html"><strong aria-hidden="true">8.</strong> Rust Background</a></li><li class="chapter-item expanded "><a href="../04_start_simple/index.html"><strong aria-hidden="true">9.</strong> Let's Start Simple</a></li><li class="chapter-item expanded "><a href="../05_compiling_and_linking/index.html"><strong aria-hidden="true">10.</strong> Compiling and Linking in More Detail</a></li><li class="chapter-item expanded "><a href="../06_source_layout/index.html"><strong aria-hidden="true">11.</strong> Source Layout and Other General Points</a></li><li class="chapter-item expanded "><a href="../07_namespacing_with_modules/index.html"><strong aria-hidden="true">12.</strong> Namespacing With Modules</a></li><li class="chapter-item expanded "><a href="../08_porting_code/index.html"><strong aria-hidden="true">13.</strong> Porting Code</a></li><li class="chapter-item expanded "><a href="../09_features_compared/index.html"><strong aria-hidden="true">14.</strong> Features of Rust compared with C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_features_compared/types.html"><strong aria-hidden="true">14.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="../09_features_compared/strings.html" class="active"><strong aria-hidden="true">14.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../09_features_compared/variables.html"><strong aria-hidden="true">14.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../09_features_compared/literals.html"><strong aria-hidden="true">14.4.</strong> Literals</a></li><li class="chapter-item expanded "><a href="../09_features_compared/collections.html"><strong aria-hidden="true">14.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../09_features_compared/structs.html"><strong aria-hidden="true">14.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../09_features_compared/comments.html"><strong aria-hidden="true">14.7.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../09_features_compared/references_and_borrowing.html"><strong aria-hidden="true">14.8.</strong> Lifetimes, References and Borrowing</a></li><li class="chapter-item expanded "><a href="../09_features_compared/expressions.html"><strong aria-hidden="true">14.9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/conditions.html"><strong aria-hidden="true">14.10.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/match.html"><strong aria-hidden="true">14.11.</strong> Switch / Match</a></li><li class="chapter-item expanded "><a href="../09_features_compared/casting.html"><strong aria-hidden="true">14.12.</strong> Casting</a></li><li class="chapter-item expanded "><a href="../09_features_compared/enums.html"><strong aria-hidden="true">14.13.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../09_features_compared/loops.html"><strong aria-hidden="true">14.14.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../09_features_compared/functions.html"><strong aria-hidden="true">14.15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/polymorphism.html"><strong aria-hidden="true">14.16.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../09_features_compared/error_handling.html"><strong aria-hidden="true">14.17.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../09_features_compared/closures.html"><strong aria-hidden="true">14.18.</strong> Lambda Expressions / Closures</a></li><li class="chapter-item expanded "><a href="../09_features_compared/generics.html"><strong aria-hidden="true">14.19.</strong> Templates / Generics</a></li><li class="chapter-item expanded "><a href="../09_features_compared/attributes.html"><strong aria-hidden="true">14.20.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="../09_features_compared/multthreading.html"><strong aria-hidden="true">14.21.</strong> Multi-threading</a></li><li class="chapter-item expanded "><a href="../09_features_compared/lint.html"><strong aria-hidden="true">14.22.</strong> Lint</a></li><li class="chapter-item expanded "><a href="../09_features_compared/macros.html"><strong aria-hidden="true">14.23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../09_features_compared/memory_allocation.html"><strong aria-hidden="true">14.24.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../09_features_compared/ffi.html"><strong aria-hidden="true">14.25.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/index.html"><strong aria-hidden="true">15.</strong> Porting from C/C++ to Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_porting_from_cpp/copy_constructors.html"><strong aria-hidden="true">15.1.</strong> Copy Constructor / Assignment Operators</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/missing_braces.html"><strong aria-hidden="true">15.2.</strong> Missing Braces in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/assignments_in_conditionals.html"><strong aria-hidden="true">15.3.</strong> Assignment in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_member_initialisation.html"><strong aria-hidden="true">15.4.</strong> Class Member Initialisation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/splitting_code_between_headers_and_sources.html"><strong aria-hidden="true">15.5.</strong> Headers and Sources</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/forward_declarations.html"><strong aria-hidden="true">15.6.</strong> Forward Declarations</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/namespace_collisions.html"><strong aria-hidden="true">15.7.</strong> Namespace Collisions</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/macros.html"><strong aria-hidden="true">15.8.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/type_mismatching.html"><strong aria-hidden="true">15.9.</strong> Type Mismatching</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_constructors.html"><strong aria-hidden="true">15.10.</strong> Explicit / Implicit Class Constructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/poor_lifetime_enforcement.html"><strong aria-hidden="true">15.11.</strong> Poor Lifetime Enforcement</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/memory_allocation.html"><strong aria-hidden="true">15.12.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/null_pointers.html"><strong aria-hidden="true">15.13.</strong> Null Pointers</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/virtual_destructors.html"><strong aria-hidden="true">15.14.</strong> Virtual Destructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/exceptions.html"><strong aria-hidden="true">15.15.</strong> Exception Handling / Safety</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/templates.html"><strong aria-hidden="true">15.16.</strong> Templates vs Generics</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/multiple_inheritance.html"><strong aria-hidden="true">15.17.</strong> Multiple Inheritance</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/linker.html"><strong aria-hidden="true">15.18.</strong> Linker Errors</a></li></ol></li><li class="chapter-item expanded "><a href="../11_debugging_rust/index.html"><strong aria-hidden="true">16.</strong> Debugging Rust</a></li><li class="chapter-item expanded "><a href="../12_memory_management/index.html"><strong aria-hidden="true">17.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../13_std_library/index.html"><strong aria-hidden="true">18.</strong> Rust's std:: library</a></li><li class="chapter-item expanded "><a href="../14_rust_cookbook/index.html"><strong aria-hidden="true">19.</strong> Rust Cookbook</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Porting C/C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In C/C++</p>
<ul>
<li>A string is typically a pointer to an array of <code>char</code>, <code>wchar_t</code>, <code>char16_t</code> or <code>char32_t</code> values. Historically most strings are <code>char</code> but efforts have been made to support wide character strings as well as Unicode encodings such as UTF-8.</li>
<li>A string's length is calculated by looking for a special nul (<code>'\0'</code>) value that signifies the end of the string. So a 2000 character string requires iterating through the whole string, potentially 2000 times looking for a nul. The <code>std::basic_string&lt;&gt;</code> type holds a length to negate the need to calculate the length and also to handle byte arrays that may contain nuls.</li>
<li>In C++ types derived from <code>std::basic_string&lt;&gt;</code> template are the recommended way to manage strings safely. But other 3rd party libraries also have their own string wrappers, e.g. <code>QString</code> in QT.</li>
<li>Only <code>char16_t</code> and <code>char32_t</code> types are considered to be Unicode (encoded as UTF-16, UTF-32 respectively). There is no encoding knowledge about the meaning of other kinds of string.</li>
<li>In C++17 you may create a <code>std::basic_string_view&lt;&gt;</code> which is a view onto a read-only string.</li>
</ul>
<p>In Rust</p>
<ul>
<li>A <code>char</code> is a primitive in Rust that is 32-bits and can represent any Unicode character. So it equivalent to <code>char32_t</code> in C++.</li>
<li>A <code>str</code> is a primitive that represents a read-only string. You don't declare these, rather any string in your code is implicitly a <code>str</code> and your variables bind to it via a string slice.</li>
<li>A <code>&amp;str</code> is a string slice - a reference to a <code>str</code>, consisting of a pointer and a length. </li>
<li>A <code>String</code> is a heap allocated writable buffer for strings. i.e. it can be truncated, extended etc. It implements all the functions of <code>str</code> and can also be used as a <code>&amp;str</code>.</li>
<li>All strings are internally encoded as UTF-8 but there are functions to iterate by character.</li>
</ul>
<h2 id="what-is-a-character-exactly"><a class="header" href="#what-is-a-character-exactly">What is a character exactly?</a></h2>
<p>Historically, a string has been a sequence of bytes, each representing a character. Each character is mapped to a byte (or multiple bytes) to be displayed on a screen. This is known as an encoding, i.e. the computer knows that a byte with value 65 corresponds as the letter 'A' and has a table lookup for every printable character.</p>
<p>The two predominent encodings early on were EBDIC and ASCII. Each of these assigned characters to byte values. We won't mention EBDIC since ASCII essentially won the encoding war but basically ASCII uses the first 7-bits (0-127) of the byte to assign values to upper and lower case letters in the English alphabet, numbers, punctuation marks and certain control characters. The eighth wasn't used because at the time it was used as a control bit for serial communications.</p>
<p><img src="USASCII_code_chart.png" alt="ASCII Table" title="ASCII Table (wikimedia)" /></p>
<p>But what about the rest of the world? It is no use to someone writing in French if there are no letters with acute, grave or circumflex chars to use ASCII since there is no character for 'À'. It would be no use at all for Japanese unless the entire language were written phonetically. For that reason the values in the 128-255 range started to be co-opted to represent other characters. </p>
<p>Languages like Chinese, Japanese, Korean, Thai, Arabic etc. have thousands of symbols so there is no way to encode them in this range. So they had to use multi-byte encodings, one character being more than one byte in length.</p>
<p>The problem here is that unless you know what language the string of bytes represents, you cannot render the character. The same sequence of bytes may mean different things depending on the encoding. So operating systems like DOS &amp; Windows gave software a clue how to handle strings - the codepage. The codepage was an environmental setting that said that on this computer, the bytes should be interpreted as.. Rusian, Latin, Japanese etc. So for example Microsoft's code page 932 use an encoding called Shift JIS (Japanese) where some symbols are two bytes.</p>
<p>The code page works for one computer, but not documents sent between multiple computers with differing code pages. The bytes in one computer mean one thing and another in the other computer. </p>
<p>Obviously this was rapidly becoming a mess. Each code page interpretted the same byte array differently according to some external setting. So you could not send a file written in Chinese to someone with a different code page and expect it to render properly.</p>
<h3 id="unicode"><a class="header" href="#unicode">Unicode</a></h3>
<p>The Unicode standard was created to solve this problem. It assigns every printable character or glyph in existence with a unique 32-bit value, called a code point. Code points are arranged into planes - blocks of 65536 code points.</p>
<p>Most characters fall in plane 0 called the Basic Multilingual Plane (BMP). These can be encoded with 2 bytes, but China has compelled software makers to support all code points since some Chinese symbols are not contained in the BMP.</p>
<h4 id="unicode-encoding"><a class="header" href="#unicode-encoding">Unicode encoding</a></h4>
<p>So Unicode represents every character in 32-bits but it would be less than inefficient to store every character in the stream as 32-bits.</p>
<p>Thus a number of encoding formats exist that attempt to losslessly represent 32-bit values in an efficient manner:</p>
<ul>
<li>UTF-8 is backwards compatible with ASCII. ASCII characters require one byte to encode, other characters may require up to 4 bytes depending on their code point.</li>
<li>UTF-16 encodes the characters in Basic Multilingual Plane in two bytes but uses four bytes for code points outside this range. </li>
<li>UTF-32 encodes every character in 4 bytes.</li>
</ul>
<p>Each encoding can be losslessly transformed to the others with helper code such as the popular <code>libicu</code> library.</p>
<p>Generally speaking UTF-8 is the most popular encoding because it is also the most efficient way to store characters most of the time. Even web pages in Japanese contain a lot of ASCII characters for the markup. So the vast majority of content is stored and served up in UTF-8. UTF-16 is not a popular encoding however the Windows operating system and also Java use it for their string encodings due to decisions made to support the BMP before China mandated full code point support.</p>
<h2 id="c--c"><a class="header" href="#c--c">C / C++</a></h2>
<h3 id="there-is-no-string-primitive"><a class="header" href="#there-is-no-string-primitive">There is no string primitive</a></h3>
<p>C and C++ does not have a string primitive type, instead it has a <code>char</code> type, that is one byte. A &quot;string&quot; is a pointer to an array of chars that are terminated with a zero byte, <code>'\0'</code>.</p>
<pre><code class="language-c++">// The array that my_string points at ends with a hidden \0
const char *my_string = &quot;This is as close to a string primitive as you can get&quot;;
printf(&quot;String is %d chars long.\n&quot;, strlen(my_string));
</code></pre>
<h4 id="string-functions"><a class="header" href="#string-functions">String functions</a></h4>
<p>In C, functions such as <code>strlen(s)</code>, <code>strcpy(dst, src)</code>, <code>strdup(s)</code> etc. allow strings to be inspected, copied or duplicated. But they work all work by essentially walking the array of bytes until they reach the <code>\0</code>. So <code>strcpy(dst, src)</code> copies from <code>src</code> to <code>dst</code> a byte at a time up to and including the <code>\0</code>. </p>
<p>But what if <code>dst</code> was not a big enough array to hold the input? Well now we have a buffer overrun which may crash the software, or cause it to be compromisd.</p>
<p>C11 introduces &quot;safe&quot; versions of functions like <code>strcpy</code> that say how large the destination is, i.e. <code>strcpy_s(dst, dstlen, src)</code>. It will not overstep the output buffer's size and if the output is not big enough to hold the input or is truncated, the function will return an error. Even so, we are required to set this size correctly, include space for the terminator byte and test for errors.</p>
<h4 id="stdbasic_string-template"><a class="header" href="#stdbasic_string-template">std::basic_string template</a></h4>
<p>C++ provides <code>std::basic_string&lt;char_type&gt;</code>. Normally <code>char_type</code> would be a <code>char</code> and there is a typedef to <code>std::string</code> which is precisely that. The <code>std::string</code> manages the lifetime of a string and provide methods for modifying the string in a safe manner. It is a vast improvement over C.</p>
<pre><code class="language-c++">#include &lt;string&gt;
//...
std::string my_string = &quot;Mary had a little lamb&quot;;
std::cout &lt;&lt; &quot;String is &quot; &lt;&lt; my_string.size() &lt;&lt; &quot; chars long.&quot; &lt;&lt; std::endl;
</code></pre>
<p>Note that this is not a primitive type. Instead <code>std::string</code> is a fairly opaque template defined in <code>&lt;string&gt;</code> that is included, compiled and linked to the executable just like every other template class. </p>
<p>In addition, a <code>std::string</code> will normally uses the heap to store the string's data which can have repercussions for memory usage and fragmentation. There is also a hidden cost to assigning one string to another strings are duplicated in the process. Operations like <code>substr()</code> create copies of the section of the string.</p>
<pre><code class="language-c++">#include &lt;string&gt;
//...
std::string str = &quot;The Evolution of Man&quot;;
std::string str2 = str.substr(4, 9);
// Str2 contains a copy of &quot;Evolution&quot;
</code></pre>
<p>In this example we use <code>substr()</code> to get a portion of the containing string, but to do so, a new string must be created. In a trivial example it doesn't matter but we might have large loops where a lot of string manipulation is occuring and it becomes inefficient. For example, if the code was consuming records delimited with a <code>|</code> where there might be 100 fields in a record, then we have a lot of allocation going on.</p>
<p>Recognizing this C++17 did this...</p>
<h4 id="stdbasic_string_view-template"><a class="header" href="#stdbasic_string_view-template">std::basic_string_view template</a></h4>
<p>C++17 supports a <code>std::basic_string_view&lt;char_type&gt;</code> template defined in <code>&lt;string_view&gt;</code>. Normally <code>char_type</code> would be a <code>char</code> and there is a typedef <code>std::string_view</code>. A string view is a read-only slice of a string.</p>
<pre><code class="language-c++">#include &lt;string_view&gt;
//...
std::string str = &quot;The Evolution of Man&quot;;
std::string_view sv { str }
std::string_view sv2 { sv.substr(4, 9) };
</code></pre>
<p>In this example, the <code>sv</code> points to <code>str</code> but it does not copy it. Basically it is just a pointer and a length onto the string. And <code>sv2</code> is a pointer and a length onto the substring portion. There is no heap or string copy happening here so it is much more efficient.</p>
<p>This allows string operations to be more efficient, however it requires the underlying string to be read only and for the view to be lifetime dependent on the string. i.e. it offers no guarantees that the view points to anything by the time it is accessed and it is the developers job to make sure it doesn't. For example, if I changed <code>str</code> in the previous example, then <code>sv</code> and <code>sv2</code> could be pointing at junk.</p>
<h3 id="string-encoding-is-whatever-you-want-it-to-be"><a class="header" href="#string-encoding-is-whatever-you-want-it-to-be">String encoding is whatever you want it to be</a></h3>
<p>C++ more or less expects you to know the encoding of your own strings. It has no inherent knowledge that an array of bytes is ASCII, EBDIC, UTF-8 or anything else. What you put in your strings is your own business and it doesn't care if the bytes are valid Unicode encodings or not. </p>
<p>However it does support Unicode if that is your intent. It has a long string notation that indicates a wide character string:</p>
<pre><code class="language-c++">wchar_t *msg = L&quot;Hello World!&quot;;
</code></pre>
<p>The <code>L</code> prefix indicates the string is in a wide format. Unfortunately <code>wchar_t</code> type can be either 2 or 4 bytes wide and is a compiler / platform specific decision. In Microsoft Visual C++ the wide char is 2 bytes and in gcc it can be 2 or 4 bytes according to the compiler flags.</p>
<p>Oops...</p>
<p>So C++11 rectifies this by introducing unambiguous <code>char16_t</code> and <code>char32_t</code> types and corresponding versions of string called <code>std::u16string</code> and <code>std::u32string</code>. It also has string prefixes for declaring encodings of strings when you combine them with <code>auto</code>:</p>
<pre><code class="language-c++">// Wide string with L prefix
wchar_t hello_chinese = L&quot;\u4f60\u597d&quot;;
// C11 and C++11 add UTF string literal prefixes
auto hello_8  = u8&quot;\u4f60\u597d&quot;; // UTF-8 encoded
auto hello_16 =  u&quot;\u4f60\u597d&quot;; // UTF-16
auto hello_32 =  U&quot;\u4f60\u597d&quot;; // UTF-32
</code></pre>
<p>Even with this you can see above that encoding Unicode in your source code isn't very nice. The Unicode characters are escaped. Some C++ compilers may allow the character set of the source file to be encoded (e.g. with UTF-8) to overcome this but it is not a certainty.</p>
<h3 id="character-types"><a class="header" href="#character-types">Character types</a></h3>
<p>So C++ has 4 character types. Great huh?</p>
<div class="table-wrapper"><table><thead><tr><th>Character type</th><th>Encoding</th></tr></thead><tbody>
<tr><td><code>char</code></td><td>C, ASCII, EBDIC, UTF-8, ad hoc, ???</td></tr>
<tr><td><code>wchar_t</code></td><td>UTF-16 or maybe UTF-32</td></tr>
<tr><td><code>char16_t</code></td><td>UTF-16</td></tr>
<tr><td><code>char32_t</code></td><td>UTF-32</td></tr>
</tbody></table>
</div>
<p>You basically cannot assume what a char string is encoded with. To preserve your sanity you are best to choose an encoding, e.g. UTF-8 and enforce it, sanitizing your inputs where you need to. If you are calling external libraries you also need to see what rules they follow for string handling. If necessary you may need to use <code>libicu</code> to properly handle strings including iterating through them since you cannot slice strings without knowing where characters lie in the buffer.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Rust has implicit string in the language itself.</p>
<ul>
<li>A <code>char</code> type is a 32-bit Unicode character.</li>
<li>A <code>str</code> type is a UTF-8 encoded string held in memory. Code will never directly use this type. Instead it will use <code>&amp;str</code> which is a string slice, a pointer and length to the str or a portion of it. </li>
<li>A <code>std::String</code> is a heap allocated <code>str</code> that you can manipulate. Code may also obtain a <code>&amp;str</code> to a <code>String</code> but the compiler will enforce that the string is read-only while the slice exists upon it.</li>
</ul>
<p>Finally there are foreign function interface (FFI) types <code>OSString</code> and <code>OSStr</code> akin to <code>String</code> and <code>str</code> that handles any differences in how the outside world sees strings compared to Rust, e.g. changing the character width or encoding and putting a null terminator on the end. Normally you would only use these types when you need to call an external API.</p>
<h2 id="types-comparison"><a class="header" href="#types-comparison">Types Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>C/C++</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>char *</code> or <code>wchar_t *</code></td><td><code>str</code>, <code>&amp;str</code></td></tr>
<tr><td></td><td><code>OSStr</code>, <code>&amp;OSStr</code> (FFI)</td></tr>
<tr><td>C11</td><td></td></tr>
<tr><td><code>char16_t *</code>, <code>char32_t *</code></td><td><code>str</code>, <code>&amp;str</code></td></tr>
<tr><td>C++11</td><td></td></tr>
<tr><td><code>std::string</code>, <code>std::wstring</code>, <code>std::u16string</code>, <code>std::u32string</code></td><td><code>std::String</code></td></tr>
<tr><td></td><td><code>OSString</code> (FFI)</td></tr>
</tbody></table>
</div>
<h3 id="slices"><a class="header" href="#slices">Slices</a></h3>
<p>A <em>slice</em> is a reference to some or all of a <code>str</code>. It is written <code>&amp;str</code> and also contains a pointer and a byte length value. </p>
<p>We saw that C++17 introduces a <code>std::string_view</code> and it's like that, but it is an intrinsic part of the language and the compiler makes sure you cannot use the slice unsafely.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These variables are &amp;str pointing to a str consisting of UTF-8 encoded bytes
let my_str = &quot;Hello&quot;; 
let hello_chinese = &quot;你好&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Type inferences for these assignments will create a <code>&amp;str</code> slice pointing to the statically allocated <code>str</code> and its bytes. The data itself doesn't move and the <code>&amp;str</code> is implicitly read-only.</p>
<p>There is no need for the different prefixes in C++ for different character widths as it is implicitly Unicode. The developer may type any Unicode they like into their UTF-8 encoded source code or between string delimiters and the compiler will just take it. </p>
<p>The <code>str</code> has functions for iterating over the string in bytes / characters, for creating slices, to find a pattern etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;Hello&quot;; // v is a &amp;’static str
println!(&quot;My string is {} and it is {} bytes long&quot;, v, v.len());
<span class="boring">}
</span></code></pre></pre>
<p>Note <code>len()</code> is the length in bytes because strings are UTF-8 encoded. A single character may be encoded as 1, 2, 3, or 4 bytes. It may not be the number of characters a human would actually see. Characters may even be clustered together to form a graphene.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;你好&quot;;
println!(&quot;Number of bytes = {}&quot;, my_str.len());
println!(&quot;Number of chars = {}&quot;, my_str.chars().count());
<span class="boring">}
</span></code></pre></pre>
<pre><code>Number of bytes = 6
Number of chars = 2
</code></pre>
<p>You can split a <code>&amp;str</code> to produce a left and a right <code>&amp;str</code> slice like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (part1, part2) = &quot;Hello&quot;.split_at(3);
println!(&quot;Part 1 = {}&quot;, part1);
println!(&quot;Part 2 = {}&quot;, part2);
<span class="boring">}
</span></code></pre></pre>
<pre><code>Part 1 = Hel
Part 2 = lo
</code></pre>
<h3 id="raw-strings"><a class="header" href="#raw-strings">Raw strings</a></h3>
<p>A raw string is a convenience for strings that contain backslashes, quotes etc. that you don't want to have to escape out.</p>
<p>It is a Unicode string starting with <code>r&quot;</code> prefix. If your string contains a double quotation mark you can also put one or more hashes around the outer quotes, <code>r#&quot;A quote is this symbol &quot;&quot;#;</code>. You could even put more hashes if your string contained <code>#&quot;</code>, e.g. <code>r##&quot;</code>, <code>&quot;##</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let quote = r#&quot;And the man said &quot;the best is yet to come&quot;&quot;#;
let multiline = r&quot;All good things
to those who wait&quot;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="byte-strings"><a class="header" href="#byte-strings">Byte strings</a></h3>
<p>A byte string is just an unchecked byte array that is not assumed to be any kind of encoding:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
let b = b&quot;SUCCESS\x0f&quot;;
}
</code></pre></pre>
<p>In this case, <code>b</code> is a reference to a static byte array <code>&amp;'static [u8]</code>. There is no <code>str</code>. This may be useful for reading data from a stream where there is no assumption about its encoding.</p>
<h1 id="unicode-1"><a class="header" href="#unicode-1">Unicode</a></h1>
<p>As state already strings are Unicode. It is worth remember that internally the string is UTF-8 encoded. What that means is you have to be a little careful conflating length with number of characters. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = &quot;你好&quot;;
    println!(&quot;Length of string = {}&quot;, s.len());
    s.chars().for_each(|c| {
      println!(&quot;Char = {}&quot;, c);
    })
}
</code></pre></pre>
<p>And the output would be:</p>
<pre><code>Length of string = 6
Char = 你
Char = 好
</code></pre>
<p>Notice that the <em>length</em> of the string is 6 bytes, but there are only two characters. It takes 6 bytes to UTF-8 encode the string and that is what is referring to. Functions that manipulate strings will be indexed by byte too and will error if you are incorrect. Therefore, you are better to use <code>chars()</code> for character wise operation.</p>
<p>So a <code>char</code> in Rust is a Unicode character, 32-bits. This may seem weird at first but remember that Rust has explicit <code>i8</code> and <code>u8</code> types if you really want to deal in bytes. But strings in Rust are not bytes, they're characters.</p>
<p>It gets more complex than &quot;character&quot; though because some languages have clusters of characters that are known as graphene clusters, which are akin to letters. So a character may be an adornment for another character, not necessarily printable. Therefore even with Unicode baked in you may find your code has to have special knowledge of what it is doing to make sense for what the user sess.</p>
<p>In addition, to manipulate strings, then there is a type for that purpose, <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;你好&quot;);
    s.push_str(&quot;世界&quot;);
    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<h2 id="stdbasic_string-c-vs-stdstring-rust"><a class="header" href="#stdbasic_string-c-vs-stdstring-rust">std::basic_string (C++) vs std::String (Rust)</a></h2>
<p>The standard C++ library also has template class <code>std::basic_string</code> that acts as a wrapper around the various character types and can be used for manipulating a string of any width. This template is specialised as<br />
<code>std::string</code>, <code>std:wstring</code>, <code>std::u16string</code> and <code>std::u32string</code>.</p>
<pre><code class="language-c++">std::string my_str = &quot;Hello&quot;;
my_str += &quot; world&quot;;

// C++11 also allows some type inference with autos
auto s1 =   &quot;Hello&quot;s; // std::string
auto s2 = u8&quot;Hello&quot;s; // std::string, forces UTF-8 encoding
auto s3 = L&quot;Hello&quot;s;  // std::wstring
auto s4 = u&quot;Hello&quot;s;  // std::u16string
auto s5 = U&quot;Hello&quot;s;  // std::u32string
</code></pre>
<p>In Rust, the <code>std::String</code> type serves the same purpose:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = String::from(&quot;Hello&quot;);
v.push_str(&quot; world&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Using it is fairly simple</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = String::from(&quot;This is a String&quot;);
v.push_str(&quot; that we can modify&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>A <code>String</code> has functions to do actions such as appending, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = String::from(&quot; Bananas&quot;);
let mut result = String::new();
result.push_str(&quot;Apples &quot;);
result.push('&amp;'); // Push a char
result.push_str(b.as_str());
println!(&quot;result = {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<p>Strings are always valid UTF-8.</p>
<p>Internally a String has a pointer to the data, its length and a capacity (max size). If you intend to expand a string, then you should ensure the <code>String</code> has sufficient capacity to accommodate its longest value otherwise you may cause it to reallocate itself excessively.</p>
<p>Strings will never shrink their capacity unless you explicitly call <code>shrink_to_fit()</code>. This means if you use a temporary string in a loop, it's probably best to place it outside the loop and reserve space to make it efficient.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = String::with_capacity(100);
// or
let mut v = String::new();
v.reserve_exact(100);
<span class="boring">}
</span></code></pre></pre>
<p>Strings also have all the methods of str thanks to implementing <code>Deref</code> trait.</p>
<h3 id="formatting-strings"><a class="header" href="#formatting-strings">Formatting strings</a></h3>
<p>Strings can be formatted in C with <code>printf</code> or <code>sprintf</code> or in C++ composed with stream operators, e.g. to a <code>std::stringstream</code>.</p>
<p>Rust uses <code>format!</code> and <code>println!</code> macros that more resemble the <code>sprintf</code> model. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">C++</th><th style="text-align: left">Rust formatting trait</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>%s</code>, <code>%u</code>, <code>%d</code>, <code>%i</code>, <code>%f</code>, <code>%c</code></td><td style="text-align: left"><code>{}</code></td><td style="text-align: left">C/C++ require the type of the parameter to be specified. In Rust the type is inferred and <code>{}</code> will invoked the type's Display trait regardless of what it is. So a String outputs its text, numeric types return their value, boolean as returns true or false, and so on.</td></tr>
<tr><td style="text-align: left"><code>%lld</code>, <code>%llu</code></td><td style="text-align: left"><code>{}</code></td><td style="text-align: left">C/C++ has extensions to deal with different size ints and floats, e.g. ll for long long due to the way arguments are passed to the function. In Rust, there is no need for that.</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>{:?}</code>, <code>{:#?}</code></td><td style="text-align: left">In Rust <code>{:?}</code> returns whatever is implemented by a type's Debug trait. The <code>{:#?}</code> variant can be used to pretty-print the output for types that derive the Debug trait.</td></tr>
<tr><td style="text-align: left"><code>%-10s</code></td><td style="text-align: left"><code>{:&lt;10}</code></td><td style="text-align: left">Format left aligned string padded to minimum of 10 spaces</td></tr>
<tr><td style="text-align: left"><code>%04</code></td><td style="text-align: left"><code>{:04}</code></td><td style="text-align: left">Pad a number with zero's to a width of 4</td></tr>
<tr><td style="text-align: left"><code>%.3</code></td><td style="text-align: left"><code>{:.3}</code></td><td style="text-align: left">Pad a number's precision to 3 decimal places. May also be zero-padded, e.g. {:.03}</td></tr>
<tr><td style="text-align: left"><code>%e</code>, <code>%E</code></td><td style="text-align: left"><code>{:e}</code>, <code>{:E}</code></td><td style="text-align: left">Exponent in lower or uppercase</td></tr>
<tr><td style="text-align: left"><code>%x</code>, <code>%X</code></td><td style="text-align: left"><code>{:x}</code>, <code>{:X}</code></td><td style="text-align: left">Hexadecimal in lower or uppercase. Note <code>{:#x}</code>, <code>{:#X}</code> prefixes the output with 0x</td></tr>
<tr><td style="text-align: left"><code>%o</code></td><td style="text-align: left"><code>{:o}</code></td><td style="text-align: left">Octal. Note <code>{:#o}</code> prefixes the output with 0o</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>{:b}</code></td><td style="text-align: left">Binary. Note <code>{:#b}</code> prefixes the output with 0b</td></tr>
<tr><td style="text-align: left"><code>%p</code></td><td style="text-align: left"><code>{:p}</code></td><td style="text-align: left">Presents a struct's memory location, i.e. pointer</td></tr>
</tbody></table>
</div>
<p>Rust has many <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">more formatting traits</a> than this.</p>
<p>For example it allows named parameters like this example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = format!(&quot;The temperature {temp}C is within {percent} of maximum&quot;, temp = 104, percent = 99);
<span class="boring">}
</span></code></pre></pre>
<p>Named parameters would be particularly useful for localization where the order of values may be different in one language compared to another.</p>
<h2 id="display-and-debug-traits"><a class="header" href="#display-and-debug-traits">Display and Debug traits</a></h2>
<p>Rust allows types to be formatted as strings based upon the formatting traits they implement.</p>
<p>The two main implementation traits are:</p>
<ul>
<li><code>Display</code> - this is for standard textual representation of a type.</li>
<li><code>Debug</code> - this is for the debugging textual representation of a type. It might present additional information or be formatted separately to the Display trait. It is possible to <code>#[derive(Debug)]</code> this trait which is usually enough for the purpose of debugging.</li>
</ul>
<p>If we look at the traits we can see they're identical</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// std::fmt::Display
pub trait Display {
    fn fmt(&amp;self, &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}
// std::fmt::Debug
pub trait Debug {
    fn fmt(&amp;self, &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>All of the intrinsic types implement <code>Display</code> and <code>Debug</code>. We can explicitly implement Display on our own structs too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::{self, Formatter, Display};

struct Person {
  first_name: String,
  last_name: String,
}

impl Display for Person {
  fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
    write!(f, &quot;{} {}&quot;, self.first_name, self.last_name)
  }
}
//...
let person = Person { first_name: &quot;Susan&quot;.to_string(), last_name: &quot;Smith&quot;.to_string() };
println!(&quot;Person - {}&quot;, person);
<span class="boring">}
</span></code></pre></pre>
<pre><code>Person - Susan Smith
</code></pre>
<p>Implementing <code>Debug</code> is usually done by <code>#[derive(Debug)]</code> but it could also be implemented. The derived <code>Debug</code> will print out the struct name, and then the members in curly braces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Person {
  //...
}
//...
println!(&quot;Person - {:?}&quot;, person);
<span class="boring">}
</span></code></pre></pre>
<pre><code>Person - Person { first_name: &quot;Susan&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>Many types process formatting traits which are values held between the <code>{}</code> braces in the string. These are fairly similar to the patterns used in C functions for printf, sprintf etc.</p>
<h2 id="osstring--osstr"><a class="header" href="#osstring--osstr">OsString / OsStr</a></h2>
<p>Rust recognises there are times when you need to pass or receive a string from a system API.</p>
<p>In this case you may use <code>OsString</code> which allows interchange between Rust and a system dependent representations of strings. On Windows it will return UTF-16 strings, on Linux / Unix systems it will return UTF-8.</p>
<p>An <code>OsStr</code> is a slice onto <code>OsString</code>, analogous to <code>str</code> and <code>String</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../09_features_compared/types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../09_features_compared/variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../09_features_compared/types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../09_features_compared/variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
