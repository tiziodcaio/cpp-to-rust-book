<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Multi-threading - A Guide to Porting C/C++ to Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book that explains how to port code from C++ to Rust.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="../foreword.html"><strong aria-hidden="true">3.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="../credits.html"><strong aria-hidden="true">4.</strong> Credits</a></li><li class="chapter-item expanded "><a href="../notation.html"><strong aria-hidden="true">5.</strong> Notation used through this book</a></li><li class="chapter-item expanded "><a href="../01_setting_up_rust/index.html"><strong aria-hidden="true">6.</strong> Setting Up Rust</a></li><li class="chapter-item expanded "><a href="../02_c_and_cpp_background/index.html"><strong aria-hidden="true">7.</strong> C and C++ Background</a></li><li class="chapter-item expanded "><a href="../03_rust_background/index.html"><strong aria-hidden="true">8.</strong> Rust Background</a></li><li class="chapter-item expanded "><a href="../04_start_simple/index.html"><strong aria-hidden="true">9.</strong> Let's Start Simple</a></li><li class="chapter-item expanded "><a href="../05_compiling_and_linking/index.html"><strong aria-hidden="true">10.</strong> Compiling and Linking in More Detail</a></li><li class="chapter-item expanded "><a href="../06_source_layout/index.html"><strong aria-hidden="true">11.</strong> Source Layout and Other General Points</a></li><li class="chapter-item expanded "><a href="../07_namespacing_with_modules/index.html"><strong aria-hidden="true">12.</strong> Namespacing With Modules</a></li><li class="chapter-item expanded "><a href="../08_porting_code/index.html"><strong aria-hidden="true">13.</strong> Porting Code</a></li><li class="chapter-item expanded "><a href="../09_features_compared/index.html"><strong aria-hidden="true">14.</strong> Features of Rust compared with C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_features_compared/types.html"><strong aria-hidden="true">14.1.</strong> Types</a></li><li class="chapter-item expanded "><a href="../09_features_compared/strings.html"><strong aria-hidden="true">14.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../09_features_compared/variables.html"><strong aria-hidden="true">14.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../09_features_compared/literals.html"><strong aria-hidden="true">14.4.</strong> Literals</a></li><li class="chapter-item expanded "><a href="../09_features_compared/collections.html"><strong aria-hidden="true">14.5.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../09_features_compared/structs.html"><strong aria-hidden="true">14.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../09_features_compared/comments.html"><strong aria-hidden="true">14.7.</strong> Comments</a></li><li class="chapter-item expanded "><a href="../09_features_compared/references_and_borrowing.html"><strong aria-hidden="true">14.8.</strong> Lifetimes, References and Borrowing</a></li><li class="chapter-item expanded "><a href="../09_features_compared/expressions.html"><strong aria-hidden="true">14.9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/conditions.html"><strong aria-hidden="true">14.10.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/match.html"><strong aria-hidden="true">14.11.</strong> Switch / Match</a></li><li class="chapter-item expanded "><a href="../09_features_compared/casting.html"><strong aria-hidden="true">14.12.</strong> Casting</a></li><li class="chapter-item expanded "><a href="../09_features_compared/enums.html"><strong aria-hidden="true">14.13.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../09_features_compared/loops.html"><strong aria-hidden="true">14.14.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../09_features_compared/functions.html"><strong aria-hidden="true">14.15.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../09_features_compared/polymorphism.html"><strong aria-hidden="true">14.16.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../09_features_compared/error_handling.html"><strong aria-hidden="true">14.17.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../09_features_compared/closures.html"><strong aria-hidden="true">14.18.</strong> Lambda Expressions / Closures</a></li><li class="chapter-item expanded "><a href="../09_features_compared/generics.html"><strong aria-hidden="true">14.19.</strong> Templates / Generics</a></li><li class="chapter-item expanded "><a href="../09_features_compared/attributes.html"><strong aria-hidden="true">14.20.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="../09_features_compared/multthreading.html" class="active"><strong aria-hidden="true">14.21.</strong> Multi-threading</a></li><li class="chapter-item expanded "><a href="../09_features_compared/lint.html"><strong aria-hidden="true">14.22.</strong> Lint</a></li><li class="chapter-item expanded "><a href="../09_features_compared/macros.html"><strong aria-hidden="true">14.23.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../09_features_compared/memory_allocation.html"><strong aria-hidden="true">14.24.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../09_features_compared/ffi.html"><strong aria-hidden="true">14.25.</strong> Foreign Function Interface</a></li></ol></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/index.html"><strong aria-hidden="true">15.</strong> Porting from C/C++ to Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_porting_from_cpp/copy_constructors.html"><strong aria-hidden="true">15.1.</strong> Copy Constructor / Assignment Operators</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/missing_braces.html"><strong aria-hidden="true">15.2.</strong> Missing Braces in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/assignments_in_conditionals.html"><strong aria-hidden="true">15.3.</strong> Assignment in Conditionals</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_member_initialisation.html"><strong aria-hidden="true">15.4.</strong> Class Member Initialisation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/splitting_code_between_headers_and_sources.html"><strong aria-hidden="true">15.5.</strong> Headers and Sources</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/forward_declarations.html"><strong aria-hidden="true">15.6.</strong> Forward Declarations</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/namespace_collisions.html"><strong aria-hidden="true">15.7.</strong> Namespace Collisions</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/macros.html"><strong aria-hidden="true">15.8.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/type_mismatching.html"><strong aria-hidden="true">15.9.</strong> Type Mismatching</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/class_constructors.html"><strong aria-hidden="true">15.10.</strong> Explicit / Implicit Class Constructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/poor_lifetime_enforcement.html"><strong aria-hidden="true">15.11.</strong> Poor Lifetime Enforcement</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/memory_allocation.html"><strong aria-hidden="true">15.12.</strong> Memory Allocation</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/null_pointers.html"><strong aria-hidden="true">15.13.</strong> Null Pointers</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/virtual_destructors.html"><strong aria-hidden="true">15.14.</strong> Virtual Destructors</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/exceptions.html"><strong aria-hidden="true">15.15.</strong> Exception Handling / Safety</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/templates.html"><strong aria-hidden="true">15.16.</strong> Templates vs Generics</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/multiple_inheritance.html"><strong aria-hidden="true">15.17.</strong> Multiple Inheritance</a></li><li class="chapter-item expanded "><a href="../10_porting_from_cpp/linker.html"><strong aria-hidden="true">15.18.</strong> Linker Errors</a></li></ol></li><li class="chapter-item expanded "><a href="../11_debugging_rust/index.html"><strong aria-hidden="true">16.</strong> Debugging Rust</a></li><li class="chapter-item expanded "><a href="../12_memory_management/index.html"><strong aria-hidden="true">17.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../13_std_library/index.html"><strong aria-hidden="true">18.</strong> Rust's std:: library</a></li><li class="chapter-item expanded "><a href="../14_rust_cookbook/index.html"><strong aria-hidden="true">19.</strong> Rust Cookbook</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Guide to Porting C/C++ to Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="multithreading"><a class="header" href="#multithreading">Multithreading</a></h1>
<p>Multithreading allows you to run parts of your programming concurrently, performing tasks in parallel. Every program has a <em>main</em> thread - i.e. the one your <code>main()</code> started from, in addition to which are any that you create.</p>
<p>Examples of reasons to use threads:</p>
<ul>
<li>Long running operations, e.g. zipping up a large file.</li>
<li>Activity that is blocking in nature, e.g. listening for connections on a socket</li>
<li>Processing data in parallel, e.g. physics, collision detection etc.</li>
<li>Asynchronous activities, e.g. timers, polling operations.</li>
</ul>
<p>In addition, if you use a graphical toolkit, or 3rd party libraries they may spawn their own threads that you do not know about. </p>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread safety</a></h2>
<p>One word you will hear a lot in multithreading is thread safety. </p>
<p>By that we mean:</p>
<ul>
<li>Threads should not be able to modify the data at the same time. When this happens it is called a data race and can corrupt the data, causing a crash. e.g. two threads trying to append to a string at the same time.</li>
<li>Threads must not lock resources in a way that could cause deadlock i.e. thread 1 obtains a lock on resource B and blocks on resource A, while thread 2 obtains a lock on resource A and blocks on resource B. Both threads are locked forever waiting for a resource to release that never will be.</li>
<li>Race conditions are bad, i.e. the order of thread execution produces unpredictable results on the output from the same input.</li>
<li>APIs that can be called by multiple threads must either protect their data structures or make it an explicit problem of the client to sort out.</li>
<li>Open files and other resources that are accessed by multiple threads must be managed safely.</li>
</ul>
<h3 id="protecting-shared-data"><a class="header" href="#protecting-shared-data">Protecting shared data</a></h3>
<p>Data should never be read at the same time it is written to in another thread. Nor should data be written to at the same time by two threads.</p>
<p>The common way to prevent this is either:</p>
<ul>
<li>Use a mutex to guard access to the data. A mutex is a special class that only one thread can lock at a time. Other threads that try to lock the mutex will wait until the lock held by another thread is relinquished</li>
<li>Use a read-write lock. Similar to a mutex, it allows one thread to lock the thread for writing data, however it permits multiple threads to have read access, providing nothing is already writing to it. For data that is read more frequently than it is modified, this is a lot more efficient than just a mutex.</li>
</ul>
<h3 id="avoiding-deadlock"><a class="header" href="#avoiding-deadlock">Avoiding deadlock</a></h3>
<p>The best way to avoid deadlock is only ever obtain a lock to one thing ever and release it as soon as you are done. But if you have to lock more than one thing, ensure the locking order is consistent between all your threads. So if thread 1 locks A and B, then ensure that thread 2 also locks A and B in that order and not B then A. The latter is surely going to cause a deadlock.</p>
<h2 id="c--c"><a class="header" href="#c--c">C / C++</a></h2>
<p>C and C++ predate threading to some extent so until C++11 the languages have had little built-in support for multi-threading and what there was tended to be compiler specific extensions.</p>
<p>A consequence of this is that C and C++ have ZERO ENFORCEMENT of thread safety. If you data race - too bad. If you forget to write a lock in one function even if you remembered all the others - too bad. You have to discipline yourself to think concurrently and apply the proper protections where it is required. </p>
<p>The consequence of not doing so may not even be felt until your software is in production and that one customer starts complaining that their server freezes about once a week. Good luck finding that bug!</p>
<h3 id="multithreading-apis"><a class="header" href="#multithreading-apis">Multithreading APIs</a></h3>
<p>The most common APIs would be:</p>
<ul>
<li><code>&lt;thread&gt;</code>, <code>&lt;mutex&gt;</code> - from C++11 onwards</li>
<li>POSIX threads, or pthreads. Exposed by POSIX systems such as Linux and most other Unix derivatives, e.g. OS X. There is also pthread-win32 support built over the top of Win32 threads.</li>
<li>Win32 threads. Exposed by the Windows operating system.</li>
<li>OpenMP. Supported by many C++ compilers.</li>
<li>3rd party libraries like Boost and Qt provide wrappers that abstract the differences between thread APIs. </li>
</ul>
<p>All APIs will have in common:</p>
<ul>
<li>Thread creation, destruction, joins (waiting on threads) and detaches (freeing the thread to do what it likes).</li>
<li>Synchronization between threads using locks and barriers.</li>
<li>Mutexes - mutual exclusion locks that protect shared data.</li>
<li>Conditional variables - a means to signal and notify of conditions becoming true.</li>
</ul>
<h3 id="stdthread"><a class="header" href="#stdthread">std::thread</a></h3>
<p>The <code>std::thread</code> represents a single thread of execution and provides an abstraction over platform dependent ways of threading.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void DoWork(int loop_count) {
    for (int i = 0; i &lt; loop_count; ++i) {
        cout &lt;&lt; &quot;Hello world &quot; &lt;&lt; i &lt;&lt; endl;
    }
}

int main() {
    thread worker(DoWork, 100);
    worker.join();
}
</code></pre>
<p>The example spawns a thread which invokes the function and passes the parameter into it, printing a message 100 times.</p>
<h3 id="stdmutex"><a class="header" href="#stdmutex">std::mutex</a></h3>
<p>C++ provides a family of various <code>mutex</code> types to protect access to shared data.</p>
<p>The mutex is obtained by a <code>lock_guard</code> and other attempts to obtain the mutex are blocked until the lock is relinquished.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

using namespace std;

mutex data_guard;
int result = 0;

void DoWork(int loop_count) {
	for (auto i = 0; i &lt; loop_count; ++i) {
		lock_guard&lt;mutex&gt; guard(data_guard);
		result += 1;
	}
}

int main() {
	thread worker1(DoWork, 100);
	thread worker2(DoWork, 150);
	worker1.join();
	worker2.join();
	cout &lt;&lt; &quot;result = &quot; &lt;&lt; result &lt;&lt; endl;
}
</code></pre>
<h3 id="posix-threads"><a class="header" href="#posix-threads">POSIX threads</a></h3>
<p>The pthreads API is prefixed <code>pthread_</code> and works like so:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;

using namespace std;

void *DoWork(void *data) {
    const int loop_count = (int) data;
    for (int i = 0; i &lt; loop_count; ++i) {
        cout &lt;&lt; &quot;Hello world &quot; &lt;&lt; i &lt;&lt; endl;
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t worker_thread;
    int result = pthread_create(&amp;worker_thread, NULL, DoWork, (void *) 100);
    // Wait for the thread to end
    result = pthread_join(worker_thread, NULL);
}
</code></pre>
<p>This example spawns a thread which invokes DoWork with the payload of 100 which causes the function to print a message 100 times.</p>
<h3 id="win32-threads"><a class="header" href="#win32-threads">Win32 Threads</a></h3>
<p>Win32 threading has functions analogous to those in POSIX. They have names such as <code>CreateThread</code>, <code>ExitThread</code>, <code>SetThreadPriority</code> etc.</p>
<h3 id="openmp-api"><a class="header" href="#openmp-api">OpenMP API</a></h3>
<p>Open Multi-Processing (OpenMP) is an API for multi-threaded parallel processing. OpenMP relies on compiler support because you use special <code>#pragma</code> directives in your source to control thread creation and access to data.</p>
<p>GCC, Clang and Visual C++ have support for OpenMP so it is an option.</p>
<p>OpenMP is a complex standard but the use of directives can make for cleaner code than invoking threading APIs directly. The downside is it is also more opaque hiding what the software is doing, making it considerably more difficult to debug.</p>
<p>OpenMP is described in detail at the OpenMP <a href="http://www.openmp.org/">website</a>.</p>
<h3 id="thread-local-storage"><a class="header" href="#thread-local-storage">Thread local storage</a></h3>
<p>Thread local storage, or TLS is static or global data which is private to every thread. Each thread holds its own copy of this data so it can modify it without fear of causing a data race.</p>
<p>Compilers also have proprietary ways to decorate types as thread local:</p>
<pre><code class="language-c++">__thread int private; // gcc / clang
__declspec(thread) int private; // MSVC
</code></pre>
<p>C++11 has gained a <code>thread_local</code> directive to decorate variables which should use TLS.</p>
<pre><code class="language-c++">thread_local int private
</code></pre>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>We saw with C++ that you had to be disciplined to remember to protect data from race conditions. </p>
<p>Rust doesn't give you that luxury -</p>
<ol>
<li>Any data that you share must be protected in a thread safe fashion</li>
<li>Any data that you pass between threads must be marked thread safe</li>
</ol>
<h3 id="spawning-a-thread"><a class="header" href="#spawning-a-thread">Spawning a thread</a></h3>
<p>Spawning a thread is easy enough by calling <code>spawn</code>, supplying the closure you want to run in the context of your new thread.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

thread::spawn(move || {
  println!(&quot;Hello&quot;);
});
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively you can supply a function to <code>spawn</code> which is called in the same manner.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn my_thread() {
  println!(&quot;Hello&quot;);
}
//...
thread::spawn(my_thread);
<span class="boring">}
</span></code></pre></pre>
<p>If you supply a closure then it must have a lifetime of <code>'static</code> because threads can outlive the thing that created them. i.e. they are detached by default. </p>
<p>A closure can make use of move values that are marked <code>Send</code> so the compiler allows ownership to transfer between threads.</p>
<p>Likewise function / closure may also return a value which is marked <code>Send</code> so the compiler can transfer ownership between the terminating thread and the thread which calls <code>join</code> to obtain the value.</p>
<p>So the thread above is detached. If we wanted to wait for the thread to complete, the <code>spawn</code> returns a <code>JoinHandle</code> that we can call <code>join</code> to wait for termination.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let h = thread::spawn(move || {
  println!(&quot;Hello&quot;);
});
h.join();
<span class="boring">}
</span></code></pre></pre>
<p>If the closure or function returns a value, we can use <code>join</code> to obtain it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let h = thread::spawn(move || 100 * 100);
let result = h.join().unwrap();
println!(&quot;Result = {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<h3 id="data-race-protection-in-the-compiler"><a class="header" href="#data-race-protection-in-the-compiler">Data race protection in the compiler</a></h3>
<p>Data races are bad news, but fortunately in Rust the compiler has your back. You MUST protect your shared data or it won't compile.</p>
<p>The simplest way to protect your data is to wrap the data in a mutex and provide each thread instance with a reference counted copy of the mutex.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shared_data = Arc::new(Mutex::new(MySharedData::new()));

// Each thread we spawn should have a clone of this Arc
let shared_data = shared_data.clone();
thread::spawn(move || {
  let mut shared_data = shared_data.lock().unwrap();
  shared_data.counter += 1;
});
<span class="boring">}
</span></code></pre></pre>
<p>Here is a full example that spawns 10 threads that each increment the counter.</p>
<pre><pre class="playground"><code class="language-rust">struct MySharedData {
  pub counter: u32,
}

impl MySharedData {
  pub fn new() -&gt; MySharedData {
    MySharedData {
	  counter: 0
	}
  }
}

fn main() {
  spawn_threads();
}

fn spawn_threads() {
  let shared_data = Arc::new(Mutex::new(MySharedData::new()));
  
  // Spawn a number of threads and collect their join handles
  let handles: Vec&lt;JoinHandle&lt;_&gt;&gt; = (0..10).map(|_| {
	let shared_data = shared_data.clone();
    thread::spawn(move || {
	  let mut shared_data = shared_data.lock().unwrap();
	  shared_data.counter += 1;
	})
  }).collect();
  
  // Wait for each thread to complete
  for h in handles {
    h.join();
  }
  
  // Print the data
  let shared_data = shared_data.lock().unwrap();
  println!(&quot;Total = {}&quot;, shared_data.counter);
}
</code></pre></pre>
<p>So the basic strategy will be this:</p>
<ol>
<li>Every thread will get it's own atomic reference to the mutex. </li>
<li>Each thread that wishes to access the shared must obtain a lock on the mutex.</li>
<li>Once the lock is released, the next waiting thread can obtain access.</li>
<li>The compiler will enforce this and generate errors if ANYTHING is wrong.</li>
</ol>
<h3 id="read-write-lock"><a class="header" href="#read-write-lock">Read Write Lock</a></h3>
<p>A read write lock works much like a mutex - we wrap the shared data in a <code>RwLock</code>, and then in an <code>Arc</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shared_data = Arc::new(RwLock::new(MySharedData::new()));
<span class="boring">}
</span></code></pre></pre>
<p>Each thread will then either need to obtain a read lock or a write lock on the shared data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shared_data = shared_data.read().unwrap();
// OR
let mut shared_data = shared_data.write().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The advantage of a <code>RwLock</code> is that many threads can concurrently read the data, providing nothing is writing to it. This may be more efficient in many cases.</p>
<h3 id="sending-data-between-threads-using-channels"><a class="header" href="#sending-data-between-threads-using-channels">Sending data between threads using channels</a></h3>
<p>TODO mpsc channel</p>
<h3 id="thread-local-storage-1"><a class="header" href="#thread-local-storage-1">Thread local storage</a></h3>
<p>As with C++ you may have reason to use thread local storage</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread_local! {
  // TODO
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="useful-crates"><a class="header" href="#useful-crates">Useful crates</a></h3>
<h4 id="rayon"><a class="header" href="#rayon">Rayon</a></h4>
<p>The <a href="https://github.com/rayon-rs/rayon">rayon</a> crate implements parallel iterators that allow your collections to be iterated in parallel. The crate
utilises work stealing and divide and conquer algorithms couple to a thread pool to process collections more quickly
than they could be in a sequential fashion.</p>
<p>Generally speaking this is a drop-in replacement with the exception that you call <code>par_iter</code> instead of <code>iter</code>. The crate
implements a <code>ParallelIterator</code> trait on collection classes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;
fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.par_iter()
         .map(|&amp;i| i * i)
         .sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>See the crate site for more information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../09_features_compared/attributes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../09_features_compared/lint.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../09_features_compared/attributes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../09_features_compared/lint.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
